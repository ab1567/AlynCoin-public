#include "blockchain.h"
#include "blake3.h"
#include "json/json.h"
#include <iomanip>
#include <iostream>
#include <fstream>
#include <thread>
#include <chrono>
#include <mutex>
#include <algorithm>
#include <atomic>
#include "transaction.h"
#include "crypto_utils.h"
#include <locale>
#include "network.h"
#include <sys/stat.h>
#include <filesystem>
#include <rocksdb/db.h>

// Global mutex for blockchain safety
std::mutex blockchainMutex;
std::atomic<bool> Blockchain::isMining{false};

// âœ… **Destructor: Close RocksDB**
Blockchain::~Blockchain() {
    delete db;  // âœ… Clean up RocksDB
}
// âœ… **Constructor: Open RocksDB**
Blockchain::Blockchain(unsigned short port) : difficulty(4), miningReward(10.0) {
    network = new Network(port);

    // âœ… Open RocksDB
    rocksdb::Options options;
    options.create_if_missing = true;
    rocksdb::Status status = rocksdb::DB::Open(options, "data/blockchain_db", &db);
    
    if (!status.ok()) {
        std::cerr << "âŒ Error opening RocksDB: " << status.ToString() << std::endl;
        exit(1);
    }

    loadFromDB(); // âœ… Load blockchain from RocksDB
    loadTransactionsFromDB();
}

// âœ… **Validate a Transaction**
bool Blockchain::isTransactionValid(const Transaction& tx) const {
    std::string senderLower = tx.getSender();
    std::transform(senderLower.begin(), senderLower.end(), senderLower.begin(), ::tolower);
    
    std::string publicKeyPath = "keys/" + senderLower + "_public.pem";

    // **Check if public key exists before proceeding**
    std::ifstream pubKeyFile(publicKeyPath);
    if (!pubKeyFile.good()) {
        std::cerr << "âŒ Error: Public key file not found: " << publicKeyPath << "! Retrying...\n";
        Crypto::generateKeysForUser(senderLower);  // Attempt to regenerate keys

        // **Wait briefly to ensure key is saved**
        std::this_thread::sleep_for(std::chrono::milliseconds(300));

        // **Re-check the file after generation**
        pubKeyFile.open(publicKeyPath);
        if (!pubKeyFile.good()) {
            std::cerr << "âŒ Critical Error: Failed to generate or load public key for " << senderLower << "!\n";
            return false;
        }
    }

    std::string transactionHash = tx.calculateHash();
    std::cerr << "ðŸ” [DEBUG] Transaction Hash (Expected for Verification): " << transactionHash << std::endl;
 
   return Crypto::verifyMessage(publicKeyPath, tx.getSignature(), transactionHash);
}

// âœ… Create the Genesis Block Properly
void Blockchain::createGenesisBlock() {
    std::cerr << "âš ï¸ Blockchain empty! Creating Genesis Block..." << std::endl;

    Transaction genesisTx("System", "Genesis", 0.0, "GENESIS_SIGNATURE");
    genesisTx.signTransaction("keys/system_private.pem");  // âœ… Ensure it has a valid signature

    std::vector<Transaction> genesisTransactions = {genesisTx};

    Block genesisBlock(0, "00000000000000000000000000000000", genesisTransactions, "System", 4);
    genesisBlock.mineBlock(4);

    chain.push_back(genesisBlock);
    saveToFile();

    std::cout << "âœ… Genesis Block Created! Hash: " << genesisBlock.getHash() << std::endl;
}
// âœ… Adds block, applies smart burn, and broadcasts to peers
void Blockchain::addBlock(const Block& block) {
    std::lock_guard<std::mutex> lock(blockchainMutex);

    if (block.isValid(chain.back().getHash())) {
        chain.push_back(block);
        saveToFile();
        std::cout << "âœ… Block added successfully!\n";

        // ðŸ“¡ **Broadcast new block to all peers**
        if (network) {
            Json::StreamWriterBuilder writer;
            std::string blockData = R"({"type": "new_block", "data": )" + Json::writeString(writer, block.toJSON()) + "}";

            for (const std::string& peer : network->getPeers()) {
                network->sendData(peer, blockData);
            }

            std::cout << "ðŸ“¡ Broadcasted new block to peers.\n";
        }
    } else {
        std::cerr << "âŒ Invalid block! Rejected.\n";
    }
}
// âœ… Adjust mining difficulty dynamically
void Blockchain::adjustDifficulty() {
    if (chain.size() < 10) return; // Ensure we have enough data for adjustment

    const int difficultyWindow = 10; // Check last 10 blocks
    std::vector<uint64_t> timestamps;
    for (int i = chain.size() - difficultyWindow; i < chain.size(); i++) {
        timestamps.push_back(chain[i].getTimestamp());
    }

    if (timestamps.size() < 2) return; // Not enough data

    double avgBlockTime = (timestamps.back() - timestamps.front()) / (difficultyWindow - 1);

    // Expected block time (target: 30 seconds per block)
    double targetTime = 30.0;

    // Dynamic difficulty update based on mining speed
    if (avgBlockTime < targetTime * 0.8) { // Blocks mined too fast
        difficulty = std::min(difficulty + 1, 8);
        std::cout << "âš¡ Increasing difficulty to: " << difficulty << " (Blocks mined too fast)\n";
    } else if (avgBlockTime > targetTime * 1.2) { // Blocks mined too slow
        difficulty = std::max(difficulty - 1, 4);
        std::cout << "ðŸ¢ Reducing difficulty to: " << difficulty << " (Blocks mined too slow)\n";
    } else {
        std::cout << "âœ… Difficulty remains the same: " << difficulty << std::endl;
    }
}

// âœ… **Singleton Instance**
Blockchain& Blockchain::getInstance(unsigned short port) {
    static Blockchain instance(port);  // âœ… Ensure only one instance
    return instance;
}
//
const std::vector<Block>& Blockchain::getChain() const {
    return chain;
}
//
void Blockchain::clearPendingTransactions() {
    std::lock_guard<std::mutex> lock(blockchainMutex);
    pendingTransactions.clear();

    // âœ… Ensure transactions file is emptied
    std::ofstream outFile("data/transactions.json", std::ios::trunc);
    outFile << "[]";  // Empty JSON array
    outFile.close();

    std::cout << "ðŸš¨ Cleared all pending transactions after mining.\n";
}

// âœ… Helper function to check if a file exists
bool fileExists(const std::string& filename) {
    struct stat buffer;
    return (stat(filename.c_str(), &buffer) == 0);
}

// âœ… **Destructor**
Blockchain::~Blockchain() {
    delete network;  // âœ… Prevent memory leaks
}

// âœ… **Check for pending transactions**
bool Blockchain::hasPendingTransactions() const {
    return !pendingTransactions.empty();  // âœ… Only checks, does not modify!
}

// âœ… Mine pending transactions and dynamically adjust difficulty
Block Blockchain::minePendingTransactions(const std::string& minerAddress) {
    std::lock_guard<std::mutex> lock(blockchainMutex);

    if (pendingTransactions.empty()) {
        std::cerr << "âš ï¸ No transactions to mine!" << std::endl;
        return Block(getLatestBlock().getIndex() + 1, getLatestBlock().getHash(), std::vector<Transaction>(), minerAddress, difficulty);
    }

    std::cout << "â³ Pending Transactions: " << pendingTransactions.size() << std::endl;

    // âœ… Remove Invalid Transactions
    std::vector<Transaction> validTransactions;
    for (const auto& tx : pendingTransactions) {
        if (isTransactionValid(tx)) {
            validTransactions.push_back(tx);
        } else {
            std::cerr << "âŒ Skipping invalid transaction!" << std::endl;
        }
    }

    if (validTransactions.empty()) {
        std::cerr << "âš ï¸ No valid transactions to mine. Aborting mining process!" << std::endl;
        return Block();
    }

    // âœ… **Adjust difficulty dynamically before mining**
    adjustDifficulty();

    Block newBlock(getLatestBlock().getIndex() + 1, getLatestBlock().getHash(), validTransactions, minerAddress, difficulty);

    std::cout << "â³ Mining Block: " << newBlock.getIndex() << " with difficulty: " << difficulty << std::endl;
    newBlock.mineBlock(difficulty);

    if (newBlock.getHash().empty()) {
        std::cerr << "âŒ Mining failed. No valid hash generated." << std::endl;
        return newBlock;
    }

    // âœ… Clear Pending Transactions **AFTER** Adding Block
    addBlock(newBlock);
    clearPendingTransactions();
    saveToFile();

    std::cout << "âœ… Block mined successfully: " << newBlock.getHash() << std::endl;
    return newBlock;
}


// 
void Blockchain::clearTransactionsAfterMining() {
    std::cout << "ðŸš¨ Clearing pending transactions! Size before clearing: " 
              << pendingTransactions.size() << std::endl;
    pendingTransactions.clear();
}

// âœ… **Sync Blockchain**
void Blockchain::syncChain(const Json::Value& jsonData) {
    std::vector<Block> newChain;
    for (const auto& blockJson : jsonData["chain"]) {
        Block newBlock;
        newBlock.fromJSON(blockJson);
        newChain.push_back(newBlock);
    }
    if (newChain.size() > chain.size()) {
        chain = newChain;
        saveToFile();
        std::cout << "âœ… Blockchain successfully synchronized!" << std::endl;
    }
}

// âœ… **Start Mining**
void Blockchain::startMining(const std::string& minerAddress) {
    if (isMining.load()) {
        std::cout << "âš ï¸ Mining is already running!" << std::endl;
        return;
    }

    isMining.store(true);

    std::thread([this, minerAddress]() {
        while (isMining.load()) {
            reloadBlockchainState();
            if (pendingTransactions.empty()) {
                std::cout << "â³ No transactions to mine. Waiting...\n";
                std::this_thread::sleep_for(std::chrono::seconds(5));
                continue;
            }

            Block newBlock = minePendingTransactions(minerAddress);
            addBlock(newBlock);
            std::this_thread::sleep_for(std::chrono::seconds(2));
        }
    }).detach();
}

// âœ… **Stop Mining**
void Blockchain::stopMining() {
    isMining.store(false);
    std::cout << "â›” Mining stopped!\n";
}

// âœ… **Reload Blockchain State**
void Blockchain::reloadBlockchainState() {
    loadFromFile();
    loadTransactionsFromDisk();
    std::cout << "âœ… Blockchain and transactions reloaded!\n";
}

// âœ… **Print Blockchain**
void Blockchain::printBlockchain() const {
    for (const auto& block : chain) {
        std::cout << block.toJSON() << std::endl; // No .toStyledString()
    }
}

    // âœ… **Show pending transactions (before they are mined)**
void Blockchain::printPendingTransactions() {
    if (!pendingTransactions.empty()) {
        std::cout << "âœ… Pending transactions available.\n";
    } else {
        std::cout << "âœ… No pending transactions.\n";
    }
}

// âœ… **Add a new transaction**
void Blockchain::addTransaction(const Transaction& tx) {
    std::lock_guard<std::mutex> lock(blockchainMutex);

    if (!isTransactionValid(tx)) {
        std::cerr << "âŒ Invalid transaction! Not adding." << std::endl;
        return;
    }

    pendingTransactions.push_back(tx);
    saveTransactionsToDisk();

    std::cout << "âœ… Transaction added successfully! Total pending: " << pendingTransactions.size() << std::endl;

    // ðŸ“¡ **Broadcast Transaction Immediately**
    if (network) {
        Json::StreamWriterBuilder writer;
        std::string txData = R"({"type": "new_transaction", "data": )" + Json::writeString(writer, tx.toJSON()) + "}";

        for (const std::string& peer : network->getPeers()) {
            network->sendData(peer, txData);
        }

        std::cout << "ðŸ“¡ Transaction broadcasted to peers!\n";
    }
}

// âœ… **Get balance of a public key**
double Blockchain::getBalance(const std::string& publicKey) const {
    double balance = 0;
    for (const Block& block : chain) {
        for (const Transaction& tx : block.getTransactions()) {
            if (tx.getRecipient() == publicKey) balance += tx.getAmount();
            if (tx.getSender() == publicKey) balance -= tx.getAmount();
        }
    }
    return balance;
}

// âœ… **Save transactions to disk**


void Blockchain::saveTransactionsToDisk() {
    std::string filePath = "data/transactions.json";

    // Ensure "data" directory exists
    struct stat info;
    if (stat("data", &info) != 0) {
        std::cerr << "âš ï¸ Warning: 'data' directory does not exist. Creating...\n";
        mkdir("data", 0777);
    }

    std::ofstream file(filePath, std::ios::out | std::ios::trunc);
    if (!file) {
        std::cerr << "âŒ Error: Could not open " << filePath << " for writing! Check permissions." << std::endl;
        return;
    }

    Json::Value jsonData(Json::arrayValue);
    for (const auto& tx : pendingTransactions) {
        jsonData.append(tx.toJSON());
    }

    file << jsonData.toStyledString();
    file.close();
    std::cout << "âœ… Transactions saved successfully!\n";
}
// âœ… **Convert blockchain to JSON**
Json::Value Blockchain::toJSON() const {
    Json::Value jsonData;
    for (const auto& block : chain) {
        jsonData["chain"].append(block.toJSON());
    }

    Json::StreamWriterBuilder writer;
    return Json::writeString(writer, jsonData);
}
// âœ… Save blockchain to disk (Updated for better persistence)
void Blockchain::saveToFile() {
    if (chain.empty()) {
        std::cerr << "âš ï¸ Blockchain empty! Creating and saving Genesis Block..." << std::endl;

        // âœ… Ensure Genesis Block is properly initialized
        Block genesis(0, "0", {}, "GENESIS", 1);
        chain.push_back(genesis);
        std::cout << "âœ… Genesis Block Created!" << std::endl;
    }

    Json::Value blockchainData;
    Json::Value blocksArray(Json::arrayValue);

    for (const auto& block : chain) {
        blocksArray.append(block.toJSON());  // âœ… Ensure block JSON is correct
    }

    blockchainData["blocks"] = blocksArray;

    std::ofstream file("blockchain.json");
    if (!file) {
        std::cerr << "âŒ Error saving blockchain to file!" << std::endl;
        return;
    }

    file << blockchainData.toStyledString();  // âœ… Ensure proper JSON formatting
    file.close();

    std::cout << "âœ… Blockchain successfully saved! Blocks count: " << chain.size() << std::endl;
}

// Loadfrom Json
void Blockchain::loadFromJSON(const Json::Value& jsonData) {
    if (!jsonData.isMember("blocks") || !jsonData["blocks"].isArray()) {
        std::cerr << "âŒ Error: Invalid blockchain JSON format!" << std::endl;
        return;
    }

    chain.clear(); // âœ… Reset chain before loading
    for (const auto& blockJson : jsonData["blocks"]) {
        Block block = Block::fromJSON(blockJson);
        if (block.getIndex() >= 0) {  // âœ… Only load valid blocks
            chain.push_back(block);
        } else {
            std::cerr << "âš ï¸ Skipping corrupted block from JSON!" << std::endl;
        }
    }

    std::cout << "âœ… Blockchain successfully loaded from JSON. Blocks count: " << chain.size() << std::endl;
}

// âœ… **Replace blockchain if a longer valid chain is found**
void Blockchain::replaceChain(const std::vector<Block>& newChain) {
    std::lock_guard<std::mutex> lock(blockchainMutex);
    if (newChain.size() > chain.size()) {
        chain = newChain;
        saveToFile();
        std::cout << "âœ… Blockchain replaced with a longer valid chain!" << std::endl;
    }
}
//
bool Blockchain::isValidNewBlock(const Block& newBlock) {
    if (chain.empty()) {
        std::cerr << "âŒ Error: Blockchain is empty. No previous block to compare." << std::endl;
        return false;
    }

    Block lastBlock = getLatestBlock();

    // âœ… Ensure new block references the latest block's hash
    if (newBlock.getPreviousHash() != lastBlock.getHash()) {
        std::cerr << "âŒ Invalid block! Previous hash mismatch." << std::endl;
        return false;
    }

    // âœ… Validate Proof-of-Work
    if (!newBlock.hasValidProofOfWork()) {
        std::cerr << "âŒ Invalid block! Proof-of-Work check failed." << std::endl;
        return false;
    }

    return true;
}
// âœ… Load blockchain from disk
void Blockchain::loadTransactionsFromDisk() {
    std::ifstream file("data/transactions.json");
    if (!file) {
        std::cerr << "âš ï¸ transactions.json not found. Creating a new file...\n";
        saveTransactionsToDisk(); // âœ… Fix: Create a new transactions file if missing
        return;
    }

    Json::CharReaderBuilder readerBuilder;
    Json::Value jsonData;
    std::string errs;

    if (!Json::parseFromStream(readerBuilder, file, &jsonData, &errs)) {
        std::cerr << "âŒ Error parsing transactions.json! " << errs << std::endl;
        return;
    }

    file.close();

    if (!jsonData.isArray()) {
        std::cerr << "âš ï¸ Invalid transactions format. Resetting transactions...\n";
        saveTransactionsToDisk();
        return;
    }

    pendingTransactions.clear();
    for (const auto& txData : jsonData) {
        Transaction transaction;
        transaction.fromJSON(txData);
        pendingTransactions.push_back(transaction);
    }

    std::cout << "âœ… Transactions loaded successfully! Count: " << pendingTransactions.size() << std::endl;
}

// âœ… Load blockchain from peers
void Blockchain::loadFromPeers() {
    if (!network) {
        std::cerr << "âŒ Network is not initialized!\n";
        return;
    }
    network->requestBlockchainSync();
}

// âœ… **Hybrid PoW Mining (BLAKE3 + Keccak Validation)**
Block Blockchain::mineBlock(const std::string& minerAddress) {
    std::cout << "\nâï¸ Mining block using BLAKE3..." << std::endl;

    if (pendingTransactions.empty()) {
        std::cerr << "âš ï¸ No transactions to mine. Aborting mining process!" << std::endl;
        return Block();
    }

    // âœ… Ensure miner keys exist
    Crypto::ensureMinerKeys();

    // âœ… Validate miner keypair before mining
    std::string minerPrivateKey = "keys/" + minerAddress + "_private.pem";
    std::string minerPublicKey = "keys/" + minerAddress + "_public.pem";

    if (!std::filesystem::exists(minerPrivateKey) || !std::filesystem::exists(minerPublicKey)) {
        std::cerr << "âŒ Error: Miner keypair is missing! Cannot proceed with mining.\n";
        return Block();
    }

    Block lastBlock = getLatestBlock();
    std::string lastBlockHash = lastBlock.getHash();

    // âœ… Generate miner address properly
    std::string resolvedMinerAddress = Crypto::generateMinerAddress(minerAddress);
    if (resolvedMinerAddress.empty()) {
        std::cerr << "âŒ Error: Failed to generate miner address from public key.\n";
        return Block();
    }

    Block newBlock(chain.size(), lastBlockHash, pendingTransactions, resolvedMinerAddress, difficulty);
    std::cout << "ðŸ” [DEBUG] Mining Block Index: " << newBlock.getIndex() << std::endl;

    uint64_t nonce = 0;
    std::string hash;

    while (true) {
        std::string data = newBlock.getPreviousHash() + std::to_string(newBlock.getTimestamp()) +
                           newBlock.getMinerAddress() + std::to_string(nonce);

        hash = Crypto::blake3(data);

        if (hash.substr(0, difficulty) == std::string(difficulty, '0')) {
            newBlock.setHash(hash);
            newBlock.setNonce(nonce);
            break;
        }

        if (nonce % 100000 == 0) {
            std::cout << "â³ Mining Progress: Nonce=" << nonce << ", Hash=" << hash << std::endl;
        }

        nonce++;
    }

    std::cout << "âœ… Block successfully mined: " << hash << " (Nonce: " << nonce << ")\n";

    // âœ… Sign the block using the miner's private key
    std::string blockSignature = Crypto::signMessage(minerPrivateKey, hash);

    if (blockSignature.empty()) {
        std::cerr << "âŒ Error: Failed to generate block signature!\n";
        return Block();
    }

    std::cout << "âœ… [DEBUG] Block Signature Successfully Generated: " << blockSignature << "\n";

    newBlock.setSignature(blockSignature);

    // âœ… Verify Block Signature
    if (!Crypto::verifyMessage(minerPublicKey, blockSignature, hash)) {
        std::cerr << "âŒ Block signature verification failed! Miner: " << resolvedMinerAddress << std::endl;
        return Block();
    }

    chain.push_back(newBlock);
    saveToFile();
    clearPendingTransactions();

    std::cout << "âœ… Block successfully added to blockchain!\n";
    return newBlock;
}

// âœ… Get latest block
const Block& Blockchain::getLatestBlock() const {
    return chain.back();
}

// âœ… Get pending transactions
std::vector<Transaction> Blockchain::getPendingTransactions() const {
    return pendingTransactions;
}
// âœ… Update blockchain from JSON
void Blockchain::updateFromJSON(const std::string& jsonData) {
    try {
        Json::Value root;
        Json::CharReaderBuilder reader;
        std::istringstream stream(jsonData);
        std::string errs;

        if (!Json::parseFromStream(reader, stream, &root, &errs)) {
            std::cerr << "âŒ Error parsing blockchain JSON: " << errs << std::endl;
            return;
        }

        chain.clear();
        for (const auto& blockJson : root["chain"]) {
            Block newBlock;
           newBlock.fromJSON(blockJson);
           chain.push_back(newBlock);
        }

        saveToFile();
        std::cout << "âœ… Blockchain updated from JSON!\n";
    } catch (const std::exception& e) {
        std::cerr << "âŒ Exception in updateFromJSON: " << e.what() << std::endl;
    }
}
// âœ… Handle client connection (FIX FOR UNDEFINED REFERENCE)
void Network::handleClient(std::shared_ptr<asio::ip::tcp::socket> socket) {
    try {
        std::array<char, 1024> data;
        asio::error_code error;
        size_t length = socket->read_some(asio::buffer(data), error);

        if (!error) {
            std::string receivedMessage(data.data(), length);
            std::cout << "ðŸ“© Received message: " << receivedMessage << std::endl;

            std::string senderIP = socket->remote_endpoint().address().to_string();
            handleIncomingData(receivedMessage, senderIP);
        } else {
            std::cerr << "âŒ Error reading from client: " << error.message() << std::endl;
        }
    } catch (const std::exception& e) {
        std::cerr << "âŒ Exception in handleClient: " << e.what() << std::endl;
    }
}
// âœ… Load blockchain from disk with error handling

bool Blockchain::loadFromFile() {
    std::ifstream file("blockchain.json");
    if (!file.is_open()) {
        std::cerr << "âš ï¸ Blockchain file not found! Creating new blockchain..." << std::endl;
        return false;
    }

    Json::Value blockchainData;
    file >> blockchainData;
    file.close();

    if (blockchainData.empty() || !blockchainData.isMember("blocks")) {
        std::cerr << "âŒ Invalid block JSON format!" << std::endl;
        return false;
    }

    chain.clear();  // âœ… Avoid duplicate entries

    for (const auto& blockJson : blockchainData["blocks"]) {
        if (!blockJson.isObject()) {
            std::cerr << "âŒ Skipping invalid block data!" << std::endl;
            continue;
        }

        Block newBlock = Block::fromJSON(blockJson);  // âœ… FIXED!
        chain.push_back(newBlock);
    }

    std::cout << "âœ… Blockchain loaded. Blocks count: " << chain.size() << std::endl;
    return true;
}

// Store recent transaction counts
std::deque<int> recentTransactionCounts;

// Function to get average transaction count
int Blockchain::getRecentTransactionCount() {
    if (recentTransactionCounts.empty()) return 0;
    
    int sum = 0;
    for (int count : recentTransactionCounts) sum += count;
    
    return sum / recentTransactionCounts.size();
}

// Update transaction history every block
void Blockchain::updateTransactionHistory(int newTxCount) {
    if (recentTransactionCounts.size() > 100) {
        recentTransactionCounts.pop_front();  // Keep last 100 blocks' data
    }
    recentTransactionCounts.push_back(newTxCount);
}
