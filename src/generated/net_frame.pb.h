// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: net_frame.proto
// Protobuf C++ Version: 5.29.3

#ifndef net_5fframe_2eproto_2epb_2eh
#define net_5fframe_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
#include "block_protos.pb.h"
#include "blockchain_protos.pb.h"
#include "sync_protos.pb.h"
#include "transaction_protos.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_net_5fframe_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_net_5fframe_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_net_5fframe_2eproto;
namespace alyncoin {
namespace net {
class BlockBatch;
struct BlockBatchDefaultTypeInternal;
extern BlockBatchDefaultTypeInternal _BlockBatch_default_instance_;
class BlockBroadcast;
struct BlockBroadcastDefaultTypeInternal;
extern BlockBroadcastDefaultTypeInternal _BlockBroadcast_default_instance_;
class BlockRequest;
struct BlockRequestDefaultTypeInternal;
extern BlockRequestDefaultTypeInternal _BlockRequest_default_instance_;
class BlockResponse;
struct BlockResponseDefaultTypeInternal;
extern BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
class EpochProof;
struct EpochProofDefaultTypeInternal;
extern EpochProofDefaultTypeInternal _EpochProof_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class GetData;
struct GetDataDefaultTypeInternal;
extern GetDataDefaultTypeInternal _GetData_default_instance_;
class GetHeaders;
struct GetHeadersDefaultTypeInternal;
extern GetHeadersDefaultTypeInternal _GetHeaders_default_instance_;
class Handshake;
struct HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class Headers;
struct HeadersDefaultTypeInternal;
extern HeadersDefaultTypeInternal _Headers_default_instance_;
class HeightProbe;
struct HeightProbeDefaultTypeInternal;
extern HeightProbeDefaultTypeInternal _HeightProbe_default_instance_;
class HeightRequest;
struct HeightRequestDefaultTypeInternal;
extern HeightRequestDefaultTypeInternal _HeightRequest_default_instance_;
class HeightResponse;
struct HeightResponseDefaultTypeInternal;
extern HeightResponseDefaultTypeInternal _HeightResponse_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class PeerList;
struct PeerListDefaultTypeInternal;
extern PeerListDefaultTypeInternal _PeerList_default_instance_;
class PeerListRequest;
struct PeerListRequestDefaultTypeInternal;
extern PeerListRequestDefaultTypeInternal _PeerListRequest_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class RollupBlockMsg;
struct RollupBlockMsgDefaultTypeInternal;
extern RollupBlockMsgDefaultTypeInternal _RollupBlockMsg_default_instance_;
class SnapshotAck;
struct SnapshotAckDefaultTypeInternal;
extern SnapshotAckDefaultTypeInternal _SnapshotAck_default_instance_;
class SnapshotChunk;
struct SnapshotChunkDefaultTypeInternal;
extern SnapshotChunkDefaultTypeInternal _SnapshotChunk_default_instance_;
class SnapshotEnd;
struct SnapshotEndDefaultTypeInternal;
extern SnapshotEndDefaultTypeInternal _SnapshotEnd_default_instance_;
class SnapshotMeta;
struct SnapshotMetaDefaultTypeInternal;
extern SnapshotMetaDefaultTypeInternal _SnapshotMeta_default_instance_;
class SnapshotRequest;
struct SnapshotRequestDefaultTypeInternal;
extern SnapshotRequestDefaultTypeInternal _SnapshotRequest_default_instance_;
class StateProof;
struct StateProofDefaultTypeInternal;
extern StateProofDefaultTypeInternal _StateProof_default_instance_;
class TailBlocks;
struct TailBlocksDefaultTypeInternal;
extern TailBlocksDefaultTypeInternal _TailBlocks_default_instance_;
class TailBlocksRequest;
struct TailBlocksRequestDefaultTypeInternal;
extern TailBlocksRequestDefaultTypeInternal _TailBlocksRequest_default_instance_;
class TipHashRequest;
struct TipHashRequestDefaultTypeInternal;
extern TipHashRequestDefaultTypeInternal _TipHashRequest_default_instance_;
class TipHashResponse;
struct TipHashResponseDefaultTypeInternal;
extern TipHashResponseDefaultTypeInternal _TipHashResponse_default_instance_;
class TransactionBroadcast;
struct TransactionBroadcastDefaultTypeInternal;
extern TransactionBroadcastDefaultTypeInternal _TransactionBroadcast_default_instance_;
class Whisper;
struct WhisperDefaultTypeInternal;
extern WhisperDefaultTypeInternal _Whisper_default_instance_;
}  // namespace net
}  // namespace alyncoin
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace alyncoin {
namespace net {

// ===================================================================


// -------------------------------------------------------------------

class Whisper final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.Whisper) */ {
 public:
  inline Whisper() : Whisper(nullptr) {}
  ~Whisper() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Whisper* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Whisper));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Whisper(
      ::google::protobuf::internal::ConstantInitialized);

  inline Whisper(const Whisper& from) : Whisper(nullptr, from) {}
  inline Whisper(Whisper&& from) noexcept
      : Whisper(nullptr, std::move(from)) {}
  inline Whisper& operator=(const Whisper& from) {
    CopyFrom(from);
    return *this;
  }
  inline Whisper& operator=(Whisper&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Whisper& default_instance() {
    return *internal_default_instance();
  }
  static inline const Whisper* internal_default_instance() {
    return reinterpret_cast<const Whisper*>(
        &_Whisper_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 29;
  friend void swap(Whisper& a, Whisper& b) { a.Swap(&b); }
  inline void Swap(Whisper* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Whisper* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Whisper* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Whisper>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Whisper& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Whisper& from) { Whisper::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Whisper* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Whisper"; }

 protected:
  explicit Whisper(::google::protobuf::Arena* arena);
  Whisper(::google::protobuf::Arena* arena, const Whisper& from);
  Whisper(::google::protobuf::Arena* arena, Whisper&& from) noexcept
      : Whisper(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.Whisper)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Whisper& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TipHashResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.TipHashResponse) */ {
 public:
  inline TipHashResponse() : TipHashResponse(nullptr) {}
  ~TipHashResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TipHashResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TipHashResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TipHashResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline TipHashResponse(const TipHashResponse& from) : TipHashResponse(nullptr, from) {}
  inline TipHashResponse(TipHashResponse&& from) noexcept
      : TipHashResponse(nullptr, std::move(from)) {}
  inline TipHashResponse& operator=(const TipHashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TipHashResponse& operator=(TipHashResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TipHashResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TipHashResponse* internal_default_instance() {
    return reinterpret_cast<const TipHashResponse*>(
        &_TipHashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 18;
  friend void swap(TipHashResponse& a, TipHashResponse& b) { a.Swap(&b); }
  inline void Swap(TipHashResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TipHashResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TipHashResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TipHashResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TipHashResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TipHashResponse& from) { TipHashResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TipHashResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.TipHashResponse"; }

 protected:
  explicit TipHashResponse(::google::protobuf::Arena* arena);
  TipHashResponse(::google::protobuf::Arena* arena, const TipHashResponse& from);
  TipHashResponse(::google::protobuf::Arena* arena, TipHashResponse&& from) noexcept
      : TipHashResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashFieldNumber = 1,
  };
  // string hash = 1;
  void clear_hash() ;
  const std::string& hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hash(Arg_&& arg, Args_... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* value);

  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(
      const std::string& value);
  std::string* _internal_mutable_hash();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.TipHashResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TipHashResponse& from_msg);
    ::google::protobuf::internal::ArenaStringPtr hash_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TipHashRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:alyncoin.net.TipHashRequest) */ {
 public:
  inline TipHashRequest() : TipHashRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TipHashRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TipHashRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TipHashRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TipHashRequest(const TipHashRequest& from) : TipHashRequest(nullptr, from) {}
  inline TipHashRequest(TipHashRequest&& from) noexcept
      : TipHashRequest(nullptr, std::move(from)) {}
  inline TipHashRequest& operator=(const TipHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TipHashRequest& operator=(TipHashRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TipHashRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TipHashRequest* internal_default_instance() {
    return reinterpret_cast<const TipHashRequest*>(
        &_TipHashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 17;
  friend void swap(TipHashRequest& a, TipHashRequest& b) { a.Swap(&b); }
  inline void Swap(TipHashRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TipHashRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TipHashRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<TipHashRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TipHashRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TipHashRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.TipHashRequest"; }

 protected:
  explicit TipHashRequest(::google::protobuf::Arena* arena);
  TipHashRequest(::google::protobuf::Arena* arena, const TipHashRequest& from);
  TipHashRequest(::google::protobuf::Arena* arena, TipHashRequest&& from) noexcept
      : TipHashRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:alyncoin.net.TipHashRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TipHashRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TailBlocksRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.TailBlocksRequest) */ {
 public:
  inline TailBlocksRequest() : TailBlocksRequest(nullptr) {}
  ~TailBlocksRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TailBlocksRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TailBlocksRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TailBlocksRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline TailBlocksRequest(const TailBlocksRequest& from) : TailBlocksRequest(nullptr, from) {}
  inline TailBlocksRequest(TailBlocksRequest&& from) noexcept
      : TailBlocksRequest(nullptr, std::move(from)) {}
  inline TailBlocksRequest& operator=(const TailBlocksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailBlocksRequest& operator=(TailBlocksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailBlocksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailBlocksRequest* internal_default_instance() {
    return reinterpret_cast<const TailBlocksRequest*>(
        &_TailBlocksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 23;
  friend void swap(TailBlocksRequest& a, TailBlocksRequest& b) { a.Swap(&b); }
  inline void Swap(TailBlocksRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailBlocksRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailBlocksRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TailBlocksRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TailBlocksRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TailBlocksRequest& from) { TailBlocksRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TailBlocksRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.TailBlocksRequest"; }

 protected:
  explicit TailBlocksRequest(::google::protobuf::Arena* arena);
  TailBlocksRequest(::google::protobuf::Arena* arena, const TailBlocksRequest& from);
  TailBlocksRequest(::google::protobuf::Arena* arena, TailBlocksRequest&& from) noexcept
      : TailBlocksRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kAnchorHashFieldNumber = 2,
    kFromHeightFieldNumber = 1,
  };
  // string anchor_hash = 2;
  void clear_anchor_hash() ;
  const std::string& anchor_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_anchor_hash(Arg_&& arg, Args_... args);
  std::string* mutable_anchor_hash();
  PROTOBUF_NODISCARD std::string* release_anchor_hash();
  void set_allocated_anchor_hash(std::string* value);

  private:
  const std::string& _internal_anchor_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_anchor_hash(
      const std::string& value);
  std::string* _internal_mutable_anchor_hash();

  public:
  // uint64 from_height = 1;
  void clear_from_height() ;
  ::uint64_t from_height() const;
  void set_from_height(::uint64_t value);

  private:
  ::uint64_t _internal_from_height() const;
  void _internal_set_from_height(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.TailBlocksRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      50, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TailBlocksRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr anchor_hash_;
    ::uint64_t from_height_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotRequest) */ {
 public:
  inline SnapshotRequest() : SnapshotRequest(nullptr) {}
  ~SnapshotRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnapshotRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnapshotRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotRequest(const SnapshotRequest& from) : SnapshotRequest(nullptr, from) {}
  inline SnapshotRequest(SnapshotRequest&& from) noexcept
      : SnapshotRequest(nullptr, std::move(from)) {}
  inline SnapshotRequest& operator=(const SnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotRequest& operator=(SnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotRequest*>(
        &_SnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 22;
  friend void swap(SnapshotRequest& a, SnapshotRequest& b) { a.Swap(&b); }
  inline void Swap(SnapshotRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SnapshotRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnapshotRequest& from) { SnapshotRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SnapshotRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.SnapshotRequest"; }

 protected:
  explicit SnapshotRequest(::google::protobuf::Arena* arena);
  SnapshotRequest(::google::protobuf::Arena* arena, const SnapshotRequest& from);
  SnapshotRequest(::google::protobuf::Arena* arena, SnapshotRequest&& from) noexcept
      : SnapshotRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kUntilHashFieldNumber = 1,
  };
  // string until_hash = 1;
  void clear_until_hash() ;
  const std::string& until_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_until_hash(Arg_&& arg, Args_... args);
  std::string* mutable_until_hash();
  PROTOBUF_NODISCARD std::string* release_until_hash();
  void set_allocated_until_hash(std::string* value);

  private:
  const std::string& _internal_until_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_until_hash(
      const std::string& value);
  std::string* _internal_mutable_until_hash();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      47, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SnapshotRequest& from_msg);
    ::google::protobuf::internal::ArenaStringPtr until_hash_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotMeta final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotMeta) */ {
 public:
  inline SnapshotMeta() : SnapshotMeta(nullptr) {}
  ~SnapshotMeta() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnapshotMeta* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnapshotMeta));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotMeta(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotMeta(const SnapshotMeta& from) : SnapshotMeta(nullptr, from) {}
  inline SnapshotMeta(SnapshotMeta&& from) noexcept
      : SnapshotMeta(nullptr, std::move(from)) {}
  inline SnapshotMeta& operator=(const SnapshotMeta& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotMeta& operator=(SnapshotMeta&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotMeta& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotMeta* internal_default_instance() {
    return reinterpret_cast<const SnapshotMeta*>(
        &_SnapshotMeta_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 10;
  friend void swap(SnapshotMeta& a, SnapshotMeta& b) { a.Swap(&b); }
  inline void Swap(SnapshotMeta* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotMeta* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotMeta* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SnapshotMeta>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotMeta& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnapshotMeta& from) { SnapshotMeta::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SnapshotMeta* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.SnapshotMeta"; }

 protected:
  explicit SnapshotMeta(::google::protobuf::Arena* arena);
  SnapshotMeta(::google::protobuf::Arena* arena, const SnapshotMeta& from);
  SnapshotMeta(::google::protobuf::Arena* arena, SnapshotMeta&& from) noexcept
      : SnapshotMeta(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kRootHashFieldNumber = 2,
    kHeightFieldNumber = 1,
    kTotalBytesFieldNumber = 3,
    kChunkSizeFieldNumber = 4,
  };
  // string root_hash = 2;
  void clear_root_hash() ;
  const std::string& root_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_root_hash(Arg_&& arg, Args_... args);
  std::string* mutable_root_hash();
  PROTOBUF_NODISCARD std::string* release_root_hash();
  void set_allocated_root_hash(std::string* value);

  private:
  const std::string& _internal_root_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_root_hash(
      const std::string& value);
  std::string* _internal_mutable_root_hash();

  public:
  // uint64 height = 1;
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // uint64 total_bytes = 3;
  void clear_total_bytes() ;
  ::uint64_t total_bytes() const;
  void set_total_bytes(::uint64_t value);

  private:
  ::uint64_t _internal_total_bytes() const;
  void _internal_set_total_bytes(::uint64_t value);

  public:
  // uint32 chunk_size = 4;
  void clear_chunk_size() ;
  ::uint32_t chunk_size() const;
  void set_chunk_size(::uint32_t value);

  private:
  ::uint32_t _internal_chunk_size() const;
  void _internal_set_chunk_size(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotMeta)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 0,
      43, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SnapshotMeta& from_msg);
    ::google::protobuf::internal::ArenaStringPtr root_hash_;
    ::uint64_t height_;
    ::uint64_t total_bytes_;
    ::uint32_t chunk_size_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotEnd final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotEnd) */ {
 public:
  inline SnapshotEnd() : SnapshotEnd(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnapshotEnd* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnapshotEnd));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotEnd(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotEnd(const SnapshotEnd& from) : SnapshotEnd(nullptr, from) {}
  inline SnapshotEnd(SnapshotEnd&& from) noexcept
      : SnapshotEnd(nullptr, std::move(from)) {}
  inline SnapshotEnd& operator=(const SnapshotEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotEnd& operator=(SnapshotEnd&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotEnd* internal_default_instance() {
    return reinterpret_cast<const SnapshotEnd*>(
        &_SnapshotEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 13;
  friend void swap(SnapshotEnd& a, SnapshotEnd& b) { a.Swap(&b); }
  inline void Swap(SnapshotEnd* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotEnd* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotEnd* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<SnapshotEnd>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotEnd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotEnd& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.SnapshotEnd"; }

 protected:
  explicit SnapshotEnd(::google::protobuf::Arena* arena);
  SnapshotEnd(::google::protobuf::Arena* arena, const SnapshotEnd& from);
  SnapshotEnd(::google::protobuf::Arena* arena, SnapshotEnd&& from) noexcept
      : SnapshotEnd(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotEnd)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SnapshotEnd& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotChunk final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotChunk) */ {
 public:
  inline SnapshotChunk() : SnapshotChunk(nullptr) {}
  ~SnapshotChunk() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnapshotChunk* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnapshotChunk));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotChunk(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotChunk(const SnapshotChunk& from) : SnapshotChunk(nullptr, from) {}
  inline SnapshotChunk(SnapshotChunk&& from) noexcept
      : SnapshotChunk(nullptr, std::move(from)) {}
  inline SnapshotChunk& operator=(const SnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotChunk& operator=(SnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const SnapshotChunk*>(
        &_SnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 11;
  friend void swap(SnapshotChunk& a, SnapshotChunk& b) { a.Swap(&b); }
  inline void Swap(SnapshotChunk* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotChunk* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotChunk* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SnapshotChunk>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotChunk& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnapshotChunk& from) { SnapshotChunk::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SnapshotChunk* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.SnapshotChunk"; }

 protected:
  explicit SnapshotChunk(::google::protobuf::Arena* arena);
  SnapshotChunk(::google::protobuf::Arena* arena, const SnapshotChunk& from);
  SnapshotChunk(::google::protobuf::Arena* arena, SnapshotChunk&& from) noexcept
      : SnapshotChunk(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotChunk)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SnapshotChunk& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotAck final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotAck) */ {
 public:
  inline SnapshotAck() : SnapshotAck(nullptr) {}
  ~SnapshotAck() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SnapshotAck* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SnapshotAck));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SnapshotAck(
      ::google::protobuf::internal::ConstantInitialized);

  inline SnapshotAck(const SnapshotAck& from) : SnapshotAck(nullptr, from) {}
  inline SnapshotAck(SnapshotAck&& from) noexcept
      : SnapshotAck(nullptr, std::move(from)) {}
  inline SnapshotAck& operator=(const SnapshotAck& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotAck& operator=(SnapshotAck&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotAck& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotAck* internal_default_instance() {
    return reinterpret_cast<const SnapshotAck*>(
        &_SnapshotAck_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 12;
  friend void swap(SnapshotAck& a, SnapshotAck& b) { a.Swap(&b); }
  inline void Swap(SnapshotAck* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotAck* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotAck* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SnapshotAck>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SnapshotAck& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SnapshotAck& from) { SnapshotAck::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SnapshotAck* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.SnapshotAck"; }

 protected:
  explicit SnapshotAck(::google::protobuf::Arena* arena);
  SnapshotAck(::google::protobuf::Arena* arena, const SnapshotAck& from);
  SnapshotAck(::google::protobuf::Arena* arena, SnapshotAck&& from) noexcept
      : SnapshotAck(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kSeqFieldNumber = 1,
  };
  // uint32 seq = 1;
  void clear_seq() ;
  ::uint32_t seq() const;
  void set_seq(::uint32_t value);

  private:
  ::uint32_t _internal_seq() const;
  void _internal_set_seq(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotAck)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SnapshotAck& from_msg);
    ::uint32_t seq_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class RollupBlockMsg final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.RollupBlockMsg) */ {
 public:
  inline RollupBlockMsg() : RollupBlockMsg(nullptr) {}
  ~RollupBlockMsg() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(RollupBlockMsg* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(RollupBlockMsg));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR RollupBlockMsg(
      ::google::protobuf::internal::ConstantInitialized);

  inline RollupBlockMsg(const RollupBlockMsg& from) : RollupBlockMsg(nullptr, from) {}
  inline RollupBlockMsg(RollupBlockMsg&& from) noexcept
      : RollupBlockMsg(nullptr, std::move(from)) {}
  inline RollupBlockMsg& operator=(const RollupBlockMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollupBlockMsg& operator=(RollupBlockMsg&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollupBlockMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RollupBlockMsg* internal_default_instance() {
    return reinterpret_cast<const RollupBlockMsg*>(
        &_RollupBlockMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 21;
  friend void swap(RollupBlockMsg& a, RollupBlockMsg& b) { a.Swap(&b); }
  inline void Swap(RollupBlockMsg* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollupBlockMsg* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollupBlockMsg* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<RollupBlockMsg>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const RollupBlockMsg& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const RollupBlockMsg& from) { RollupBlockMsg::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(RollupBlockMsg* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.RollupBlockMsg"; }

 protected:
  explicit RollupBlockMsg(::google::protobuf::Arena* arena);
  RollupBlockMsg(::google::protobuf::Arena* arena, const RollupBlockMsg& from);
  RollupBlockMsg(::google::protobuf::Arena* arena, RollupBlockMsg&& from) noexcept
      : RollupBlockMsg(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.RollupBlockMsg)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const RollupBlockMsg& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Pong final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:alyncoin.net.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Pong* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Pong));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Pong(
      ::google::protobuf::internal::ConstantInitialized);

  inline Pong(const Pong& from) : Pong(nullptr, from) {}
  inline Pong(Pong&& from) noexcept
      : Pong(nullptr, std::move(from)) {}
  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
        &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(Pong& a, Pong& b) { a.Swap(&b); }
  inline void Swap(Pong* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Pong>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Pong& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Pong& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Pong"; }

 protected:
  explicit Pong(::google::protobuf::Arena* arena);
  Pong(::google::protobuf::Arena* arena, const Pong& from);
  Pong(::google::protobuf::Arena* arena, Pong&& from) noexcept
      : Pong(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:alyncoin.net.Pong)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Pong& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Ping final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:alyncoin.net.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Ping* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Ping));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Ping(
      ::google::protobuf::internal::ConstantInitialized);

  inline Ping(const Ping& from) : Ping(nullptr, from) {}
  inline Ping(Ping&& from) noexcept
      : Ping(nullptr, std::move(from)) {}
  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
        &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(Ping& a, Ping& b) { a.Swap(&b); }
  inline void Swap(Ping* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<Ping>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Ping& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Ping& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Ping"; }

 protected:
  explicit Ping(::google::protobuf::Arena* arena);
  Ping(::google::protobuf::Arena* arena, const Ping& from);
  Ping(::google::protobuf::Arena* arena, Ping&& from) noexcept
      : Ping(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:alyncoin.net.Ping)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Ping& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class PeerListRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:alyncoin.net.PeerListRequest) */ {
 public:
  inline PeerListRequest() : PeerListRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PeerListRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PeerListRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PeerListRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline PeerListRequest(const PeerListRequest& from) : PeerListRequest(nullptr, from) {}
  inline PeerListRequest(PeerListRequest&& from) noexcept
      : PeerListRequest(nullptr, std::move(from)) {}
  inline PeerListRequest& operator=(const PeerListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerListRequest& operator=(PeerListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerListRequest* internal_default_instance() {
    return reinterpret_cast<const PeerListRequest*>(
        &_PeerListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 19;
  friend void swap(PeerListRequest& a, PeerListRequest& b) { a.Swap(&b); }
  inline void Swap(PeerListRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerListRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerListRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<PeerListRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PeerListRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PeerListRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.PeerListRequest"; }

 protected:
  explicit PeerListRequest(::google::protobuf::Arena* arena);
  PeerListRequest(::google::protobuf::Arena* arena, const PeerListRequest& from);
  PeerListRequest(::google::protobuf::Arena* arena, PeerListRequest&& from) noexcept
      : PeerListRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:alyncoin.net.PeerListRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PeerListRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class PeerList final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.PeerList) */ {
 public:
  inline PeerList() : PeerList(nullptr) {}
  ~PeerList() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(PeerList* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(PeerList));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR PeerList(
      ::google::protobuf::internal::ConstantInitialized);

  inline PeerList(const PeerList& from) : PeerList(nullptr, from) {}
  inline PeerList(PeerList&& from) noexcept
      : PeerList(nullptr, std::move(from)) {}
  inline PeerList& operator=(const PeerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerList& operator=(PeerList&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerList* internal_default_instance() {
    return reinterpret_cast<const PeerList*>(
        &_PeerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 20;
  friend void swap(PeerList& a, PeerList& b) { a.Swap(&b); }
  inline void Swap(PeerList* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerList* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerList* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<PeerList>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const PeerList& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const PeerList& from) { PeerList::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(PeerList* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.PeerList"; }

 protected:
  explicit PeerList(::google::protobuf::Arena* arena);
  PeerList(::google::protobuf::Arena* arena, const PeerList& from);
  PeerList(::google::protobuf::Arena* arena, PeerList&& from) noexcept
      : PeerList(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated string peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;

  public:
  void clear_peers() ;
  const std::string& peers(int index) const;
  std::string* mutable_peers(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_peers(int index, Arg_&& value, Args_... args);
  std::string* add_peers();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_peers(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& peers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_peers();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_peers() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_peers();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.PeerList)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const PeerList& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> peers_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Inventory final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Inventory* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Inventory));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Inventory(
      ::google::protobuf::internal::ConstantInitialized);

  inline Inventory(const Inventory& from) : Inventory(nullptr, from) {}
  inline Inventory(Inventory&& from) noexcept
      : Inventory(nullptr, std::move(from)) {}
  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
        &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 16;
  friend void swap(Inventory& a, Inventory& b) { a.Swap(&b); }
  inline void Swap(Inventory* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Inventory>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Inventory& from) { Inventory::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Inventory* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Inventory"; }

 protected:
  explicit Inventory(::google::protobuf::Arena* arena);
  Inventory(::google::protobuf::Arena* arena, const Inventory& from);
  Inventory(::google::protobuf::Arena* arena, Inventory&& from) noexcept
      : Inventory(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated string hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;

  public:
  void clear_hashes() ;
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hashes(int index, Arg_&& value, Args_... args);
  std::string* add_hashes();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_hashes(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_hashes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_hashes();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.Inventory)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      37, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Inventory& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> hashes_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.HeightResponse) */ {
 public:
  inline HeightResponse() : HeightResponse(nullptr) {}
  ~HeightResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeightResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeightResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeightResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeightResponse(const HeightResponse& from) : HeightResponse(nullptr, from) {}
  inline HeightResponse(HeightResponse&& from) noexcept
      : HeightResponse(nullptr, std::move(from)) {}
  inline HeightResponse& operator=(const HeightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightResponse& operator=(HeightResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightResponse* internal_default_instance() {
    return reinterpret_cast<const HeightResponse*>(
        &_HeightResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(HeightResponse& a, HeightResponse& b) { a.Swap(&b); }
  inline void Swap(HeightResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HeightResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeightResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeightResponse& from) { HeightResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HeightResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.HeightResponse"; }

 protected:
  explicit HeightResponse(::google::protobuf::Arena* arena);
  HeightResponse(::google::protobuf::Arena* arena, const HeightResponse& from);
  HeightResponse(::google::protobuf::Arena* arena, HeightResponse&& from) noexcept
      : HeightResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeightFieldNumber = 1,
    kTotalWorkFieldNumber = 2,
  };
  // uint64 height = 1;
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // uint64 total_work = 2;
  void clear_total_work() ;
  ::uint64_t total_work() const;
  void set_total_work(::uint64_t value);

  private:
  ::uint64_t _internal_total_work() const;
  void _internal_set_total_work(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      1, 2, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeightResponse& from_msg);
    ::uint64_t height_;
    ::uint64_t total_work_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightRequest final : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:alyncoin.net.HeightRequest) */ {
 public:
  inline HeightRequest() : HeightRequest(nullptr) {}

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeightRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeightRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeightRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeightRequest(const HeightRequest& from) : HeightRequest(nullptr, from) {}
  inline HeightRequest(HeightRequest&& from) noexcept
      : HeightRequest(nullptr, std::move(from)) {}
  inline HeightRequest& operator=(const HeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightRequest& operator=(HeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightRequest* internal_default_instance() {
    return reinterpret_cast<const HeightRequest*>(
        &_HeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(HeightRequest& a, HeightRequest& b) { a.Swap(&b); }
  inline void Swap(HeightRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<HeightRequest>(arena);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeightRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeightRequest& from) {
    ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }

  public:
  bool IsInitialized() const {
    return true;
  }
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.HeightRequest"; }

 protected:
  explicit HeightRequest(::google::protobuf::Arena* arena);
  HeightRequest(::google::protobuf::Arena* arena, const HeightRequest& from);
  HeightRequest(::google::protobuf::Arena* arena, HeightRequest&& from) noexcept
      : HeightRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 0, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeightRequest& from_msg);
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightProbe final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.HeightProbe) */ {
 public:
  inline HeightProbe() : HeightProbe(nullptr) {}
  ~HeightProbe() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(HeightProbe* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(HeightProbe));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR HeightProbe(
      ::google::protobuf::internal::ConstantInitialized);

  inline HeightProbe(const HeightProbe& from) : HeightProbe(nullptr, from) {}
  inline HeightProbe(HeightProbe&& from) noexcept
      : HeightProbe(nullptr, std::move(from)) {}
  inline HeightProbe& operator=(const HeightProbe& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightProbe& operator=(HeightProbe&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightProbe& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightProbe* internal_default_instance() {
    return reinterpret_cast<const HeightProbe*>(
        &_HeightProbe_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 5;
  friend void swap(HeightProbe& a, HeightProbe& b) { a.Swap(&b); }
  inline void Swap(HeightProbe* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightProbe* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightProbe* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<HeightProbe>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const HeightProbe& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const HeightProbe& from) { HeightProbe::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(HeightProbe* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.HeightProbe"; }

 protected:
  explicit HeightProbe(::google::protobuf::Arena* arena);
  HeightProbe(::google::protobuf::Arena* arena, const HeightProbe& from);
  HeightProbe(::google::protobuf::Arena* arena, HeightProbe&& from) noexcept
      : HeightProbe(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTipHashFieldNumber = 2,
    kTotalWorkFieldNumber = 3,
    kHeightFieldNumber = 1,
  };
  // bytes tip_hash = 2;
  void clear_tip_hash() ;
  const std::string& tip_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_tip_hash(Arg_&& arg, Args_... args);
  std::string* mutable_tip_hash();
  PROTOBUF_NODISCARD std::string* release_tip_hash();
  void set_allocated_tip_hash(std::string* value);

  private:
  const std::string& _internal_tip_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tip_hash(
      const std::string& value);
  std::string* _internal_mutable_tip_hash();

  public:
  // uint64 total_work = 3;
  void clear_total_work() ;
  ::uint64_t total_work() const;
  void set_total_work(::uint64_t value);

  private:
  ::uint64_t _internal_total_work() const;
  void _internal_set_total_work(::uint64_t value);

  public:
  // uint32 height = 1;
  void clear_height() ;
  ::uint32_t height() const;
  void set_height(::uint32_t value);

  private:
  ::uint32_t _internal_height() const;
  void _internal_set_height(::uint32_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightProbe)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 3, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const HeightProbe& from_msg);
    ::google::protobuf::internal::ArenaStringPtr tip_hash_;
    ::uint64_t total_work_;
    ::uint32_t height_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Handshake final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.Handshake) */ {
 public:
  inline Handshake() : Handshake(nullptr) {}
  ~Handshake() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Handshake* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Handshake));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Handshake(
      ::google::protobuf::internal::ConstantInitialized);

  inline Handshake(const Handshake& from) : Handshake(nullptr, from) {}
  inline Handshake(Handshake&& from) noexcept
      : Handshake(nullptr, std::move(from)) {}
  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handshake& operator=(Handshake&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
        &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(Handshake& a, Handshake& b) { a.Swap(&b); }
  inline void Swap(Handshake* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handshake* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handshake* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Handshake>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Handshake& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Handshake& from) { Handshake::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Handshake* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Handshake"; }

 protected:
  explicit Handshake(::google::protobuf::Arena* arena);
  Handshake(::google::protobuf::Arena* arena, const Handshake& from);
  Handshake(::google::protobuf::Arena* arena, Handshake&& from) noexcept
      : Handshake(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kCapabilitiesFieldNumber = 6,
    kVersionFieldNumber = 1,
    kNetworkIdFieldNumber = 2,
    kGenesisHashFieldNumber = 5,
    kPubKeyFieldNumber = 7,
    kNodeIdFieldNumber = 12,
    kHeightFieldNumber = 3,
    kListenPortFieldNumber = 4,
    kFrameRevFieldNumber = 8,
    kTotalWorkFieldNumber = 9,
    kWantSnapshotFieldNumber = 10,
    kSnapshotSizeFieldNumber = 11,
    kNonceFieldNumber = 13,
  };
  // repeated string capabilities = 6;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;

  public:
  void clear_capabilities() ;
  const std::string& capabilities(int index) const;
  std::string* mutable_capabilities(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_capabilities(int index, Arg_&& value, Args_... args);
  std::string* add_capabilities();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_capabilities(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& capabilities() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_capabilities();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_capabilities() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_capabilities();

  public:
  // string version = 1;
  void clear_version() ;
  const std::string& version() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_version(Arg_&& arg, Args_... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* value);

  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(
      const std::string& value);
  std::string* _internal_mutable_version();

  public:
  // string network_id = 2;
  void clear_network_id() ;
  const std::string& network_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_network_id(Arg_&& arg, Args_... args);
  std::string* mutable_network_id();
  PROTOBUF_NODISCARD std::string* release_network_id();
  void set_allocated_network_id(std::string* value);

  private:
  const std::string& _internal_network_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_id(
      const std::string& value);
  std::string* _internal_mutable_network_id();

  public:
  // bytes genesis_hash = 5;
  void clear_genesis_hash() ;
  const std::string& genesis_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_genesis_hash(Arg_&& arg, Args_... args);
  std::string* mutable_genesis_hash();
  PROTOBUF_NODISCARD std::string* release_genesis_hash();
  void set_allocated_genesis_hash(std::string* value);

  private:
  const std::string& _internal_genesis_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_genesis_hash(
      const std::string& value);
  std::string* _internal_mutable_genesis_hash();

  public:
  // bytes pub_key = 7;
  void clear_pub_key() ;
  const std::string& pub_key() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_pub_key(Arg_&& arg, Args_... args);
  std::string* mutable_pub_key();
  PROTOBUF_NODISCARD std::string* release_pub_key();
  void set_allocated_pub_key(std::string* value);

  private:
  const std::string& _internal_pub_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pub_key(
      const std::string& value);
  std::string* _internal_mutable_pub_key();

  public:
  // string node_id = 12;
  void clear_node_id() ;
  const std::string& node_id() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_node_id(Arg_&& arg, Args_... args);
  std::string* mutable_node_id();
  PROTOBUF_NODISCARD std::string* release_node_id();
  void set_allocated_node_id(std::string* value);

  private:
  const std::string& _internal_node_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_node_id(
      const std::string& value);
  std::string* _internal_mutable_node_id();

  public:
  // uint64 height = 3;
  void clear_height() ;
  ::uint64_t height() const;
  void set_height(::uint64_t value);

  private:
  ::uint64_t _internal_height() const;
  void _internal_set_height(::uint64_t value);

  public:
  // uint32 listen_port = 4;
  void clear_listen_port() ;
  ::uint32_t listen_port() const;
  void set_listen_port(::uint32_t value);

  private:
  ::uint32_t _internal_listen_port() const;
  void _internal_set_listen_port(::uint32_t value);

  public:
  // uint32 frame_rev = 8;
  void clear_frame_rev() ;
  ::uint32_t frame_rev() const;
  void set_frame_rev(::uint32_t value);

  private:
  ::uint32_t _internal_frame_rev() const;
  void _internal_set_frame_rev(::uint32_t value);

  public:
  // uint64 total_work = 9;
  void clear_total_work() ;
  ::uint64_t total_work() const;
  void set_total_work(::uint64_t value);

  private:
  ::uint64_t _internal_total_work() const;
  void _internal_set_total_work(::uint64_t value);

  public:
  // bool want_snapshot = 10;
  void clear_want_snapshot() ;
  bool want_snapshot() const;
  void set_want_snapshot(bool value);

  private:
  bool _internal_want_snapshot() const;
  void _internal_set_want_snapshot(bool value);

  public:
  // uint32 snapshot_size = 11;
  void clear_snapshot_size() ;
  ::uint32_t snapshot_size() const;
  void set_snapshot_size(::uint32_t value);

  private:
  ::uint32_t _internal_snapshot_size() const;
  void _internal_set_snapshot_size(::uint32_t value);

  public:
  // uint64 nonce = 13;
  void clear_nonce() ;
  ::uint64_t nonce() const;
  void set_nonce(::uint64_t value);

  private:
  ::uint64_t _internal_nonce() const;
  void _internal_set_nonce(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.Handshake)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 13, 0,
      75, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Handshake& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> capabilities_;
    ::google::protobuf::internal::ArenaStringPtr version_;
    ::google::protobuf::internal::ArenaStringPtr network_id_;
    ::google::protobuf::internal::ArenaStringPtr genesis_hash_;
    ::google::protobuf::internal::ArenaStringPtr pub_key_;
    ::google::protobuf::internal::ArenaStringPtr node_id_;
    ::uint64_t height_;
    ::uint32_t listen_port_;
    ::uint32_t frame_rev_;
    ::uint64_t total_work_;
    bool want_snapshot_;
    ::uint32_t snapshot_size_;
    ::uint64_t nonce_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class GetHeaders final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.GetHeaders) */ {
 public:
  inline GetHeaders() : GetHeaders(nullptr) {}
  ~GetHeaders() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetHeaders* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetHeaders));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetHeaders(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetHeaders(const GetHeaders& from) : GetHeaders(nullptr, from) {}
  inline GetHeaders(GetHeaders&& from) noexcept
      : GetHeaders(nullptr, std::move(from)) {}
  inline GetHeaders& operator=(const GetHeaders& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetHeaders& operator=(GetHeaders&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetHeaders& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetHeaders* internal_default_instance() {
    return reinterpret_cast<const GetHeaders*>(
        &_GetHeaders_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 25;
  friend void swap(GetHeaders& a, GetHeaders& b) { a.Swap(&b); }
  inline void Swap(GetHeaders* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetHeaders* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetHeaders* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetHeaders>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetHeaders& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetHeaders& from) { GetHeaders::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetHeaders* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.GetHeaders"; }

 protected:
  explicit GetHeaders(::google::protobuf::Arena* arena);
  GetHeaders(::google::protobuf::Arena* arena, const GetHeaders& from);
  GetHeaders(::google::protobuf::Arena* arena, GetHeaders&& from) noexcept
      : GetHeaders(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kFromHashFieldNumber = 1,
  };
  // string from_hash = 1;
  void clear_from_hash() ;
  const std::string& from_hash() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_from_hash(Arg_&& arg, Args_... args);
  std::string* mutable_from_hash();
  PROTOBUF_NODISCARD std::string* release_from_hash();
  void set_allocated_from_hash(std::string* value);

  private:
  const std::string& _internal_from_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_from_hash(
      const std::string& value);
  std::string* _internal_mutable_from_hash();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.GetHeaders)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetHeaders& from_msg);
    ::google::protobuf::internal::ArenaStringPtr from_hash_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class GetData final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.GetData) */ {
 public:
  inline GetData() : GetData(nullptr) {}
  ~GetData() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(GetData* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(GetData));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR GetData(
      ::google::protobuf::internal::ConstantInitialized);

  inline GetData(const GetData& from) : GetData(nullptr, from) {}
  inline GetData(GetData&& from) noexcept
      : GetData(nullptr, std::move(from)) {}
  inline GetData& operator=(const GetData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetData& operator=(GetData&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetData* internal_default_instance() {
    return reinterpret_cast<const GetData*>(
        &_GetData_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 24;
  friend void swap(GetData& a, GetData& b) { a.Swap(&b); }
  inline void Swap(GetData* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetData* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetData* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<GetData>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const GetData& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const GetData& from) { GetData::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(GetData* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.GetData"; }

 protected:
  explicit GetData(::google::protobuf::Arena* arena);
  GetData(::google::protobuf::Arena* arena, const GetData& from);
  GetData(::google::protobuf::Arena* arena, GetData&& from) noexcept
      : GetData(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated string hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;

  public:
  void clear_hashes() ;
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_hashes(int index, Arg_&& value, Args_... args);
  std::string* add_hashes();
  template <typename Arg_ = const std::string&, typename... Args_>
  void add_hashes(Arg_&& value, Args_... args);
  const ::google::protobuf::RepeatedPtrField<std::string>& hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* mutable_hashes();

  private:
  const ::google::protobuf::RepeatedPtrField<std::string>& _internal_hashes() const;
  ::google::protobuf::RepeatedPtrField<std::string>* _internal_mutable_hashes();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.GetData)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      35, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const GetData& from_msg);
    ::google::protobuf::RepeatedPtrField<std::string> hashes_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class EpochProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.EpochProof) */ {
 public:
  inline EpochProof() : EpochProof(nullptr) {}
  ~EpochProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(EpochProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(EpochProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR EpochProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline EpochProof(const EpochProof& from) : EpochProof(nullptr, from) {}
  inline EpochProof(EpochProof&& from) noexcept
      : EpochProof(nullptr, std::move(from)) {}
  inline EpochProof& operator=(const EpochProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochProof& operator=(EpochProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpochProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpochProof* internal_default_instance() {
    return reinterpret_cast<const EpochProof*>(
        &_EpochProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 15;
  friend void swap(EpochProof& a, EpochProof& b) { a.Swap(&b); }
  inline void Swap(EpochProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpochProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<EpochProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const EpochProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const EpochProof& from) { EpochProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(EpochProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.EpochProof"; }

 protected:
  explicit EpochProof(::google::protobuf::Arena* arena);
  EpochProof(::google::protobuf::Arena* arena, const EpochProof& from);
  EpochProof(::google::protobuf::Arena* arena, EpochProof&& from) noexcept
      : EpochProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data() ;
  const std::string& data() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_data(Arg_&& arg, Args_... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* value);

  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(
      const std::string& value);
  std::string* _internal_mutable_data();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.EpochProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const EpochProof& from_msg);
    ::google::protobuf::internal::ArenaStringPtr data_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.BlockRequest) */ {
 public:
  inline BlockRequest() : BlockRequest(nullptr) {}
  ~BlockRequest() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockRequest* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockRequest));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockRequest(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockRequest(const BlockRequest& from) : BlockRequest(nullptr, from) {}
  inline BlockRequest(BlockRequest&& from) noexcept
      : BlockRequest(nullptr, std::move(from)) {}
  inline BlockRequest& operator=(const BlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockRequest& operator=(BlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockRequest* internal_default_instance() {
    return reinterpret_cast<const BlockRequest*>(
        &_BlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 8;
  friend void swap(BlockRequest& a, BlockRequest& b) { a.Swap(&b); }
  inline void Swap(BlockRequest* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockRequest* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockRequest* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockRequest>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockRequest& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockRequest& from) { BlockRequest::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockRequest* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.BlockRequest"; }

 protected:
  explicit BlockRequest(::google::protobuf::Arena* arena);
  BlockRequest(::google::protobuf::Arena* arena, const BlockRequest& from);
  BlockRequest(::google::protobuf::Arena* arena, BlockRequest&& from) noexcept
      : BlockRequest(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kIndexFieldNumber = 1,
  };
  // uint64 index = 1;
  void clear_index() ;
  ::uint64_t index() const;
  void set_index(::uint64_t value);

  private:
  ::uint64_t _internal_index() const;
  void _internal_set_index(::uint64_t value);

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockRequest)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 0,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockRequest& from_msg);
    ::uint64_t index_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TransactionBroadcast final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.TransactionBroadcast) */ {
 public:
  inline TransactionBroadcast() : TransactionBroadcast(nullptr) {}
  ~TransactionBroadcast() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TransactionBroadcast* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TransactionBroadcast));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TransactionBroadcast(
      ::google::protobuf::internal::ConstantInitialized);

  inline TransactionBroadcast(const TransactionBroadcast& from) : TransactionBroadcast(nullptr, from) {}
  inline TransactionBroadcast(TransactionBroadcast&& from) noexcept
      : TransactionBroadcast(nullptr, std::move(from)) {}
  inline TransactionBroadcast& operator=(const TransactionBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionBroadcast& operator=(TransactionBroadcast&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionBroadcast& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionBroadcast* internal_default_instance() {
    return reinterpret_cast<const TransactionBroadcast*>(
        &_TransactionBroadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 28;
  friend void swap(TransactionBroadcast& a, TransactionBroadcast& b) { a.Swap(&b); }
  inline void Swap(TransactionBroadcast* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionBroadcast* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionBroadcast* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TransactionBroadcast>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TransactionBroadcast& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TransactionBroadcast& from) { TransactionBroadcast::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TransactionBroadcast* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.TransactionBroadcast"; }

 protected:
  explicit TransactionBroadcast(::google::protobuf::Arena* arena);
  TransactionBroadcast(::google::protobuf::Arena* arena, const TransactionBroadcast& from);
  TransactionBroadcast(::google::protobuf::Arena* arena, TransactionBroadcast&& from) noexcept
      : TransactionBroadcast(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kTxFieldNumber = 1,
  };
  // .alyncoin.TransactionProto tx = 1;
  bool has_tx() const;
  void clear_tx() ;
  const ::alyncoin::TransactionProto& tx() const;
  PROTOBUF_NODISCARD ::alyncoin::TransactionProto* release_tx();
  ::alyncoin::TransactionProto* mutable_tx();
  void set_allocated_tx(::alyncoin::TransactionProto* value);
  void unsafe_arena_set_allocated_tx(::alyncoin::TransactionProto* value);
  ::alyncoin::TransactionProto* unsafe_arena_release_tx();

  private:
  const ::alyncoin::TransactionProto& _internal_tx() const;
  ::alyncoin::TransactionProto* _internal_mutable_tx();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.TransactionBroadcast)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TransactionBroadcast& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::alyncoin::TransactionProto* tx_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class StateProof final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.StateProof) */ {
 public:
  inline StateProof() : StateProof(nullptr) {}
  ~StateProof() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(StateProof* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(StateProof));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR StateProof(
      ::google::protobuf::internal::ConstantInitialized);

  inline StateProof(const StateProof& from) : StateProof(nullptr, from) {}
  inline StateProof(StateProof&& from) noexcept
      : StateProof(nullptr, std::move(from)) {}
  inline StateProof& operator=(const StateProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateProof& operator=(StateProof&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateProof* internal_default_instance() {
    return reinterpret_cast<const StateProof*>(
        &_StateProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 27;
  friend void swap(StateProof& a, StateProof& b) { a.Swap(&b); }
  inline void Swap(StateProof* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateProof* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateProof* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<StateProof>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const StateProof& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const StateProof& from) { StateProof::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(StateProof* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.StateProof"; }

 protected:
  explicit StateProof(::google::protobuf::Arena* arena);
  StateProof(::google::protobuf::Arena* arena, const StateProof& from);
  StateProof(::google::protobuf::Arena* arena, StateProof&& from) noexcept
      : StateProof(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kProofFieldNumber = 1,
  };
  // .alyncoin.StateProofProto proof = 1;
  bool has_proof() const;
  void clear_proof() ;
  const ::alyncoin::StateProofProto& proof() const;
  PROTOBUF_NODISCARD ::alyncoin::StateProofProto* release_proof();
  ::alyncoin::StateProofProto* mutable_proof();
  void set_allocated_proof(::alyncoin::StateProofProto* value);
  void unsafe_arena_set_allocated_proof(::alyncoin::StateProofProto* value);
  ::alyncoin::StateProofProto* unsafe_arena_release_proof();

  private:
  const ::alyncoin::StateProofProto& _internal_proof() const;
  ::alyncoin::StateProofProto* _internal_mutable_proof();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.StateProof)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const StateProof& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::alyncoin::StateProofProto* proof_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TailBlocks final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.TailBlocks) */ {
 public:
  inline TailBlocks() : TailBlocks(nullptr) {}
  ~TailBlocks() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(TailBlocks* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(TailBlocks));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR TailBlocks(
      ::google::protobuf::internal::ConstantInitialized);

  inline TailBlocks(const TailBlocks& from) : TailBlocks(nullptr, from) {}
  inline TailBlocks(TailBlocks&& from) noexcept
      : TailBlocks(nullptr, std::move(from)) {}
  inline TailBlocks& operator=(const TailBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailBlocks& operator=(TailBlocks&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailBlocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailBlocks* internal_default_instance() {
    return reinterpret_cast<const TailBlocks*>(
        &_TailBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 14;
  friend void swap(TailBlocks& a, TailBlocks& b) { a.Swap(&b); }
  inline void Swap(TailBlocks* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailBlocks* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailBlocks* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<TailBlocks>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const TailBlocks& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const TailBlocks& from) { TailBlocks::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(TailBlocks* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.TailBlocks"; }

 protected:
  explicit TailBlocks(::google::protobuf::Arena* arena);
  TailBlocks(::google::protobuf::Arena* arena, const TailBlocks& from);
  TailBlocks(::google::protobuf::Arena* arena, TailBlocks&& from) noexcept
      : TailBlocks(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .alyncoin.BlockProto blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;

  public:
  void clear_blocks() ;
  ::alyncoin::BlockProto* mutable_blocks(int index);
  ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>* mutable_blocks();

  private:
  const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>& _internal_blocks() const;
  ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>* _internal_mutable_blocks();
  public:
  const ::alyncoin::BlockProto& blocks(int index) const;
  ::alyncoin::BlockProto* add_blocks();
  const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>& blocks() const;
  // @@protoc_insertion_point(class_scope:alyncoin.net.TailBlocks)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const TailBlocks& from_msg);
    ::google::protobuf::RepeatedPtrField< ::alyncoin::BlockProto > blocks_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Headers final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.Headers) */ {
 public:
  inline Headers() : Headers(nullptr) {}
  ~Headers() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Headers* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Headers));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Headers(
      ::google::protobuf::internal::ConstantInitialized);

  inline Headers(const Headers& from) : Headers(nullptr, from) {}
  inline Headers(Headers&& from) noexcept
      : Headers(nullptr, std::move(from)) {}
  inline Headers& operator=(const Headers& from) {
    CopyFrom(from);
    return *this;
  }
  inline Headers& operator=(Headers&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Headers& default_instance() {
    return *internal_default_instance();
  }
  static inline const Headers* internal_default_instance() {
    return reinterpret_cast<const Headers*>(
        &_Headers_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 26;
  friend void swap(Headers& a, Headers& b) { a.Swap(&b); }
  inline void Swap(Headers* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Headers* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Headers* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Headers>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Headers& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Headers& from) { Headers::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Headers* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Headers"; }

 protected:
  explicit Headers(::google::protobuf::Arena* arena);
  Headers(::google::protobuf::Arena* arena, const Headers& from);
  Headers(::google::protobuf::Arena* arena, Headers&& from) noexcept
      : Headers(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHeadersFieldNumber = 1,
  };
  // repeated .alyncoin.BlockProto headers = 1;
  int headers_size() const;
  private:
  int _internal_headers_size() const;

  public:
  void clear_headers() ;
  ::alyncoin::BlockProto* mutable_headers(int index);
  ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>* mutable_headers();

  private:
  const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>& _internal_headers() const;
  ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>* _internal_mutable_headers();
  public:
  const ::alyncoin::BlockProto& headers(int index) const;
  ::alyncoin::BlockProto* add_headers();
  const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>& headers() const;
  // @@protoc_insertion_point(class_scope:alyncoin.net.Headers)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Headers& from_msg);
    ::google::protobuf::RepeatedPtrField< ::alyncoin::BlockProto > headers_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockResponse final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.BlockResponse) */ {
 public:
  inline BlockResponse() : BlockResponse(nullptr) {}
  ~BlockResponse() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockResponse* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockResponse));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockResponse(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockResponse(const BlockResponse& from) : BlockResponse(nullptr, from) {}
  inline BlockResponse(BlockResponse&& from) noexcept
      : BlockResponse(nullptr, std::move(from)) {}
  inline BlockResponse& operator=(const BlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockResponse& operator=(BlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockResponse* internal_default_instance() {
    return reinterpret_cast<const BlockResponse*>(
        &_BlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 9;
  friend void swap(BlockResponse& a, BlockResponse& b) { a.Swap(&b); }
  inline void Swap(BlockResponse* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockResponse* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockResponse* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockResponse>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockResponse& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockResponse& from) { BlockResponse::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockResponse* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.BlockResponse"; }

 protected:
  explicit BlockResponse(::google::protobuf::Arena* arena);
  BlockResponse(::google::protobuf::Arena* arena, const BlockResponse& from);
  BlockResponse(::google::protobuf::Arena* arena, BlockResponse&& from) noexcept
      : BlockResponse(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockFieldNumber = 1,
  };
  // .alyncoin.BlockProto block = 1;
  bool has_block() const;
  void clear_block() ;
  const ::alyncoin::BlockProto& block() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockProto* release_block();
  ::alyncoin::BlockProto* mutable_block();
  void set_allocated_block(::alyncoin::BlockProto* value);
  void unsafe_arena_set_allocated_block(::alyncoin::BlockProto* value);
  ::alyncoin::BlockProto* unsafe_arena_release_block();

  private:
  const ::alyncoin::BlockProto& _internal_block() const;
  ::alyncoin::BlockProto* _internal_mutable_block();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockResponse)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockResponse& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::alyncoin::BlockProto* block_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockBroadcast final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.BlockBroadcast) */ {
 public:
  inline BlockBroadcast() : BlockBroadcast(nullptr) {}
  ~BlockBroadcast() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockBroadcast* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockBroadcast));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBroadcast(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockBroadcast(const BlockBroadcast& from) : BlockBroadcast(nullptr, from) {}
  inline BlockBroadcast(BlockBroadcast&& from) noexcept
      : BlockBroadcast(nullptr, std::move(from)) {}
  inline BlockBroadcast& operator=(const BlockBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBroadcast& operator=(BlockBroadcast&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBroadcast& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBroadcast* internal_default_instance() {
    return reinterpret_cast<const BlockBroadcast*>(
        &_BlockBroadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 6;
  friend void swap(BlockBroadcast& a, BlockBroadcast& b) { a.Swap(&b); }
  inline void Swap(BlockBroadcast* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBroadcast* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBroadcast* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockBroadcast>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockBroadcast& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockBroadcast& from) { BlockBroadcast::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockBroadcast* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.BlockBroadcast"; }

 protected:
  explicit BlockBroadcast(::google::protobuf::Arena* arena);
  BlockBroadcast(::google::protobuf::Arena* arena, const BlockBroadcast& from);
  BlockBroadcast(::google::protobuf::Arena* arena, BlockBroadcast&& from) noexcept
      : BlockBroadcast(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kBlockFieldNumber = 1,
  };
  // .alyncoin.BlockProto block = 1;
  bool has_block() const;
  void clear_block() ;
  const ::alyncoin::BlockProto& block() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockProto* release_block();
  ::alyncoin::BlockProto* mutable_block();
  void set_allocated_block(::alyncoin::BlockProto* value);
  void unsafe_arena_set_allocated_block(::alyncoin::BlockProto* value);
  ::alyncoin::BlockProto* unsafe_arena_release_block();

  private:
  const ::alyncoin::BlockProto& _internal_block() const;
  ::alyncoin::BlockProto* _internal_mutable_block();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockBroadcast)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockBroadcast& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::alyncoin::BlockProto* block_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockBatch final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.BlockBatch) */ {
 public:
  inline BlockBatch() : BlockBatch(nullptr) {}
  ~BlockBatch() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(BlockBatch* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(BlockBatch));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR BlockBatch(
      ::google::protobuf::internal::ConstantInitialized);

  inline BlockBatch(const BlockBatch& from) : BlockBatch(nullptr, from) {}
  inline BlockBatch(BlockBatch&& from) noexcept
      : BlockBatch(nullptr, std::move(from)) {}
  inline BlockBatch& operator=(const BlockBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBatch& operator=(BlockBatch&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBatch* internal_default_instance() {
    return reinterpret_cast<const BlockBatch*>(
        &_BlockBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 7;
  friend void swap(BlockBatch& a, BlockBatch& b) { a.Swap(&b); }
  inline void Swap(BlockBatch* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBatch* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBatch* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<BlockBatch>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const BlockBatch& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const BlockBatch& from) { BlockBatch::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(BlockBatch* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.BlockBatch"; }

 protected:
  explicit BlockBatch(::google::protobuf::Arena* arena);
  BlockBatch(::google::protobuf::Arena* arena, const BlockBatch& from);
  BlockBatch(::google::protobuf::Arena* arena, BlockBatch&& from) noexcept
      : BlockBatch(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kChainFieldNumber = 1,
  };
  // .alyncoin.BlockchainProto chain = 1;
  bool has_chain() const;
  void clear_chain() ;
  const ::alyncoin::BlockchainProto& chain() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockchainProto* release_chain();
  ::alyncoin::BlockchainProto* mutable_chain();
  void set_allocated_chain(::alyncoin::BlockchainProto* value);
  void unsafe_arena_set_allocated_chain(::alyncoin::BlockchainProto* value);
  ::alyncoin::BlockchainProto* unsafe_arena_release_chain();

  private:
  const ::alyncoin::BlockchainProto& _internal_chain() const;
  ::alyncoin::BlockchainProto* _internal_mutable_chain();

  public:
  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockBatch)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 1, 1,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const BlockBatch& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::alyncoin::BlockchainProto* chain_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Frame final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:alyncoin.net.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(Frame* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(Frame));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR Frame(
      ::google::protobuf::internal::ConstantInitialized);

  inline Frame(const Frame& from) : Frame(nullptr, from) {}
  inline Frame(Frame&& from) noexcept
      : Frame(nullptr, std::move(from)) {}
  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kHandshake = 1,
    kPing = 2,
    kPong = 3,
    kHeightReq = 4,
    kHeightRes = 5,
    kHeightProbe = 31,
    kBlockBroadcast = 6,
    kBlockBatch = 7,
    kBlockRequest = 29,
    kBlockResponse = 30,
    kSnapshotMeta = 8,
    kSnapshotChunk = 9,
    kSnapshotAck = 10,
    kSnapshotEnd = 11,
    kTailBlocks = 12,
    kAggProof = 13,
    kInv = 14,
    kTipHashReq = 15,
    kTipHashRes = 16,
    kPeerListReq = 17,
    kPeerList = 18,
    kRollupBlock = 19,
    kSnapshotReq = 20,
    kTailReq = 21,
    kStateProof = 22,
    kGetData = 23,
    kBlockchainSyncRequest = 24,
    kTxBroadcast = 25,
    kWhisper = 26,
    kGetHeaders = 27,
    kHeaders = 28,
    KIND_NOT_SET = 0,
  };
  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
        &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 30;
  friend void swap(Frame& a, Frame& b) { a.Swap(&b); }
  inline void Swap(Frame* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<Frame>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const Frame& from) { Frame::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(Frame* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "alyncoin.net.Frame"; }

 protected:
  explicit Frame(::google::protobuf::Arena* arena);
  Frame(::google::protobuf::Arena* arena, const Frame& from);
  Frame(::google::protobuf::Arena* arena, Frame&& from) noexcept
      : Frame(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kHandshakeFieldNumber = 1,
    kPingFieldNumber = 2,
    kPongFieldNumber = 3,
    kHeightReqFieldNumber = 4,
    kHeightResFieldNumber = 5,
    kHeightProbeFieldNumber = 31,
    kBlockBroadcastFieldNumber = 6,
    kBlockBatchFieldNumber = 7,
    kBlockRequestFieldNumber = 29,
    kBlockResponseFieldNumber = 30,
    kSnapshotMetaFieldNumber = 8,
    kSnapshotChunkFieldNumber = 9,
    kSnapshotAckFieldNumber = 10,
    kSnapshotEndFieldNumber = 11,
    kTailBlocksFieldNumber = 12,
    kAggProofFieldNumber = 13,
    kInvFieldNumber = 14,
    kTipHashReqFieldNumber = 15,
    kTipHashResFieldNumber = 16,
    kPeerListReqFieldNumber = 17,
    kPeerListFieldNumber = 18,
    kRollupBlockFieldNumber = 19,
    kSnapshotReqFieldNumber = 20,
    kTailReqFieldNumber = 21,
    kStateProofFieldNumber = 22,
    kGetDataFieldNumber = 23,
    kBlockchainSyncRequestFieldNumber = 24,
    kTxBroadcastFieldNumber = 25,
    kWhisperFieldNumber = 26,
    kGetHeadersFieldNumber = 27,
    kHeadersFieldNumber = 28,
  };
  // .alyncoin.net.Handshake handshake = 1;
  bool has_handshake() const;
  private:
  bool _internal_has_handshake() const;

  public:
  void clear_handshake() ;
  const ::alyncoin::net::Handshake& handshake() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Handshake* release_handshake();
  ::alyncoin::net::Handshake* mutable_handshake();
  void set_allocated_handshake(::alyncoin::net::Handshake* value);
  void unsafe_arena_set_allocated_handshake(::alyncoin::net::Handshake* value);
  ::alyncoin::net::Handshake* unsafe_arena_release_handshake();

  private:
  const ::alyncoin::net::Handshake& _internal_handshake() const;
  ::alyncoin::net::Handshake* _internal_mutable_handshake();

  public:
  // .alyncoin.net.Ping ping = 2;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;

  public:
  void clear_ping() ;
  const ::alyncoin::net::Ping& ping() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Ping* release_ping();
  ::alyncoin::net::Ping* mutable_ping();
  void set_allocated_ping(::alyncoin::net::Ping* value);
  void unsafe_arena_set_allocated_ping(::alyncoin::net::Ping* value);
  ::alyncoin::net::Ping* unsafe_arena_release_ping();

  private:
  const ::alyncoin::net::Ping& _internal_ping() const;
  ::alyncoin::net::Ping* _internal_mutable_ping();

  public:
  // .alyncoin.net.Pong pong = 3;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;

  public:
  void clear_pong() ;
  const ::alyncoin::net::Pong& pong() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Pong* release_pong();
  ::alyncoin::net::Pong* mutable_pong();
  void set_allocated_pong(::alyncoin::net::Pong* value);
  void unsafe_arena_set_allocated_pong(::alyncoin::net::Pong* value);
  ::alyncoin::net::Pong* unsafe_arena_release_pong();

  private:
  const ::alyncoin::net::Pong& _internal_pong() const;
  ::alyncoin::net::Pong* _internal_mutable_pong();

  public:
  // .alyncoin.net.HeightRequest height_req = 4;
  bool has_height_req() const;
  private:
  bool _internal_has_height_req() const;

  public:
  void clear_height_req() ;
  const ::alyncoin::net::HeightRequest& height_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightRequest* release_height_req();
  ::alyncoin::net::HeightRequest* mutable_height_req();
  void set_allocated_height_req(::alyncoin::net::HeightRequest* value);
  void unsafe_arena_set_allocated_height_req(::alyncoin::net::HeightRequest* value);
  ::alyncoin::net::HeightRequest* unsafe_arena_release_height_req();

  private:
  const ::alyncoin::net::HeightRequest& _internal_height_req() const;
  ::alyncoin::net::HeightRequest* _internal_mutable_height_req();

  public:
  // .alyncoin.net.HeightResponse height_res = 5;
  bool has_height_res() const;
  private:
  bool _internal_has_height_res() const;

  public:
  void clear_height_res() ;
  const ::alyncoin::net::HeightResponse& height_res() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightResponse* release_height_res();
  ::alyncoin::net::HeightResponse* mutable_height_res();
  void set_allocated_height_res(::alyncoin::net::HeightResponse* value);
  void unsafe_arena_set_allocated_height_res(::alyncoin::net::HeightResponse* value);
  ::alyncoin::net::HeightResponse* unsafe_arena_release_height_res();

  private:
  const ::alyncoin::net::HeightResponse& _internal_height_res() const;
  ::alyncoin::net::HeightResponse* _internal_mutable_height_res();

  public:
  // .alyncoin.net.HeightProbe height_probe = 31;
  bool has_height_probe() const;
  private:
  bool _internal_has_height_probe() const;

  public:
  void clear_height_probe() ;
  const ::alyncoin::net::HeightProbe& height_probe() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightProbe* release_height_probe();
  ::alyncoin::net::HeightProbe* mutable_height_probe();
  void set_allocated_height_probe(::alyncoin::net::HeightProbe* value);
  void unsafe_arena_set_allocated_height_probe(::alyncoin::net::HeightProbe* value);
  ::alyncoin::net::HeightProbe* unsafe_arena_release_height_probe();

  private:
  const ::alyncoin::net::HeightProbe& _internal_height_probe() const;
  ::alyncoin::net::HeightProbe* _internal_mutable_height_probe();

  public:
  // .alyncoin.net.BlockBroadcast block_broadcast = 6;
  bool has_block_broadcast() const;
  private:
  bool _internal_has_block_broadcast() const;

  public:
  void clear_block_broadcast() ;
  const ::alyncoin::net::BlockBroadcast& block_broadcast() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockBroadcast* release_block_broadcast();
  ::alyncoin::net::BlockBroadcast* mutable_block_broadcast();
  void set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* value);
  void unsafe_arena_set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* value);
  ::alyncoin::net::BlockBroadcast* unsafe_arena_release_block_broadcast();

  private:
  const ::alyncoin::net::BlockBroadcast& _internal_block_broadcast() const;
  ::alyncoin::net::BlockBroadcast* _internal_mutable_block_broadcast();

  public:
  // .alyncoin.net.BlockBatch block_batch = 7;
  bool has_block_batch() const;
  private:
  bool _internal_has_block_batch() const;

  public:
  void clear_block_batch() ;
  const ::alyncoin::net::BlockBatch& block_batch() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockBatch* release_block_batch();
  ::alyncoin::net::BlockBatch* mutable_block_batch();
  void set_allocated_block_batch(::alyncoin::net::BlockBatch* value);
  void unsafe_arena_set_allocated_block_batch(::alyncoin::net::BlockBatch* value);
  ::alyncoin::net::BlockBatch* unsafe_arena_release_block_batch();

  private:
  const ::alyncoin::net::BlockBatch& _internal_block_batch() const;
  ::alyncoin::net::BlockBatch* _internal_mutable_block_batch();

  public:
  // .alyncoin.net.BlockRequest block_request = 29;
  bool has_block_request() const;
  private:
  bool _internal_has_block_request() const;

  public:
  void clear_block_request() ;
  const ::alyncoin::net::BlockRequest& block_request() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockRequest* release_block_request();
  ::alyncoin::net::BlockRequest* mutable_block_request();
  void set_allocated_block_request(::alyncoin::net::BlockRequest* value);
  void unsafe_arena_set_allocated_block_request(::alyncoin::net::BlockRequest* value);
  ::alyncoin::net::BlockRequest* unsafe_arena_release_block_request();

  private:
  const ::alyncoin::net::BlockRequest& _internal_block_request() const;
  ::alyncoin::net::BlockRequest* _internal_mutable_block_request();

  public:
  // .alyncoin.net.BlockResponse block_response = 30;
  bool has_block_response() const;
  private:
  bool _internal_has_block_response() const;

  public:
  void clear_block_response() ;
  const ::alyncoin::net::BlockResponse& block_response() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockResponse* release_block_response();
  ::alyncoin::net::BlockResponse* mutable_block_response();
  void set_allocated_block_response(::alyncoin::net::BlockResponse* value);
  void unsafe_arena_set_allocated_block_response(::alyncoin::net::BlockResponse* value);
  ::alyncoin::net::BlockResponse* unsafe_arena_release_block_response();

  private:
  const ::alyncoin::net::BlockResponse& _internal_block_response() const;
  ::alyncoin::net::BlockResponse* _internal_mutable_block_response();

  public:
  // .alyncoin.net.SnapshotMeta snapshot_meta = 8;
  bool has_snapshot_meta() const;
  private:
  bool _internal_has_snapshot_meta() const;

  public:
  void clear_snapshot_meta() ;
  const ::alyncoin::net::SnapshotMeta& snapshot_meta() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotMeta* release_snapshot_meta();
  ::alyncoin::net::SnapshotMeta* mutable_snapshot_meta();
  void set_allocated_snapshot_meta(::alyncoin::net::SnapshotMeta* value);
  void unsafe_arena_set_allocated_snapshot_meta(::alyncoin::net::SnapshotMeta* value);
  ::alyncoin::net::SnapshotMeta* unsafe_arena_release_snapshot_meta();

  private:
  const ::alyncoin::net::SnapshotMeta& _internal_snapshot_meta() const;
  ::alyncoin::net::SnapshotMeta* _internal_mutable_snapshot_meta();

  public:
  // .alyncoin.net.SnapshotChunk snapshot_chunk = 9;
  bool has_snapshot_chunk() const;
  private:
  bool _internal_has_snapshot_chunk() const;

  public:
  void clear_snapshot_chunk() ;
  const ::alyncoin::net::SnapshotChunk& snapshot_chunk() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotChunk* release_snapshot_chunk();
  ::alyncoin::net::SnapshotChunk* mutable_snapshot_chunk();
  void set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* value);
  void unsafe_arena_set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* value);
  ::alyncoin::net::SnapshotChunk* unsafe_arena_release_snapshot_chunk();

  private:
  const ::alyncoin::net::SnapshotChunk& _internal_snapshot_chunk() const;
  ::alyncoin::net::SnapshotChunk* _internal_mutable_snapshot_chunk();

  public:
  // .alyncoin.net.SnapshotAck snapshot_ack = 10;
  bool has_snapshot_ack() const;
  private:
  bool _internal_has_snapshot_ack() const;

  public:
  void clear_snapshot_ack() ;
  const ::alyncoin::net::SnapshotAck& snapshot_ack() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotAck* release_snapshot_ack();
  ::alyncoin::net::SnapshotAck* mutable_snapshot_ack();
  void set_allocated_snapshot_ack(::alyncoin::net::SnapshotAck* value);
  void unsafe_arena_set_allocated_snapshot_ack(::alyncoin::net::SnapshotAck* value);
  ::alyncoin::net::SnapshotAck* unsafe_arena_release_snapshot_ack();

  private:
  const ::alyncoin::net::SnapshotAck& _internal_snapshot_ack() const;
  ::alyncoin::net::SnapshotAck* _internal_mutable_snapshot_ack();

  public:
  // .alyncoin.net.SnapshotEnd snapshot_end = 11;
  bool has_snapshot_end() const;
  private:
  bool _internal_has_snapshot_end() const;

  public:
  void clear_snapshot_end() ;
  const ::alyncoin::net::SnapshotEnd& snapshot_end() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotEnd* release_snapshot_end();
  ::alyncoin::net::SnapshotEnd* mutable_snapshot_end();
  void set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* value);
  void unsafe_arena_set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* value);
  ::alyncoin::net::SnapshotEnd* unsafe_arena_release_snapshot_end();

  private:
  const ::alyncoin::net::SnapshotEnd& _internal_snapshot_end() const;
  ::alyncoin::net::SnapshotEnd* _internal_mutable_snapshot_end();

  public:
  // .alyncoin.net.TailBlocks tail_blocks = 12;
  bool has_tail_blocks() const;
  private:
  bool _internal_has_tail_blocks() const;

  public:
  void clear_tail_blocks() ;
  const ::alyncoin::net::TailBlocks& tail_blocks() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TailBlocks* release_tail_blocks();
  ::alyncoin::net::TailBlocks* mutable_tail_blocks();
  void set_allocated_tail_blocks(::alyncoin::net::TailBlocks* value);
  void unsafe_arena_set_allocated_tail_blocks(::alyncoin::net::TailBlocks* value);
  ::alyncoin::net::TailBlocks* unsafe_arena_release_tail_blocks();

  private:
  const ::alyncoin::net::TailBlocks& _internal_tail_blocks() const;
  ::alyncoin::net::TailBlocks* _internal_mutable_tail_blocks();

  public:
  // .alyncoin.net.EpochProof agg_proof = 13;
  bool has_agg_proof() const;
  private:
  bool _internal_has_agg_proof() const;

  public:
  void clear_agg_proof() ;
  const ::alyncoin::net::EpochProof& agg_proof() const;
  PROTOBUF_NODISCARD ::alyncoin::net::EpochProof* release_agg_proof();
  ::alyncoin::net::EpochProof* mutable_agg_proof();
  void set_allocated_agg_proof(::alyncoin::net::EpochProof* value);
  void unsafe_arena_set_allocated_agg_proof(::alyncoin::net::EpochProof* value);
  ::alyncoin::net::EpochProof* unsafe_arena_release_agg_proof();

  private:
  const ::alyncoin::net::EpochProof& _internal_agg_proof() const;
  ::alyncoin::net::EpochProof* _internal_mutable_agg_proof();

  public:
  // .alyncoin.net.Inventory inv = 14;
  bool has_inv() const;
  private:
  bool _internal_has_inv() const;

  public:
  void clear_inv() ;
  const ::alyncoin::net::Inventory& inv() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Inventory* release_inv();
  ::alyncoin::net::Inventory* mutable_inv();
  void set_allocated_inv(::alyncoin::net::Inventory* value);
  void unsafe_arena_set_allocated_inv(::alyncoin::net::Inventory* value);
  ::alyncoin::net::Inventory* unsafe_arena_release_inv();

  private:
  const ::alyncoin::net::Inventory& _internal_inv() const;
  ::alyncoin::net::Inventory* _internal_mutable_inv();

  public:
  // .alyncoin.net.TipHashRequest tip_hash_req = 15;
  bool has_tip_hash_req() const;
  private:
  bool _internal_has_tip_hash_req() const;

  public:
  void clear_tip_hash_req() ;
  const ::alyncoin::net::TipHashRequest& tip_hash_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TipHashRequest* release_tip_hash_req();
  ::alyncoin::net::TipHashRequest* mutable_tip_hash_req();
  void set_allocated_tip_hash_req(::alyncoin::net::TipHashRequest* value);
  void unsafe_arena_set_allocated_tip_hash_req(::alyncoin::net::TipHashRequest* value);
  ::alyncoin::net::TipHashRequest* unsafe_arena_release_tip_hash_req();

  private:
  const ::alyncoin::net::TipHashRequest& _internal_tip_hash_req() const;
  ::alyncoin::net::TipHashRequest* _internal_mutable_tip_hash_req();

  public:
  // .alyncoin.net.TipHashResponse tip_hash_res = 16;
  bool has_tip_hash_res() const;
  private:
  bool _internal_has_tip_hash_res() const;

  public:
  void clear_tip_hash_res() ;
  const ::alyncoin::net::TipHashResponse& tip_hash_res() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TipHashResponse* release_tip_hash_res();
  ::alyncoin::net::TipHashResponse* mutable_tip_hash_res();
  void set_allocated_tip_hash_res(::alyncoin::net::TipHashResponse* value);
  void unsafe_arena_set_allocated_tip_hash_res(::alyncoin::net::TipHashResponse* value);
  ::alyncoin::net::TipHashResponse* unsafe_arena_release_tip_hash_res();

  private:
  const ::alyncoin::net::TipHashResponse& _internal_tip_hash_res() const;
  ::alyncoin::net::TipHashResponse* _internal_mutable_tip_hash_res();

  public:
  // .alyncoin.net.PeerListRequest peer_list_req = 17;
  bool has_peer_list_req() const;
  private:
  bool _internal_has_peer_list_req() const;

  public:
  void clear_peer_list_req() ;
  const ::alyncoin::net::PeerListRequest& peer_list_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::PeerListRequest* release_peer_list_req();
  ::alyncoin::net::PeerListRequest* mutable_peer_list_req();
  void set_allocated_peer_list_req(::alyncoin::net::PeerListRequest* value);
  void unsafe_arena_set_allocated_peer_list_req(::alyncoin::net::PeerListRequest* value);
  ::alyncoin::net::PeerListRequest* unsafe_arena_release_peer_list_req();

  private:
  const ::alyncoin::net::PeerListRequest& _internal_peer_list_req() const;
  ::alyncoin::net::PeerListRequest* _internal_mutable_peer_list_req();

  public:
  // .alyncoin.net.PeerList peer_list = 18;
  bool has_peer_list() const;
  private:
  bool _internal_has_peer_list() const;

  public:
  void clear_peer_list() ;
  const ::alyncoin::net::PeerList& peer_list() const;
  PROTOBUF_NODISCARD ::alyncoin::net::PeerList* release_peer_list();
  ::alyncoin::net::PeerList* mutable_peer_list();
  void set_allocated_peer_list(::alyncoin::net::PeerList* value);
  void unsafe_arena_set_allocated_peer_list(::alyncoin::net::PeerList* value);
  ::alyncoin::net::PeerList* unsafe_arena_release_peer_list();

  private:
  const ::alyncoin::net::PeerList& _internal_peer_list() const;
  ::alyncoin::net::PeerList* _internal_mutable_peer_list();

  public:
  // .alyncoin.net.RollupBlockMsg rollup_block = 19;
  bool has_rollup_block() const;
  private:
  bool _internal_has_rollup_block() const;

  public:
  void clear_rollup_block() ;
  const ::alyncoin::net::RollupBlockMsg& rollup_block() const;
  PROTOBUF_NODISCARD ::alyncoin::net::RollupBlockMsg* release_rollup_block();
  ::alyncoin::net::RollupBlockMsg* mutable_rollup_block();
  void set_allocated_rollup_block(::alyncoin::net::RollupBlockMsg* value);
  void unsafe_arena_set_allocated_rollup_block(::alyncoin::net::RollupBlockMsg* value);
  ::alyncoin::net::RollupBlockMsg* unsafe_arena_release_rollup_block();

  private:
  const ::alyncoin::net::RollupBlockMsg& _internal_rollup_block() const;
  ::alyncoin::net::RollupBlockMsg* _internal_mutable_rollup_block();

  public:
  // .alyncoin.net.SnapshotRequest snapshot_req = 20;
  bool has_snapshot_req() const;
  private:
  bool _internal_has_snapshot_req() const;

  public:
  void clear_snapshot_req() ;
  const ::alyncoin::net::SnapshotRequest& snapshot_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotRequest* release_snapshot_req();
  ::alyncoin::net::SnapshotRequest* mutable_snapshot_req();
  void set_allocated_snapshot_req(::alyncoin::net::SnapshotRequest* value);
  void unsafe_arena_set_allocated_snapshot_req(::alyncoin::net::SnapshotRequest* value);
  ::alyncoin::net::SnapshotRequest* unsafe_arena_release_snapshot_req();

  private:
  const ::alyncoin::net::SnapshotRequest& _internal_snapshot_req() const;
  ::alyncoin::net::SnapshotRequest* _internal_mutable_snapshot_req();

  public:
  // .alyncoin.net.TailBlocksRequest tail_req = 21;
  bool has_tail_req() const;
  private:
  bool _internal_has_tail_req() const;

  public:
  void clear_tail_req() ;
  const ::alyncoin::net::TailBlocksRequest& tail_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TailBlocksRequest* release_tail_req();
  ::alyncoin::net::TailBlocksRequest* mutable_tail_req();
  void set_allocated_tail_req(::alyncoin::net::TailBlocksRequest* value);
  void unsafe_arena_set_allocated_tail_req(::alyncoin::net::TailBlocksRequest* value);
  ::alyncoin::net::TailBlocksRequest* unsafe_arena_release_tail_req();

  private:
  const ::alyncoin::net::TailBlocksRequest& _internal_tail_req() const;
  ::alyncoin::net::TailBlocksRequest* _internal_mutable_tail_req();

  public:
  // .alyncoin.net.StateProof state_proof = 22;
  bool has_state_proof() const;
  private:
  bool _internal_has_state_proof() const;

  public:
  void clear_state_proof() ;
  const ::alyncoin::net::StateProof& state_proof() const;
  PROTOBUF_NODISCARD ::alyncoin::net::StateProof* release_state_proof();
  ::alyncoin::net::StateProof* mutable_state_proof();
  void set_allocated_state_proof(::alyncoin::net::StateProof* value);
  void unsafe_arena_set_allocated_state_proof(::alyncoin::net::StateProof* value);
  ::alyncoin::net::StateProof* unsafe_arena_release_state_proof();

  private:
  const ::alyncoin::net::StateProof& _internal_state_proof() const;
  ::alyncoin::net::StateProof* _internal_mutable_state_proof();

  public:
  // .alyncoin.net.GetData get_data = 23;
  bool has_get_data() const;
  private:
  bool _internal_has_get_data() const;

  public:
  void clear_get_data() ;
  const ::alyncoin::net::GetData& get_data() const;
  PROTOBUF_NODISCARD ::alyncoin::net::GetData* release_get_data();
  ::alyncoin::net::GetData* mutable_get_data();
  void set_allocated_get_data(::alyncoin::net::GetData* value);
  void unsafe_arena_set_allocated_get_data(::alyncoin::net::GetData* value);
  ::alyncoin::net::GetData* unsafe_arena_release_get_data();

  private:
  const ::alyncoin::net::GetData& _internal_get_data() const;
  ::alyncoin::net::GetData* _internal_mutable_get_data();

  public:
  // .alyncoin.BlockchainSyncProto blockchain_sync_request = 24;
  bool has_blockchain_sync_request() const;
  private:
  bool _internal_has_blockchain_sync_request() const;

  public:
  void clear_blockchain_sync_request() ;
  const ::alyncoin::BlockchainSyncProto& blockchain_sync_request() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockchainSyncProto* release_blockchain_sync_request();
  ::alyncoin::BlockchainSyncProto* mutable_blockchain_sync_request();
  void set_allocated_blockchain_sync_request(::alyncoin::BlockchainSyncProto* value);
  void unsafe_arena_set_allocated_blockchain_sync_request(::alyncoin::BlockchainSyncProto* value);
  ::alyncoin::BlockchainSyncProto* unsafe_arena_release_blockchain_sync_request();

  private:
  const ::alyncoin::BlockchainSyncProto& _internal_blockchain_sync_request() const;
  ::alyncoin::BlockchainSyncProto* _internal_mutable_blockchain_sync_request();

  public:
  // .alyncoin.net.TransactionBroadcast tx_broadcast = 25;
  bool has_tx_broadcast() const;
  private:
  bool _internal_has_tx_broadcast() const;

  public:
  void clear_tx_broadcast() ;
  const ::alyncoin::net::TransactionBroadcast& tx_broadcast() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TransactionBroadcast* release_tx_broadcast();
  ::alyncoin::net::TransactionBroadcast* mutable_tx_broadcast();
  void set_allocated_tx_broadcast(::alyncoin::net::TransactionBroadcast* value);
  void unsafe_arena_set_allocated_tx_broadcast(::alyncoin::net::TransactionBroadcast* value);
  ::alyncoin::net::TransactionBroadcast* unsafe_arena_release_tx_broadcast();

  private:
  const ::alyncoin::net::TransactionBroadcast& _internal_tx_broadcast() const;
  ::alyncoin::net::TransactionBroadcast* _internal_mutable_tx_broadcast();

  public:
  // .alyncoin.net.Whisper whisper = 26;
  bool has_whisper() const;
  private:
  bool _internal_has_whisper() const;

  public:
  void clear_whisper() ;
  const ::alyncoin::net::Whisper& whisper() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Whisper* release_whisper();
  ::alyncoin::net::Whisper* mutable_whisper();
  void set_allocated_whisper(::alyncoin::net::Whisper* value);
  void unsafe_arena_set_allocated_whisper(::alyncoin::net::Whisper* value);
  ::alyncoin::net::Whisper* unsafe_arena_release_whisper();

  private:
  const ::alyncoin::net::Whisper& _internal_whisper() const;
  ::alyncoin::net::Whisper* _internal_mutable_whisper();

  public:
  // .alyncoin.net.GetHeaders get_headers = 27;
  bool has_get_headers() const;
  private:
  bool _internal_has_get_headers() const;

  public:
  void clear_get_headers() ;
  const ::alyncoin::net::GetHeaders& get_headers() const;
  PROTOBUF_NODISCARD ::alyncoin::net::GetHeaders* release_get_headers();
  ::alyncoin::net::GetHeaders* mutable_get_headers();
  void set_allocated_get_headers(::alyncoin::net::GetHeaders* value);
  void unsafe_arena_set_allocated_get_headers(::alyncoin::net::GetHeaders* value);
  ::alyncoin::net::GetHeaders* unsafe_arena_release_get_headers();

  private:
  const ::alyncoin::net::GetHeaders& _internal_get_headers() const;
  ::alyncoin::net::GetHeaders* _internal_mutable_get_headers();

  public:
  // .alyncoin.net.Headers headers = 28;
  bool has_headers() const;
  private:
  bool _internal_has_headers() const;

  public:
  void clear_headers() ;
  const ::alyncoin::net::Headers& headers() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Headers* release_headers();
  ::alyncoin::net::Headers* mutable_headers();
  void set_allocated_headers(::alyncoin::net::Headers* value);
  void unsafe_arena_set_allocated_headers(::alyncoin::net::Headers* value);
  ::alyncoin::net::Headers* unsafe_arena_release_headers();

  private:
  const ::alyncoin::net::Headers& _internal_headers() const;
  ::alyncoin::net::Headers* _internal_mutable_headers();

  public:
  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:alyncoin.net.Frame)
 private:
  class _Internal;
  void set_has_handshake();
  void set_has_ping();
  void set_has_pong();
  void set_has_height_req();
  void set_has_height_res();
  void set_has_height_probe();
  void set_has_block_broadcast();
  void set_has_block_batch();
  void set_has_block_request();
  void set_has_block_response();
  void set_has_snapshot_meta();
  void set_has_snapshot_chunk();
  void set_has_snapshot_ack();
  void set_has_snapshot_end();
  void set_has_tail_blocks();
  void set_has_agg_proof();
  void set_has_inv();
  void set_has_tip_hash_req();
  void set_has_tip_hash_res();
  void set_has_peer_list_req();
  void set_has_peer_list();
  void set_has_rollup_block();
  void set_has_snapshot_req();
  void set_has_tail_req();
  void set_has_state_proof();
  void set_has_get_data();
  void set_has_blockchain_sync_request();
  void set_has_tx_broadcast();
  void set_has_whisper();
  void set_has_get_headers();
  void set_has_headers();
  inline bool has_kind() const;
  inline void clear_has_kind();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      0, 31, 31,
      0, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const Frame& from_msg);
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::alyncoin::net::Handshake* handshake_;
      ::alyncoin::net::Ping* ping_;
      ::alyncoin::net::Pong* pong_;
      ::alyncoin::net::HeightRequest* height_req_;
      ::alyncoin::net::HeightResponse* height_res_;
      ::alyncoin::net::HeightProbe* height_probe_;
      ::alyncoin::net::BlockBroadcast* block_broadcast_;
      ::alyncoin::net::BlockBatch* block_batch_;
      ::alyncoin::net::BlockRequest* block_request_;
      ::alyncoin::net::BlockResponse* block_response_;
      ::alyncoin::net::SnapshotMeta* snapshot_meta_;
      ::alyncoin::net::SnapshotChunk* snapshot_chunk_;
      ::alyncoin::net::SnapshotAck* snapshot_ack_;
      ::alyncoin::net::SnapshotEnd* snapshot_end_;
      ::alyncoin::net::TailBlocks* tail_blocks_;
      ::alyncoin::net::EpochProof* agg_proof_;
      ::alyncoin::net::Inventory* inv_;
      ::alyncoin::net::TipHashRequest* tip_hash_req_;
      ::alyncoin::net::TipHashResponse* tip_hash_res_;
      ::alyncoin::net::PeerListRequest* peer_list_req_;
      ::alyncoin::net::PeerList* peer_list_;
      ::alyncoin::net::RollupBlockMsg* rollup_block_;
      ::alyncoin::net::SnapshotRequest* snapshot_req_;
      ::alyncoin::net::TailBlocksRequest* tail_req_;
      ::alyncoin::net::StateProof* state_proof_;
      ::alyncoin::net::GetData* get_data_;
      ::alyncoin::BlockchainSyncProto* blockchain_sync_request_;
      ::alyncoin::net::TransactionBroadcast* tx_broadcast_;
      ::alyncoin::net::Whisper* whisper_;
      ::alyncoin::net::GetHeaders* get_headers_;
      ::alyncoin::net::Headers* headers_;
    } kind_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Handshake

// string version = 1;
inline void Handshake::clear_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Handshake::version() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.version)
  return _internal_version();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_version(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.version)
}
inline std::string* Handshake::mutable_version() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.version)
  return _s;
}
inline const std::string& Handshake::_internal_version() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.version_.Get();
}
inline void Handshake::_internal_set_version(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.Set(value, GetArena());
}
inline std::string* Handshake::_internal_mutable_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.version_.Mutable( GetArena());
}
inline std::string* Handshake::release_version() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.version)
  return _impl_.version_.Release();
}
inline void Handshake::set_allocated_version(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.version_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.version)
}

// string network_id = 2;
inline void Handshake::clear_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.ClearToEmpty();
}
inline const std::string& Handshake::network_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.network_id)
  return _internal_network_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_network_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.network_id)
}
inline std::string* Handshake::mutable_network_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_network_id();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.network_id)
  return _s;
}
inline const std::string& Handshake::_internal_network_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.network_id_.Get();
}
inline void Handshake::_internal_set_network_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.Set(value, GetArena());
}
inline std::string* Handshake::_internal_mutable_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.network_id_.Mutable( GetArena());
}
inline std::string* Handshake::release_network_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.network_id)
  return _impl_.network_id_.Release();
}
inline void Handshake::set_allocated_network_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.network_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.network_id_.IsDefault()) {
    _impl_.network_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.network_id)
}

// uint64 height = 3;
inline void Handshake::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t Handshake::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.height)
  return _internal_height();
}
inline void Handshake::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.height)
}
inline ::uint64_t Handshake::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void Handshake::_internal_set_height(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// uint32 listen_port = 4;
inline void Handshake::clear_listen_port() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listen_port_ = 0u;
}
inline ::uint32_t Handshake::listen_port() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.listen_port)
  return _internal_listen_port();
}
inline void Handshake::set_listen_port(::uint32_t value) {
  _internal_set_listen_port(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.listen_port)
}
inline ::uint32_t Handshake::_internal_listen_port() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.listen_port_;
}
inline void Handshake::_internal_set_listen_port(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.listen_port_ = value;
}

// bytes genesis_hash = 5;
inline void Handshake::clear_genesis_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.genesis_hash_.ClearToEmpty();
}
inline const std::string& Handshake::genesis_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.genesis_hash)
  return _internal_genesis_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_genesis_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.genesis_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.genesis_hash)
}
inline std::string* Handshake::mutable_genesis_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_genesis_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.genesis_hash)
  return _s;
}
inline const std::string& Handshake::_internal_genesis_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.genesis_hash_.Get();
}
inline void Handshake::_internal_set_genesis_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.genesis_hash_.Set(value, GetArena());
}
inline std::string* Handshake::_internal_mutable_genesis_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.genesis_hash_.Mutable( GetArena());
}
inline std::string* Handshake::release_genesis_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.genesis_hash)
  return _impl_.genesis_hash_.Release();
}
inline void Handshake::set_allocated_genesis_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.genesis_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.genesis_hash_.IsDefault()) {
    _impl_.genesis_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.genesis_hash)
}

// repeated string capabilities = 6;
inline int Handshake::_internal_capabilities_size() const {
  return _internal_capabilities().size();
}
inline int Handshake::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void Handshake::clear_capabilities() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.capabilities_.Clear();
}
inline std::string* Handshake::add_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_capabilities()->Add();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.Handshake.capabilities)
  return _s;
}
inline const std::string& Handshake::capabilities(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.capabilities)
  return _internal_capabilities().Get(index);
}
inline std::string* Handshake::mutable_capabilities(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.capabilities)
  return _internal_mutable_capabilities()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Handshake::set_capabilities(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_capabilities()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.capabilities)
}
template <typename Arg_, typename... Args_>
inline void Handshake::add_capabilities(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_capabilities(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:alyncoin.net.Handshake.capabilities)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Handshake::capabilities() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:alyncoin.net.Handshake.capabilities)
  return _internal_capabilities();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Handshake::mutable_capabilities() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.Handshake.capabilities)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_capabilities();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Handshake::_internal_capabilities() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.capabilities_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Handshake::_internal_mutable_capabilities() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.capabilities_;
}

// bytes pub_key = 7;
inline void Handshake::clear_pub_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pub_key_.ClearToEmpty();
}
inline const std::string& Handshake::pub_key() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.pub_key)
  return _internal_pub_key();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_pub_key(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pub_key_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.pub_key)
}
inline std::string* Handshake::mutable_pub_key() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_pub_key();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.pub_key)
  return _s;
}
inline const std::string& Handshake::_internal_pub_key() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.pub_key_.Get();
}
inline void Handshake::_internal_set_pub_key(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pub_key_.Set(value, GetArena());
}
inline std::string* Handshake::_internal_mutable_pub_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.pub_key_.Mutable( GetArena());
}
inline std::string* Handshake::release_pub_key() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.pub_key)
  return _impl_.pub_key_.Release();
}
inline void Handshake::set_allocated_pub_key(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.pub_key_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.pub_key_.IsDefault()) {
    _impl_.pub_key_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.pub_key)
}

// uint32 frame_rev = 8;
inline void Handshake::clear_frame_rev() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_rev_ = 0u;
}
inline ::uint32_t Handshake::frame_rev() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.frame_rev)
  return _internal_frame_rev();
}
inline void Handshake::set_frame_rev(::uint32_t value) {
  _internal_set_frame_rev(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.frame_rev)
}
inline ::uint32_t Handshake::_internal_frame_rev() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.frame_rev_;
}
inline void Handshake::_internal_set_frame_rev(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.frame_rev_ = value;
}

// uint64 total_work = 9;
inline void Handshake::clear_total_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_work_ = ::uint64_t{0u};
}
inline ::uint64_t Handshake::total_work() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.total_work)
  return _internal_total_work();
}
inline void Handshake::set_total_work(::uint64_t value) {
  _internal_set_total_work(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.total_work)
}
inline ::uint64_t Handshake::_internal_total_work() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_work_;
}
inline void Handshake::_internal_set_total_work(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_work_ = value;
}

// bool want_snapshot = 10;
inline void Handshake::clear_want_snapshot() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.want_snapshot_ = false;
}
inline bool Handshake::want_snapshot() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.want_snapshot)
  return _internal_want_snapshot();
}
inline void Handshake::set_want_snapshot(bool value) {
  _internal_set_want_snapshot(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.want_snapshot)
}
inline bool Handshake::_internal_want_snapshot() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.want_snapshot_;
}
inline void Handshake::_internal_set_want_snapshot(bool value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.want_snapshot_ = value;
}

// uint32 snapshot_size = 11;
inline void Handshake::clear_snapshot_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_size_ = 0u;
}
inline ::uint32_t Handshake::snapshot_size() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.snapshot_size)
  return _internal_snapshot_size();
}
inline void Handshake::set_snapshot_size(::uint32_t value) {
  _internal_set_snapshot_size(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.snapshot_size)
}
inline ::uint32_t Handshake::_internal_snapshot_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.snapshot_size_;
}
inline void Handshake::_internal_set_snapshot_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.snapshot_size_ = value;
}

// string node_id = 12;
inline void Handshake::clear_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.ClearToEmpty();
}
inline const std::string& Handshake::node_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.node_id)
  return _internal_node_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Handshake::set_node_id(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.node_id)
}
inline std::string* Handshake::mutable_node_id() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_node_id();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.node_id)
  return _s;
}
inline const std::string& Handshake::_internal_node_id() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_id_.Get();
}
inline void Handshake::_internal_set_node_id(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.Set(value, GetArena());
}
inline std::string* Handshake::_internal_mutable_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.node_id_.Mutable( GetArena());
}
inline std::string* Handshake::release_node_id() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.node_id)
  return _impl_.node_id_.Release();
}
inline void Handshake::set_allocated_node_id(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_id_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.node_id_.IsDefault()) {
    _impl_.node_id_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.node_id)
}

// uint64 nonce = 13;
inline void Handshake::clear_nonce() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = ::uint64_t{0u};
}
inline ::uint64_t Handshake::nonce() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.nonce)
  return _internal_nonce();
}
inline void Handshake::set_nonce(::uint64_t value) {
  _internal_set_nonce(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.nonce)
}
inline ::uint64_t Handshake::_internal_nonce() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.nonce_;
}
inline void Handshake::_internal_set_nonce(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.nonce_ = value;
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// -------------------------------------------------------------------

// HeightRequest

// -------------------------------------------------------------------

// HeightResponse

// uint64 height = 1;
inline void HeightResponse::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t HeightResponse::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightResponse.height)
  return _internal_height();
}
inline void HeightResponse::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightResponse.height)
}
inline ::uint64_t HeightResponse::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void HeightResponse::_internal_set_height(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// uint64 total_work = 2;
inline void HeightResponse::clear_total_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_work_ = ::uint64_t{0u};
}
inline ::uint64_t HeightResponse::total_work() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightResponse.total_work)
  return _internal_total_work();
}
inline void HeightResponse::set_total_work(::uint64_t value) {
  _internal_set_total_work(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightResponse.total_work)
}
inline ::uint64_t HeightResponse::_internal_total_work() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_work_;
}
inline void HeightResponse::_internal_set_total_work(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_work_ = value;
}

// -------------------------------------------------------------------

// HeightProbe

// uint32 height = 1;
inline void HeightProbe::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = 0u;
}
inline ::uint32_t HeightProbe::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightProbe.height)
  return _internal_height();
}
inline void HeightProbe::set_height(::uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightProbe.height)
}
inline ::uint32_t HeightProbe::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void HeightProbe::_internal_set_height(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// bytes tip_hash = 2;
inline void HeightProbe::clear_tip_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tip_hash_.ClearToEmpty();
}
inline const std::string& HeightProbe::tip_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightProbe.tip_hash)
  return _internal_tip_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void HeightProbe::set_tip_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tip_hash_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightProbe.tip_hash)
}
inline std::string* HeightProbe::mutable_tip_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_tip_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.HeightProbe.tip_hash)
  return _s;
}
inline const std::string& HeightProbe::_internal_tip_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.tip_hash_.Get();
}
inline void HeightProbe::_internal_set_tip_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tip_hash_.Set(value, GetArena());
}
inline std::string* HeightProbe::_internal_mutable_tip_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.tip_hash_.Mutable( GetArena());
}
inline std::string* HeightProbe::release_tip_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.HeightProbe.tip_hash)
  return _impl_.tip_hash_.Release();
}
inline void HeightProbe::set_allocated_tip_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.tip_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.tip_hash_.IsDefault()) {
    _impl_.tip_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.HeightProbe.tip_hash)
}

// uint64 total_work = 3;
inline void HeightProbe::clear_total_work() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_work_ = ::uint64_t{0u};
}
inline ::uint64_t HeightProbe::total_work() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightProbe.total_work)
  return _internal_total_work();
}
inline void HeightProbe::set_total_work(::uint64_t value) {
  _internal_set_total_work(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightProbe.total_work)
}
inline ::uint64_t HeightProbe::_internal_total_work() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_work_;
}
inline void HeightProbe::_internal_set_total_work(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_work_ = value;
}

// -------------------------------------------------------------------

// BlockBroadcast

// .alyncoin.BlockProto block = 1;
inline bool BlockBroadcast::has_block() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_ != nullptr);
  return value;
}
inline const ::alyncoin::BlockProto& BlockBroadcast::_internal_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::alyncoin::BlockProto* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockProto&>(::alyncoin::_BlockProto_default_instance_);
}
inline const ::alyncoin::BlockProto& BlockBroadcast::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockBroadcast.block)
  return _internal_block();
}
inline void BlockBroadcast::unsafe_arena_set_allocated_block(::alyncoin::BlockProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = reinterpret_cast<::alyncoin::BlockProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockBroadcast.block)
}
inline ::alyncoin::BlockProto* BlockBroadcast::release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::BlockProto* released = _impl_.block_;
  _impl_.block_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::alyncoin::BlockProto* BlockBroadcast::unsafe_arena_release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockBroadcast.block)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::BlockProto* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockProto* BlockBroadcast::_internal_mutable_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::alyncoin::BlockProto>(GetArena());
    _impl_.block_ = reinterpret_cast<::alyncoin::BlockProto*>(p);
  }
  return _impl_.block_;
}
inline ::alyncoin::BlockProto* BlockBroadcast::mutable_block() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::alyncoin::BlockProto* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockBroadcast.block)
  return _msg;
}
inline void BlockBroadcast::set_allocated_block(::alyncoin::BlockProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.block_ = reinterpret_cast<::alyncoin::BlockProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockBroadcast.block)
}

// -------------------------------------------------------------------

// BlockBatch

// .alyncoin.BlockchainProto chain = 1;
inline bool BlockBatch::has_chain() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.chain_ != nullptr);
  return value;
}
inline const ::alyncoin::BlockchainProto& BlockBatch::_internal_chain() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::alyncoin::BlockchainProto* p = _impl_.chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockchainProto&>(::alyncoin::_BlockchainProto_default_instance_);
}
inline const ::alyncoin::BlockchainProto& BlockBatch::chain() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockBatch.chain)
  return _internal_chain();
}
inline void BlockBatch::unsafe_arena_set_allocated_chain(::alyncoin::BlockchainProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chain_);
  }
  _impl_.chain_ = reinterpret_cast<::alyncoin::BlockchainProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockBatch.chain)
}
inline ::alyncoin::BlockchainProto* BlockBatch::release_chain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::BlockchainProto* released = _impl_.chain_;
  _impl_.chain_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::alyncoin::BlockchainProto* BlockBatch::unsafe_arena_release_chain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockBatch.chain)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::BlockchainProto* temp = _impl_.chain_;
  _impl_.chain_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockchainProto* BlockBatch::_internal_mutable_chain() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.chain_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::alyncoin::BlockchainProto>(GetArena());
    _impl_.chain_ = reinterpret_cast<::alyncoin::BlockchainProto*>(p);
  }
  return _impl_.chain_;
}
inline ::alyncoin::BlockchainProto* BlockBatch::mutable_chain() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::alyncoin::BlockchainProto* _msg = _internal_mutable_chain();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockBatch.chain)
  return _msg;
}
inline void BlockBatch::set_allocated_chain(::alyncoin::BlockchainProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.chain_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.chain_ = reinterpret_cast<::alyncoin::BlockchainProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockBatch.chain)
}

// -------------------------------------------------------------------

// BlockRequest

// uint64 index = 1;
inline void BlockRequest::clear_index() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = ::uint64_t{0u};
}
inline ::uint64_t BlockRequest::index() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockRequest.index)
  return _internal_index();
}
inline void BlockRequest::set_index(::uint64_t value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.BlockRequest.index)
}
inline ::uint64_t BlockRequest::_internal_index() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.index_;
}
inline void BlockRequest::_internal_set_index(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.index_ = value;
}

// -------------------------------------------------------------------

// BlockResponse

// .alyncoin.BlockProto block = 1;
inline bool BlockResponse::has_block() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.block_ != nullptr);
  return value;
}
inline const ::alyncoin::BlockProto& BlockResponse::_internal_block() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::alyncoin::BlockProto* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockProto&>(::alyncoin::_BlockProto_default_instance_);
}
inline const ::alyncoin::BlockProto& BlockResponse::block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockResponse.block)
  return _internal_block();
}
inline void BlockResponse::unsafe_arena_set_allocated_block(::alyncoin::BlockProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = reinterpret_cast<::alyncoin::BlockProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockResponse.block)
}
inline ::alyncoin::BlockProto* BlockResponse::release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::BlockProto* released = _impl_.block_;
  _impl_.block_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::alyncoin::BlockProto* BlockResponse::unsafe_arena_release_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockResponse.block)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::BlockProto* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockProto* BlockResponse::_internal_mutable_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.block_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::alyncoin::BlockProto>(GetArena());
    _impl_.block_ = reinterpret_cast<::alyncoin::BlockProto*>(p);
  }
  return _impl_.block_;
}
inline ::alyncoin::BlockProto* BlockResponse::mutable_block() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::alyncoin::BlockProto* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockResponse.block)
  return _msg;
}
inline void BlockResponse::set_allocated_block(::alyncoin::BlockProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.block_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.block_ = reinterpret_cast<::alyncoin::BlockProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockResponse.block)
}

// -------------------------------------------------------------------

// SnapshotMeta

// uint64 height = 1;
inline void SnapshotMeta::clear_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = ::uint64_t{0u};
}
inline ::uint64_t SnapshotMeta::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotMeta.height)
  return _internal_height();
}
inline void SnapshotMeta::set_height(::uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotMeta.height)
}
inline ::uint64_t SnapshotMeta::_internal_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.height_;
}
inline void SnapshotMeta::_internal_set_height(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.height_ = value;
}

// string root_hash = 2;
inline void SnapshotMeta::clear_root_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_hash_.ClearToEmpty();
}
inline const std::string& SnapshotMeta::root_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotMeta.root_hash)
  return _internal_root_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotMeta::set_root_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotMeta.root_hash)
}
inline std::string* SnapshotMeta::mutable_root_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_root_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.SnapshotMeta.root_hash)
  return _s;
}
inline const std::string& SnapshotMeta::_internal_root_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.root_hash_.Get();
}
inline void SnapshotMeta::_internal_set_root_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_hash_.Set(value, GetArena());
}
inline std::string* SnapshotMeta::_internal_mutable_root_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.root_hash_.Mutable( GetArena());
}
inline std::string* SnapshotMeta::release_root_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.SnapshotMeta.root_hash)
  return _impl_.root_hash_.Release();
}
inline void SnapshotMeta::set_allocated_root_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.root_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.root_hash_.IsDefault()) {
    _impl_.root_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.SnapshotMeta.root_hash)
}

// uint64 total_bytes = 3;
inline void SnapshotMeta::clear_total_bytes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_ = ::uint64_t{0u};
}
inline ::uint64_t SnapshotMeta::total_bytes() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotMeta.total_bytes)
  return _internal_total_bytes();
}
inline void SnapshotMeta::set_total_bytes(::uint64_t value) {
  _internal_set_total_bytes(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotMeta.total_bytes)
}
inline ::uint64_t SnapshotMeta::_internal_total_bytes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.total_bytes_;
}
inline void SnapshotMeta::_internal_set_total_bytes(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.total_bytes_ = value;
}

// uint32 chunk_size = 4;
inline void SnapshotMeta::clear_chunk_size() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_size_ = 0u;
}
inline ::uint32_t SnapshotMeta::chunk_size() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotMeta.chunk_size)
  return _internal_chunk_size();
}
inline void SnapshotMeta::set_chunk_size(::uint32_t value) {
  _internal_set_chunk_size(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotMeta.chunk_size)
}
inline ::uint32_t SnapshotMeta::_internal_chunk_size() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.chunk_size_;
}
inline void SnapshotMeta::_internal_set_chunk_size(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.chunk_size_ = value;
}

// -------------------------------------------------------------------

// SnapshotChunk

// bytes data = 1;
inline void SnapshotChunk::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SnapshotChunk::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotChunk.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotChunk::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotChunk.data)
}
inline std::string* SnapshotChunk::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.SnapshotChunk.data)
  return _s;
}
inline const std::string& SnapshotChunk::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void SnapshotChunk::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* SnapshotChunk::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* SnapshotChunk::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.SnapshotChunk.data)
  return _impl_.data_.Release();
}
inline void SnapshotChunk::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.SnapshotChunk.data)
}

// -------------------------------------------------------------------

// SnapshotAck

// uint32 seq = 1;
inline void SnapshotAck::clear_seq() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seq_ = 0u;
}
inline ::uint32_t SnapshotAck::seq() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotAck.seq)
  return _internal_seq();
}
inline void SnapshotAck::set_seq(::uint32_t value) {
  _internal_set_seq(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotAck.seq)
}
inline ::uint32_t SnapshotAck::_internal_seq() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.seq_;
}
inline void SnapshotAck::_internal_set_seq(::uint32_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.seq_ = value;
}

// -------------------------------------------------------------------

// SnapshotEnd

// -------------------------------------------------------------------

// TailBlocks

// repeated .alyncoin.BlockProto blocks = 1;
inline int TailBlocks::_internal_blocks_size() const {
  return _internal_blocks().size();
}
inline int TailBlocks::blocks_size() const {
  return _internal_blocks_size();
}
inline ::alyncoin::BlockProto* TailBlocks::mutable_blocks(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TailBlocks.blocks)
  return _internal_mutable_blocks()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>* TailBlocks::mutable_blocks()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.TailBlocks.blocks)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_blocks();
}
inline const ::alyncoin::BlockProto& TailBlocks::blocks(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.TailBlocks.blocks)
  return _internal_blocks().Get(index);
}
inline ::alyncoin::BlockProto* TailBlocks::add_blocks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::alyncoin::BlockProto* _add = _internal_mutable_blocks()->Add();
  // @@protoc_insertion_point(field_add:alyncoin.net.TailBlocks.blocks)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>& TailBlocks::blocks() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:alyncoin.net.TailBlocks.blocks)
  return _internal_blocks();
}
inline const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>&
TailBlocks::_internal_blocks() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.blocks_;
}
inline ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>*
TailBlocks::_internal_mutable_blocks() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.blocks_;
}

// -------------------------------------------------------------------

// EpochProof

// bytes data = 1;
inline void EpochProof::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& EpochProof::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.EpochProof.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void EpochProof::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.EpochProof.data)
}
inline std::string* EpochProof::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.EpochProof.data)
  return _s;
}
inline const std::string& EpochProof::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void EpochProof::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* EpochProof::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* EpochProof::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.EpochProof.data)
  return _impl_.data_.Release();
}
inline void EpochProof::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.EpochProof.data)
}

// -------------------------------------------------------------------

// Inventory

// repeated string hashes = 1;
inline int Inventory::_internal_hashes_size() const {
  return _internal_hashes().size();
}
inline int Inventory::hashes_size() const {
  return _internal_hashes_size();
}
inline void Inventory::clear_hashes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashes_.Clear();
}
inline std::string* Inventory::add_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_hashes()->Add();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.Inventory.hashes)
  return _s;
}
inline const std::string& Inventory::hashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Inventory.hashes)
  return _internal_hashes().Get(index);
}
inline std::string* Inventory::mutable_hashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Inventory.hashes)
  return _internal_mutable_hashes()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void Inventory::set_hashes(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_hashes()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:alyncoin.net.Inventory.hashes)
}
template <typename Arg_, typename... Args_>
inline void Inventory::add_hashes(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_hashes(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:alyncoin.net.Inventory.hashes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Inventory::hashes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:alyncoin.net.Inventory.hashes)
  return _internal_hashes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Inventory::mutable_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.Inventory.hashes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hashes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
Inventory::_internal_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hashes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
Inventory::_internal_mutable_hashes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hashes_;
}

// -------------------------------------------------------------------

// TipHashRequest

// -------------------------------------------------------------------

// TipHashResponse

// string hash = 1;
inline void TipHashResponse::clear_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TipHashResponse::hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.TipHashResponse.hash)
  return _internal_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TipHashResponse::set_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.TipHashResponse.hash)
}
inline std::string* TipHashResponse::mutable_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TipHashResponse.hash)
  return _s;
}
inline const std::string& TipHashResponse::_internal_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hash_.Get();
}
inline void TipHashResponse::_internal_set_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.Set(value, GetArena());
}
inline std::string* TipHashResponse::_internal_mutable_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.hash_.Mutable( GetArena());
}
inline std::string* TipHashResponse::release_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.TipHashResponse.hash)
  return _impl_.hash_.Release();
}
inline void TipHashResponse::set_allocated_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.TipHashResponse.hash)
}

// -------------------------------------------------------------------

// PeerListRequest

// -------------------------------------------------------------------

// PeerList

// repeated string peers = 1;
inline int PeerList::_internal_peers_size() const {
  return _internal_peers().size();
}
inline int PeerList::peers_size() const {
  return _internal_peers_size();
}
inline void PeerList::clear_peers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.peers_.Clear();
}
inline std::string* PeerList::add_peers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_peers()->Add();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.PeerList.peers)
  return _s;
}
inline const std::string& PeerList::peers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.PeerList.peers)
  return _internal_peers().Get(index);
}
inline std::string* PeerList::mutable_peers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.PeerList.peers)
  return _internal_mutable_peers()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void PeerList::set_peers(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_peers()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:alyncoin.net.PeerList.peers)
}
template <typename Arg_, typename... Args_>
inline void PeerList::add_peers(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_peers(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:alyncoin.net.PeerList.peers)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PeerList::peers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:alyncoin.net.PeerList.peers)
  return _internal_peers();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PeerList::mutable_peers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.PeerList.peers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_peers();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
PeerList::_internal_peers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.peers_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
PeerList::_internal_mutable_peers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.peers_;
}

// -------------------------------------------------------------------

// RollupBlockMsg

// bytes data = 1;
inline void RollupBlockMsg::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RollupBlockMsg::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.RollupBlockMsg.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void RollupBlockMsg::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.RollupBlockMsg.data)
}
inline std::string* RollupBlockMsg::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.RollupBlockMsg.data)
  return _s;
}
inline const std::string& RollupBlockMsg::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void RollupBlockMsg::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* RollupBlockMsg::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* RollupBlockMsg::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.RollupBlockMsg.data)
  return _impl_.data_.Release();
}
inline void RollupBlockMsg::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.RollupBlockMsg.data)
}

// -------------------------------------------------------------------

// SnapshotRequest

// string until_hash = 1;
inline void SnapshotRequest::clear_until_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.until_hash_.ClearToEmpty();
}
inline const std::string& SnapshotRequest::until_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotRequest.until_hash)
  return _internal_until_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SnapshotRequest::set_until_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.until_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotRequest.until_hash)
}
inline std::string* SnapshotRequest::mutable_until_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_until_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.SnapshotRequest.until_hash)
  return _s;
}
inline const std::string& SnapshotRequest::_internal_until_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.until_hash_.Get();
}
inline void SnapshotRequest::_internal_set_until_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.until_hash_.Set(value, GetArena());
}
inline std::string* SnapshotRequest::_internal_mutable_until_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.until_hash_.Mutable( GetArena());
}
inline std::string* SnapshotRequest::release_until_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.SnapshotRequest.until_hash)
  return _impl_.until_hash_.Release();
}
inline void SnapshotRequest::set_allocated_until_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.until_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.until_hash_.IsDefault()) {
    _impl_.until_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.SnapshotRequest.until_hash)
}

// -------------------------------------------------------------------

// TailBlocksRequest

// uint64 from_height = 1;
inline void TailBlocksRequest::clear_from_height() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_height_ = ::uint64_t{0u};
}
inline ::uint64_t TailBlocksRequest::from_height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.TailBlocksRequest.from_height)
  return _internal_from_height();
}
inline void TailBlocksRequest::set_from_height(::uint64_t value) {
  _internal_set_from_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.TailBlocksRequest.from_height)
}
inline ::uint64_t TailBlocksRequest::_internal_from_height() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_height_;
}
inline void TailBlocksRequest::_internal_set_from_height(::uint64_t value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_height_ = value;
}

// string anchor_hash = 2;
inline void TailBlocksRequest::clear_anchor_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anchor_hash_.ClearToEmpty();
}
inline const std::string& TailBlocksRequest::anchor_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.TailBlocksRequest.anchor_hash)
  return _internal_anchor_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void TailBlocksRequest::set_anchor_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anchor_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.TailBlocksRequest.anchor_hash)
}
inline std::string* TailBlocksRequest::mutable_anchor_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_anchor_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TailBlocksRequest.anchor_hash)
  return _s;
}
inline const std::string& TailBlocksRequest::_internal_anchor_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.anchor_hash_.Get();
}
inline void TailBlocksRequest::_internal_set_anchor_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anchor_hash_.Set(value, GetArena());
}
inline std::string* TailBlocksRequest::_internal_mutable_anchor_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.anchor_hash_.Mutable( GetArena());
}
inline std::string* TailBlocksRequest::release_anchor_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.TailBlocksRequest.anchor_hash)
  return _impl_.anchor_hash_.Release();
}
inline void TailBlocksRequest::set_allocated_anchor_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.anchor_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.anchor_hash_.IsDefault()) {
    _impl_.anchor_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.TailBlocksRequest.anchor_hash)
}

// -------------------------------------------------------------------

// GetData

// repeated string hashes = 1;
inline int GetData::_internal_hashes_size() const {
  return _internal_hashes().size();
}
inline int GetData::hashes_size() const {
  return _internal_hashes_size();
}
inline void GetData::clear_hashes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.hashes_.Clear();
}
inline std::string* GetData::add_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  std::string* _s = _internal_mutable_hashes()->Add();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.GetData.hashes)
  return _s;
}
inline const std::string& GetData::hashes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.GetData.hashes)
  return _internal_hashes().Get(index);
}
inline std::string* GetData::mutable_hashes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.GetData.hashes)
  return _internal_mutable_hashes()->Mutable(index);
}
template <typename Arg_, typename... Args_>
inline void GetData::set_hashes(int index, Arg_&& value, Args_... args) {
  ::google::protobuf::internal::AssignToString(
      *_internal_mutable_hashes()->Mutable(index),
      std::forward<Arg_>(value), args... );
  // @@protoc_insertion_point(field_set:alyncoin.net.GetData.hashes)
}
template <typename Arg_, typename... Args_>
inline void GetData::add_hashes(Arg_&& value, Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::google::protobuf::internal::AddToRepeatedPtrField(*_internal_mutable_hashes(),
                               std::forward<Arg_>(value),
                               args... );
  // @@protoc_insertion_point(field_add:alyncoin.net.GetData.hashes)
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetData::hashes() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:alyncoin.net.GetData.hashes)
  return _internal_hashes();
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetData::mutable_hashes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.GetData.hashes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_hashes();
}
inline const ::google::protobuf::RepeatedPtrField<std::string>&
GetData::_internal_hashes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.hashes_;
}
inline ::google::protobuf::RepeatedPtrField<std::string>*
GetData::_internal_mutable_hashes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.hashes_;
}

// -------------------------------------------------------------------

// GetHeaders

// string from_hash = 1;
inline void GetHeaders::clear_from_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_hash_.ClearToEmpty();
}
inline const std::string& GetHeaders::from_hash() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.GetHeaders.from_hash)
  return _internal_from_hash();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void GetHeaders::set_from_hash(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_hash_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.GetHeaders.from_hash)
}
inline std::string* GetHeaders::mutable_from_hash() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_from_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.GetHeaders.from_hash)
  return _s;
}
inline const std::string& GetHeaders::_internal_from_hash() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.from_hash_.Get();
}
inline void GetHeaders::_internal_set_from_hash(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_hash_.Set(value, GetArena());
}
inline std::string* GetHeaders::_internal_mutable_from_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.from_hash_.Mutable( GetArena());
}
inline std::string* GetHeaders::release_from_hash() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.GetHeaders.from_hash)
  return _impl_.from_hash_.Release();
}
inline void GetHeaders::set_allocated_from_hash(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.from_hash_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.from_hash_.IsDefault()) {
    _impl_.from_hash_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.GetHeaders.from_hash)
}

// -------------------------------------------------------------------

// Headers

// repeated .alyncoin.BlockProto headers = 1;
inline int Headers::_internal_headers_size() const {
  return _internal_headers().size();
}
inline int Headers::headers_size() const {
  return _internal_headers_size();
}
inline ::alyncoin::BlockProto* Headers::mutable_headers(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Headers.headers)
  return _internal_mutable_headers()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>* Headers::mutable_headers()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.Headers.headers)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_headers();
}
inline const ::alyncoin::BlockProto& Headers::headers(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Headers.headers)
  return _internal_headers().Get(index);
}
inline ::alyncoin::BlockProto* Headers::add_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::alyncoin::BlockProto* _add = _internal_mutable_headers()->Add();
  // @@protoc_insertion_point(field_add:alyncoin.net.Headers.headers)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>& Headers::headers() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:alyncoin.net.Headers.headers)
  return _internal_headers();
}
inline const ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>&
Headers::_internal_headers() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.headers_;
}
inline ::google::protobuf::RepeatedPtrField<::alyncoin::BlockProto>*
Headers::_internal_mutable_headers() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.headers_;
}

// -------------------------------------------------------------------

// StateProof

// .alyncoin.StateProofProto proof = 1;
inline bool StateProof::has_proof() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.proof_ != nullptr);
  return value;
}
inline const ::alyncoin::StateProofProto& StateProof::_internal_proof() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::alyncoin::StateProofProto* p = _impl_.proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::StateProofProto&>(::alyncoin::_StateProofProto_default_instance_);
}
inline const ::alyncoin::StateProofProto& StateProof::proof() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.StateProof.proof)
  return _internal_proof();
}
inline void StateProof::unsafe_arena_set_allocated_proof(::alyncoin::StateProofProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proof_);
  }
  _impl_.proof_ = reinterpret_cast<::alyncoin::StateProofProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.StateProof.proof)
}
inline ::alyncoin::StateProofProto* StateProof::release_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::StateProofProto* released = _impl_.proof_;
  _impl_.proof_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::alyncoin::StateProofProto* StateProof::unsafe_arena_release_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.StateProof.proof)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::StateProofProto* temp = _impl_.proof_;
  _impl_.proof_ = nullptr;
  return temp;
}
inline ::alyncoin::StateProofProto* StateProof::_internal_mutable_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.proof_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::alyncoin::StateProofProto>(GetArena());
    _impl_.proof_ = reinterpret_cast<::alyncoin::StateProofProto*>(p);
  }
  return _impl_.proof_;
}
inline ::alyncoin::StateProofProto* StateProof::mutable_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::alyncoin::StateProofProto* _msg = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.StateProof.proof)
  return _msg;
}
inline void StateProof::set_allocated_proof(::alyncoin::StateProofProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.proof_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.proof_ = reinterpret_cast<::alyncoin::StateProofProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.StateProof.proof)
}

// -------------------------------------------------------------------

// TransactionBroadcast

// .alyncoin.TransactionProto tx = 1;
inline bool TransactionBroadcast::has_tx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.tx_ != nullptr);
  return value;
}
inline const ::alyncoin::TransactionProto& TransactionBroadcast::_internal_tx() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::alyncoin::TransactionProto* p = _impl_.tx_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::TransactionProto&>(::alyncoin::_TransactionProto_default_instance_);
}
inline const ::alyncoin::TransactionProto& TransactionBroadcast::tx() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.TransactionBroadcast.tx)
  return _internal_tx();
}
inline void TransactionBroadcast::unsafe_arena_set_allocated_tx(::alyncoin::TransactionProto* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tx_);
  }
  _impl_.tx_ = reinterpret_cast<::alyncoin::TransactionProto*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.TransactionBroadcast.tx)
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::release_tx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::TransactionProto* released = _impl_.tx_;
  _impl_.tx_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::unsafe_arena_release_tx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.TransactionBroadcast.tx)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::alyncoin::TransactionProto* temp = _impl_.tx_;
  _impl_.tx_ = nullptr;
  return temp;
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::_internal_mutable_tx() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.tx_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::alyncoin::TransactionProto>(GetArena());
    _impl_.tx_ = reinterpret_cast<::alyncoin::TransactionProto*>(p);
  }
  return _impl_.tx_;
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::mutable_tx() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::alyncoin::TransactionProto* _msg = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TransactionBroadcast.tx)
  return _msg;
}
inline void TransactionBroadcast::set_allocated_tx(::alyncoin::TransactionProto* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.tx_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.tx_ = reinterpret_cast<::alyncoin::TransactionProto*>(value);
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.TransactionBroadcast.tx)
}

// -------------------------------------------------------------------

// Whisper

// bytes data = 1;
inline void Whisper::clear_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.ClearToEmpty();
}
inline const std::string& Whisper::data() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Whisper.data)
  return _internal_data();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Whisper::set_data(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetBytes(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:alyncoin.net.Whisper.data)
}
inline std::string* Whisper::mutable_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Whisper.data)
  return _s;
}
inline const std::string& Whisper::_internal_data() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.data_.Get();
}
inline void Whisper::_internal_set_data(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.Set(value, GetArena());
}
inline std::string* Whisper::_internal_mutable_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.data_.Mutable( GetArena());
}
inline std::string* Whisper::release_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:alyncoin.net.Whisper.data)
  return _impl_.data_.Release();
}
inline void Whisper::set_allocated_data(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.data_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Whisper.data)
}

// -------------------------------------------------------------------

// Frame

// .alyncoin.net.Handshake handshake = 1;
inline bool Frame::has_handshake() const {
  return kind_case() == kHandshake;
}
inline bool Frame::_internal_has_handshake() const {
  return kind_case() == kHandshake;
}
inline void Frame::set_has_handshake() {
  _impl_._oneof_case_[0] = kHandshake;
}
inline void Frame::clear_handshake() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kHandshake) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.handshake_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.handshake_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Handshake* Frame::release_handshake() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.handshake)
  if (kind_case() == kHandshake) {
    clear_has_kind();
    auto* temp = _impl_.kind_.handshake_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Handshake& Frame::_internal_handshake() const {
  return kind_case() == kHandshake ? *_impl_.kind_.handshake_ : reinterpret_cast<::alyncoin::net::Handshake&>(::alyncoin::net::_Handshake_default_instance_);
}
inline const ::alyncoin::net::Handshake& Frame::handshake() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.handshake)
  return _internal_handshake();
}
inline ::alyncoin::net::Handshake* Frame::unsafe_arena_release_handshake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.handshake)
  if (kind_case() == kHandshake) {
    clear_has_kind();
    auto* temp = _impl_.kind_.handshake_;
    _impl_.kind_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_handshake(::alyncoin::net::Handshake* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_handshake();
    _impl_.kind_.handshake_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.handshake)
}
inline ::alyncoin::net::Handshake* Frame::_internal_mutable_handshake() {
  if (kind_case() != kHandshake) {
    clear_kind();
    set_has_handshake();
    _impl_.kind_.handshake_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::Handshake>(GetArena());
  }
  return _impl_.kind_.handshake_;
}
inline ::alyncoin::net::Handshake* Frame::mutable_handshake() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::Handshake* _msg = _internal_mutable_handshake();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.handshake)
  return _msg;
}

// .alyncoin.net.Ping ping = 2;
inline bool Frame::has_ping() const {
  return kind_case() == kPing;
}
inline bool Frame::_internal_has_ping() const {
  return kind_case() == kPing;
}
inline void Frame::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void Frame::clear_ping() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPing) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.ping_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.ping_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Ping* Frame::release_ping() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.ping)
  if (kind_case() == kPing) {
    clear_has_kind();
    auto* temp = _impl_.kind_.ping_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Ping& Frame::_internal_ping() const {
  return kind_case() == kPing ? *_impl_.kind_.ping_ : reinterpret_cast<::alyncoin::net::Ping&>(::alyncoin::net::_Ping_default_instance_);
}
inline const ::alyncoin::net::Ping& Frame::ping() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.ping)
  return _internal_ping();
}
inline ::alyncoin::net::Ping* Frame::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.ping)
  if (kind_case() == kPing) {
    clear_has_kind();
    auto* temp = _impl_.kind_.ping_;
    _impl_.kind_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_ping(::alyncoin::net::Ping* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_ping();
    _impl_.kind_.ping_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.ping)
}
inline ::alyncoin::net::Ping* Frame::_internal_mutable_ping() {
  if (kind_case() != kPing) {
    clear_kind();
    set_has_ping();
    _impl_.kind_.ping_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::Ping>(GetArena());
  }
  return _impl_.kind_.ping_;
}
inline ::alyncoin::net::Ping* Frame::mutable_ping() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.ping)
  return _msg;
}

// .alyncoin.net.Pong pong = 3;
inline bool Frame::has_pong() const {
  return kind_case() == kPong;
}
inline bool Frame::_internal_has_pong() const {
  return kind_case() == kPong;
}
inline void Frame::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void Frame::clear_pong() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPong) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.pong_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.pong_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Pong* Frame::release_pong() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.pong)
  if (kind_case() == kPong) {
    clear_has_kind();
    auto* temp = _impl_.kind_.pong_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Pong& Frame::_internal_pong() const {
  return kind_case() == kPong ? *_impl_.kind_.pong_ : reinterpret_cast<::alyncoin::net::Pong&>(::alyncoin::net::_Pong_default_instance_);
}
inline const ::alyncoin::net::Pong& Frame::pong() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.pong)
  return _internal_pong();
}
inline ::alyncoin::net::Pong* Frame::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.pong)
  if (kind_case() == kPong) {
    clear_has_kind();
    auto* temp = _impl_.kind_.pong_;
    _impl_.kind_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_pong(::alyncoin::net::Pong* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_pong();
    _impl_.kind_.pong_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.pong)
}
inline ::alyncoin::net::Pong* Frame::_internal_mutable_pong() {
  if (kind_case() != kPong) {
    clear_kind();
    set_has_pong();
    _impl_.kind_.pong_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::Pong>(GetArena());
  }
  return _impl_.kind_.pong_;
}
inline ::alyncoin::net::Pong* Frame::mutable_pong() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::Pong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.pong)
  return _msg;
}

// .alyncoin.net.HeightRequest height_req = 4;
inline bool Frame::has_height_req() const {
  return kind_case() == kHeightReq;
}
inline bool Frame::_internal_has_height_req() const {
  return kind_case() == kHeightReq;
}
inline void Frame::set_has_height_req() {
  _impl_._oneof_case_[0] = kHeightReq;
}
inline void Frame::clear_height_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kHeightReq) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.height_req_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.height_req_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightRequest* Frame::release_height_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_req)
  if (kind_case() == kHeightReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.height_req_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightRequest& Frame::_internal_height_req() const {
  return kind_case() == kHeightReq ? *_impl_.kind_.height_req_ : reinterpret_cast<::alyncoin::net::HeightRequest&>(::alyncoin::net::_HeightRequest_default_instance_);
}
inline const ::alyncoin::net::HeightRequest& Frame::height_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_req)
  return _internal_height_req();
}
inline ::alyncoin::net::HeightRequest* Frame::unsafe_arena_release_height_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_req)
  if (kind_case() == kHeightReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.height_req_;
    _impl_.kind_.height_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_req(::alyncoin::net::HeightRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_height_req();
    _impl_.kind_.height_req_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_req)
}
inline ::alyncoin::net::HeightRequest* Frame::_internal_mutable_height_req() {
  if (kind_case() != kHeightReq) {
    clear_kind();
    set_has_height_req();
    _impl_.kind_.height_req_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::HeightRequest>(GetArena());
  }
  return _impl_.kind_.height_req_;
}
inline ::alyncoin::net::HeightRequest* Frame::mutable_height_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::HeightRequest* _msg = _internal_mutable_height_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_req)
  return _msg;
}

// .alyncoin.net.HeightResponse height_res = 5;
inline bool Frame::has_height_res() const {
  return kind_case() == kHeightRes;
}
inline bool Frame::_internal_has_height_res() const {
  return kind_case() == kHeightRes;
}
inline void Frame::set_has_height_res() {
  _impl_._oneof_case_[0] = kHeightRes;
}
inline void Frame::clear_height_res() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kHeightRes) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.height_res_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.height_res_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightResponse* Frame::release_height_res() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_res)
  if (kind_case() == kHeightRes) {
    clear_has_kind();
    auto* temp = _impl_.kind_.height_res_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightResponse& Frame::_internal_height_res() const {
  return kind_case() == kHeightRes ? *_impl_.kind_.height_res_ : reinterpret_cast<::alyncoin::net::HeightResponse&>(::alyncoin::net::_HeightResponse_default_instance_);
}
inline const ::alyncoin::net::HeightResponse& Frame::height_res() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_res)
  return _internal_height_res();
}
inline ::alyncoin::net::HeightResponse* Frame::unsafe_arena_release_height_res() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_res)
  if (kind_case() == kHeightRes) {
    clear_has_kind();
    auto* temp = _impl_.kind_.height_res_;
    _impl_.kind_.height_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_res(::alyncoin::net::HeightResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_height_res();
    _impl_.kind_.height_res_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_res)
}
inline ::alyncoin::net::HeightResponse* Frame::_internal_mutable_height_res() {
  if (kind_case() != kHeightRes) {
    clear_kind();
    set_has_height_res();
    _impl_.kind_.height_res_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::HeightResponse>(GetArena());
  }
  return _impl_.kind_.height_res_;
}
inline ::alyncoin::net::HeightResponse* Frame::mutable_height_res() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::HeightResponse* _msg = _internal_mutable_height_res();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_res)
  return _msg;
}

// .alyncoin.net.HeightProbe height_probe = 31;
inline bool Frame::has_height_probe() const {
  return kind_case() == kHeightProbe;
}
inline bool Frame::_internal_has_height_probe() const {
  return kind_case() == kHeightProbe;
}
inline void Frame::set_has_height_probe() {
  _impl_._oneof_case_[0] = kHeightProbe;
}
inline void Frame::clear_height_probe() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kHeightProbe) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.height_probe_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.height_probe_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightProbe* Frame::release_height_probe() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_probe)
  if (kind_case() == kHeightProbe) {
    clear_has_kind();
    auto* temp = _impl_.kind_.height_probe_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_probe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightProbe& Frame::_internal_height_probe() const {
  return kind_case() == kHeightProbe ? *_impl_.kind_.height_probe_ : reinterpret_cast<::alyncoin::net::HeightProbe&>(::alyncoin::net::_HeightProbe_default_instance_);
}
inline const ::alyncoin::net::HeightProbe& Frame::height_probe() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_probe)
  return _internal_height_probe();
}
inline ::alyncoin::net::HeightProbe* Frame::unsafe_arena_release_height_probe() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_probe)
  if (kind_case() == kHeightProbe) {
    clear_has_kind();
    auto* temp = _impl_.kind_.height_probe_;
    _impl_.kind_.height_probe_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_probe(::alyncoin::net::HeightProbe* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_height_probe();
    _impl_.kind_.height_probe_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_probe)
}
inline ::alyncoin::net::HeightProbe* Frame::_internal_mutable_height_probe() {
  if (kind_case() != kHeightProbe) {
    clear_kind();
    set_has_height_probe();
    _impl_.kind_.height_probe_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::HeightProbe>(GetArena());
  }
  return _impl_.kind_.height_probe_;
}
inline ::alyncoin::net::HeightProbe* Frame::mutable_height_probe() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::HeightProbe* _msg = _internal_mutable_height_probe();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_probe)
  return _msg;
}

// .alyncoin.net.BlockBroadcast block_broadcast = 6;
inline bool Frame::has_block_broadcast() const {
  return kind_case() == kBlockBroadcast;
}
inline bool Frame::_internal_has_block_broadcast() const {
  return kind_case() == kBlockBroadcast;
}
inline void Frame::set_has_block_broadcast() {
  _impl_._oneof_case_[0] = kBlockBroadcast;
}
inline void Frame::clear_block_broadcast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBlockBroadcast) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.block_broadcast_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.block_broadcast_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockBroadcast* Frame::release_block_broadcast() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_broadcast)
  if (kind_case() == kBlockBroadcast) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_broadcast_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockBroadcast& Frame::_internal_block_broadcast() const {
  return kind_case() == kBlockBroadcast ? *_impl_.kind_.block_broadcast_ : reinterpret_cast<::alyncoin::net::BlockBroadcast&>(::alyncoin::net::_BlockBroadcast_default_instance_);
}
inline const ::alyncoin::net::BlockBroadcast& Frame::block_broadcast() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_broadcast)
  return _internal_block_broadcast();
}
inline ::alyncoin::net::BlockBroadcast* Frame::unsafe_arena_release_block_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_broadcast)
  if (kind_case() == kBlockBroadcast) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_broadcast_;
    _impl_.kind_.block_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_broadcast)
}
inline ::alyncoin::net::BlockBroadcast* Frame::_internal_mutable_block_broadcast() {
  if (kind_case() != kBlockBroadcast) {
    clear_kind();
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::BlockBroadcast>(GetArena());
  }
  return _impl_.kind_.block_broadcast_;
}
inline ::alyncoin::net::BlockBroadcast* Frame::mutable_block_broadcast() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::BlockBroadcast* _msg = _internal_mutable_block_broadcast();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_broadcast)
  return _msg;
}

// .alyncoin.net.BlockBatch block_batch = 7;
inline bool Frame::has_block_batch() const {
  return kind_case() == kBlockBatch;
}
inline bool Frame::_internal_has_block_batch() const {
  return kind_case() == kBlockBatch;
}
inline void Frame::set_has_block_batch() {
  _impl_._oneof_case_[0] = kBlockBatch;
}
inline void Frame::clear_block_batch() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBlockBatch) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.block_batch_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.block_batch_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockBatch* Frame::release_block_batch() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_batch)
  if (kind_case() == kBlockBatch) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_batch_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockBatch& Frame::_internal_block_batch() const {
  return kind_case() == kBlockBatch ? *_impl_.kind_.block_batch_ : reinterpret_cast<::alyncoin::net::BlockBatch&>(::alyncoin::net::_BlockBatch_default_instance_);
}
inline const ::alyncoin::net::BlockBatch& Frame::block_batch() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_batch)
  return _internal_block_batch();
}
inline ::alyncoin::net::BlockBatch* Frame::unsafe_arena_release_block_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_batch)
  if (kind_case() == kBlockBatch) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_batch_;
    _impl_.kind_.block_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_batch(::alyncoin::net::BlockBatch* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_block_batch();
    _impl_.kind_.block_batch_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_batch)
}
inline ::alyncoin::net::BlockBatch* Frame::_internal_mutable_block_batch() {
  if (kind_case() != kBlockBatch) {
    clear_kind();
    set_has_block_batch();
    _impl_.kind_.block_batch_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::BlockBatch>(GetArena());
  }
  return _impl_.kind_.block_batch_;
}
inline ::alyncoin::net::BlockBatch* Frame::mutable_block_batch() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::BlockBatch* _msg = _internal_mutable_block_batch();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_batch)
  return _msg;
}

// .alyncoin.net.BlockRequest block_request = 29;
inline bool Frame::has_block_request() const {
  return kind_case() == kBlockRequest;
}
inline bool Frame::_internal_has_block_request() const {
  return kind_case() == kBlockRequest;
}
inline void Frame::set_has_block_request() {
  _impl_._oneof_case_[0] = kBlockRequest;
}
inline void Frame::clear_block_request() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBlockRequest) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.block_request_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.block_request_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockRequest* Frame::release_block_request() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_request)
  if (kind_case() == kBlockRequest) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockRequest& Frame::_internal_block_request() const {
  return kind_case() == kBlockRequest ? *_impl_.kind_.block_request_ : reinterpret_cast<::alyncoin::net::BlockRequest&>(::alyncoin::net::_BlockRequest_default_instance_);
}
inline const ::alyncoin::net::BlockRequest& Frame::block_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_request)
  return _internal_block_request();
}
inline ::alyncoin::net::BlockRequest* Frame::unsafe_arena_release_block_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_request)
  if (kind_case() == kBlockRequest) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_request_;
    _impl_.kind_.block_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_request(::alyncoin::net::BlockRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_block_request();
    _impl_.kind_.block_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_request)
}
inline ::alyncoin::net::BlockRequest* Frame::_internal_mutable_block_request() {
  if (kind_case() != kBlockRequest) {
    clear_kind();
    set_has_block_request();
    _impl_.kind_.block_request_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::BlockRequest>(GetArena());
  }
  return _impl_.kind_.block_request_;
}
inline ::alyncoin::net::BlockRequest* Frame::mutable_block_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::BlockRequest* _msg = _internal_mutable_block_request();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_request)
  return _msg;
}

// .alyncoin.net.BlockResponse block_response = 30;
inline bool Frame::has_block_response() const {
  return kind_case() == kBlockResponse;
}
inline bool Frame::_internal_has_block_response() const {
  return kind_case() == kBlockResponse;
}
inline void Frame::set_has_block_response() {
  _impl_._oneof_case_[0] = kBlockResponse;
}
inline void Frame::clear_block_response() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kBlockResponse) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.block_response_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.block_response_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockResponse* Frame::release_block_response() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_response)
  if (kind_case() == kBlockResponse) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_response_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockResponse& Frame::_internal_block_response() const {
  return kind_case() == kBlockResponse ? *_impl_.kind_.block_response_ : reinterpret_cast<::alyncoin::net::BlockResponse&>(::alyncoin::net::_BlockResponse_default_instance_);
}
inline const ::alyncoin::net::BlockResponse& Frame::block_response() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_response)
  return _internal_block_response();
}
inline ::alyncoin::net::BlockResponse* Frame::unsafe_arena_release_block_response() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_response)
  if (kind_case() == kBlockResponse) {
    clear_has_kind();
    auto* temp = _impl_.kind_.block_response_;
    _impl_.kind_.block_response_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_response(::alyncoin::net::BlockResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_block_response();
    _impl_.kind_.block_response_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_response)
}
inline ::alyncoin::net::BlockResponse* Frame::_internal_mutable_block_response() {
  if (kind_case() != kBlockResponse) {
    clear_kind();
    set_has_block_response();
    _impl_.kind_.block_response_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::BlockResponse>(GetArena());
  }
  return _impl_.kind_.block_response_;
}
inline ::alyncoin::net::BlockResponse* Frame::mutable_block_response() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::BlockResponse* _msg = _internal_mutable_block_response();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_response)
  return _msg;
}

// .alyncoin.net.SnapshotMeta snapshot_meta = 8;
inline bool Frame::has_snapshot_meta() const {
  return kind_case() == kSnapshotMeta;
}
inline bool Frame::_internal_has_snapshot_meta() const {
  return kind_case() == kSnapshotMeta;
}
inline void Frame::set_has_snapshot_meta() {
  _impl_._oneof_case_[0] = kSnapshotMeta;
}
inline void Frame::clear_snapshot_meta() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSnapshotMeta) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.snapshot_meta_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.snapshot_meta_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotMeta* Frame::release_snapshot_meta() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_meta)
  if (kind_case() == kSnapshotMeta) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_meta_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotMeta& Frame::_internal_snapshot_meta() const {
  return kind_case() == kSnapshotMeta ? *_impl_.kind_.snapshot_meta_ : reinterpret_cast<::alyncoin::net::SnapshotMeta&>(::alyncoin::net::_SnapshotMeta_default_instance_);
}
inline const ::alyncoin::net::SnapshotMeta& Frame::snapshot_meta() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_meta)
  return _internal_snapshot_meta();
}
inline ::alyncoin::net::SnapshotMeta* Frame::unsafe_arena_release_snapshot_meta() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_meta)
  if (kind_case() == kSnapshotMeta) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_meta_;
    _impl_.kind_.snapshot_meta_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_meta(::alyncoin::net::SnapshotMeta* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_snapshot_meta();
    _impl_.kind_.snapshot_meta_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_meta)
}
inline ::alyncoin::net::SnapshotMeta* Frame::_internal_mutable_snapshot_meta() {
  if (kind_case() != kSnapshotMeta) {
    clear_kind();
    set_has_snapshot_meta();
    _impl_.kind_.snapshot_meta_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::SnapshotMeta>(GetArena());
  }
  return _impl_.kind_.snapshot_meta_;
}
inline ::alyncoin::net::SnapshotMeta* Frame::mutable_snapshot_meta() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::SnapshotMeta* _msg = _internal_mutable_snapshot_meta();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_meta)
  return _msg;
}

// .alyncoin.net.SnapshotChunk snapshot_chunk = 9;
inline bool Frame::has_snapshot_chunk() const {
  return kind_case() == kSnapshotChunk;
}
inline bool Frame::_internal_has_snapshot_chunk() const {
  return kind_case() == kSnapshotChunk;
}
inline void Frame::set_has_snapshot_chunk() {
  _impl_._oneof_case_[0] = kSnapshotChunk;
}
inline void Frame::clear_snapshot_chunk() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSnapshotChunk) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.snapshot_chunk_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.snapshot_chunk_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotChunk* Frame::release_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_chunk)
  if (kind_case() == kSnapshotChunk) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_chunk_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotChunk& Frame::_internal_snapshot_chunk() const {
  return kind_case() == kSnapshotChunk ? *_impl_.kind_.snapshot_chunk_ : reinterpret_cast<::alyncoin::net::SnapshotChunk&>(::alyncoin::net::_SnapshotChunk_default_instance_);
}
inline const ::alyncoin::net::SnapshotChunk& Frame::snapshot_chunk() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_chunk)
  return _internal_snapshot_chunk();
}
inline ::alyncoin::net::SnapshotChunk* Frame::unsafe_arena_release_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_chunk)
  if (kind_case() == kSnapshotChunk) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_chunk_;
    _impl_.kind_.snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_chunk)
}
inline ::alyncoin::net::SnapshotChunk* Frame::_internal_mutable_snapshot_chunk() {
  if (kind_case() != kSnapshotChunk) {
    clear_kind();
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::SnapshotChunk>(GetArena());
  }
  return _impl_.kind_.snapshot_chunk_;
}
inline ::alyncoin::net::SnapshotChunk* Frame::mutable_snapshot_chunk() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::SnapshotChunk* _msg = _internal_mutable_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_chunk)
  return _msg;
}

// .alyncoin.net.SnapshotAck snapshot_ack = 10;
inline bool Frame::has_snapshot_ack() const {
  return kind_case() == kSnapshotAck;
}
inline bool Frame::_internal_has_snapshot_ack() const {
  return kind_case() == kSnapshotAck;
}
inline void Frame::set_has_snapshot_ack() {
  _impl_._oneof_case_[0] = kSnapshotAck;
}
inline void Frame::clear_snapshot_ack() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSnapshotAck) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.snapshot_ack_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.snapshot_ack_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotAck* Frame::release_snapshot_ack() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_ack)
  if (kind_case() == kSnapshotAck) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_ack_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotAck& Frame::_internal_snapshot_ack() const {
  return kind_case() == kSnapshotAck ? *_impl_.kind_.snapshot_ack_ : reinterpret_cast<::alyncoin::net::SnapshotAck&>(::alyncoin::net::_SnapshotAck_default_instance_);
}
inline const ::alyncoin::net::SnapshotAck& Frame::snapshot_ack() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_ack)
  return _internal_snapshot_ack();
}
inline ::alyncoin::net::SnapshotAck* Frame::unsafe_arena_release_snapshot_ack() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_ack)
  if (kind_case() == kSnapshotAck) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_ack_;
    _impl_.kind_.snapshot_ack_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_ack(::alyncoin::net::SnapshotAck* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_snapshot_ack();
    _impl_.kind_.snapshot_ack_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_ack)
}
inline ::alyncoin::net::SnapshotAck* Frame::_internal_mutable_snapshot_ack() {
  if (kind_case() != kSnapshotAck) {
    clear_kind();
    set_has_snapshot_ack();
    _impl_.kind_.snapshot_ack_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::SnapshotAck>(GetArena());
  }
  return _impl_.kind_.snapshot_ack_;
}
inline ::alyncoin::net::SnapshotAck* Frame::mutable_snapshot_ack() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::SnapshotAck* _msg = _internal_mutable_snapshot_ack();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_ack)
  return _msg;
}

// .alyncoin.net.SnapshotEnd snapshot_end = 11;
inline bool Frame::has_snapshot_end() const {
  return kind_case() == kSnapshotEnd;
}
inline bool Frame::_internal_has_snapshot_end() const {
  return kind_case() == kSnapshotEnd;
}
inline void Frame::set_has_snapshot_end() {
  _impl_._oneof_case_[0] = kSnapshotEnd;
}
inline void Frame::clear_snapshot_end() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSnapshotEnd) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.snapshot_end_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.snapshot_end_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotEnd* Frame::release_snapshot_end() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_end)
  if (kind_case() == kSnapshotEnd) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_end_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotEnd& Frame::_internal_snapshot_end() const {
  return kind_case() == kSnapshotEnd ? *_impl_.kind_.snapshot_end_ : reinterpret_cast<::alyncoin::net::SnapshotEnd&>(::alyncoin::net::_SnapshotEnd_default_instance_);
}
inline const ::alyncoin::net::SnapshotEnd& Frame::snapshot_end() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_end)
  return _internal_snapshot_end();
}
inline ::alyncoin::net::SnapshotEnd* Frame::unsafe_arena_release_snapshot_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_end)
  if (kind_case() == kSnapshotEnd) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_end_;
    _impl_.kind_.snapshot_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_end)
}
inline ::alyncoin::net::SnapshotEnd* Frame::_internal_mutable_snapshot_end() {
  if (kind_case() != kSnapshotEnd) {
    clear_kind();
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::SnapshotEnd>(GetArena());
  }
  return _impl_.kind_.snapshot_end_;
}
inline ::alyncoin::net::SnapshotEnd* Frame::mutable_snapshot_end() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::SnapshotEnd* _msg = _internal_mutable_snapshot_end();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_end)
  return _msg;
}

// .alyncoin.net.TailBlocks tail_blocks = 12;
inline bool Frame::has_tail_blocks() const {
  return kind_case() == kTailBlocks;
}
inline bool Frame::_internal_has_tail_blocks() const {
  return kind_case() == kTailBlocks;
}
inline void Frame::set_has_tail_blocks() {
  _impl_._oneof_case_[0] = kTailBlocks;
}
inline void Frame::clear_tail_blocks() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTailBlocks) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tail_blocks_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tail_blocks_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TailBlocks* Frame::release_tail_blocks() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tail_blocks)
  if (kind_case() == kTailBlocks) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tail_blocks_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tail_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TailBlocks& Frame::_internal_tail_blocks() const {
  return kind_case() == kTailBlocks ? *_impl_.kind_.tail_blocks_ : reinterpret_cast<::alyncoin::net::TailBlocks&>(::alyncoin::net::_TailBlocks_default_instance_);
}
inline const ::alyncoin::net::TailBlocks& Frame::tail_blocks() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tail_blocks)
  return _internal_tail_blocks();
}
inline ::alyncoin::net::TailBlocks* Frame::unsafe_arena_release_tail_blocks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tail_blocks)
  if (kind_case() == kTailBlocks) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tail_blocks_;
    _impl_.kind_.tail_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tail_blocks(::alyncoin::net::TailBlocks* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tail_blocks)
}
inline ::alyncoin::net::TailBlocks* Frame::_internal_mutable_tail_blocks() {
  if (kind_case() != kTailBlocks) {
    clear_kind();
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::TailBlocks>(GetArena());
  }
  return _impl_.kind_.tail_blocks_;
}
inline ::alyncoin::net::TailBlocks* Frame::mutable_tail_blocks() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::TailBlocks* _msg = _internal_mutable_tail_blocks();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tail_blocks)
  return _msg;
}

// .alyncoin.net.EpochProof agg_proof = 13;
inline bool Frame::has_agg_proof() const {
  return kind_case() == kAggProof;
}
inline bool Frame::_internal_has_agg_proof() const {
  return kind_case() == kAggProof;
}
inline void Frame::set_has_agg_proof() {
  _impl_._oneof_case_[0] = kAggProof;
}
inline void Frame::clear_agg_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kAggProof) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.agg_proof_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.agg_proof_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::EpochProof* Frame::release_agg_proof() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.agg_proof)
  if (kind_case() == kAggProof) {
    clear_has_kind();
    auto* temp = _impl_.kind_.agg_proof_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.agg_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::EpochProof& Frame::_internal_agg_proof() const {
  return kind_case() == kAggProof ? *_impl_.kind_.agg_proof_ : reinterpret_cast<::alyncoin::net::EpochProof&>(::alyncoin::net::_EpochProof_default_instance_);
}
inline const ::alyncoin::net::EpochProof& Frame::agg_proof() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.agg_proof)
  return _internal_agg_proof();
}
inline ::alyncoin::net::EpochProof* Frame::unsafe_arena_release_agg_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.agg_proof)
  if (kind_case() == kAggProof) {
    clear_has_kind();
    auto* temp = _impl_.kind_.agg_proof_;
    _impl_.kind_.agg_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_agg_proof(::alyncoin::net::EpochProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.agg_proof)
}
inline ::alyncoin::net::EpochProof* Frame::_internal_mutable_agg_proof() {
  if (kind_case() != kAggProof) {
    clear_kind();
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::EpochProof>(GetArena());
  }
  return _impl_.kind_.agg_proof_;
}
inline ::alyncoin::net::EpochProof* Frame::mutable_agg_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::EpochProof* _msg = _internal_mutable_agg_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.agg_proof)
  return _msg;
}

// .alyncoin.net.Inventory inv = 14;
inline bool Frame::has_inv() const {
  return kind_case() == kInv;
}
inline bool Frame::_internal_has_inv() const {
  return kind_case() == kInv;
}
inline void Frame::set_has_inv() {
  _impl_._oneof_case_[0] = kInv;
}
inline void Frame::clear_inv() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kInv) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.inv_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.inv_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Inventory* Frame::release_inv() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.inv)
  if (kind_case() == kInv) {
    clear_has_kind();
    auto* temp = _impl_.kind_.inv_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.inv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Inventory& Frame::_internal_inv() const {
  return kind_case() == kInv ? *_impl_.kind_.inv_ : reinterpret_cast<::alyncoin::net::Inventory&>(::alyncoin::net::_Inventory_default_instance_);
}
inline const ::alyncoin::net::Inventory& Frame::inv() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.inv)
  return _internal_inv();
}
inline ::alyncoin::net::Inventory* Frame::unsafe_arena_release_inv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.inv)
  if (kind_case() == kInv) {
    clear_has_kind();
    auto* temp = _impl_.kind_.inv_;
    _impl_.kind_.inv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_inv(::alyncoin::net::Inventory* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_inv();
    _impl_.kind_.inv_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.inv)
}
inline ::alyncoin::net::Inventory* Frame::_internal_mutable_inv() {
  if (kind_case() != kInv) {
    clear_kind();
    set_has_inv();
    _impl_.kind_.inv_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::Inventory>(GetArena());
  }
  return _impl_.kind_.inv_;
}
inline ::alyncoin::net::Inventory* Frame::mutable_inv() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::Inventory* _msg = _internal_mutable_inv();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.inv)
  return _msg;
}

// .alyncoin.net.TipHashRequest tip_hash_req = 15;
inline bool Frame::has_tip_hash_req() const {
  return kind_case() == kTipHashReq;
}
inline bool Frame::_internal_has_tip_hash_req() const {
  return kind_case() == kTipHashReq;
}
inline void Frame::set_has_tip_hash_req() {
  _impl_._oneof_case_[0] = kTipHashReq;
}
inline void Frame::clear_tip_hash_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTipHashReq) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tip_hash_req_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tip_hash_req_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TipHashRequest* Frame::release_tip_hash_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tip_hash_req)
  if (kind_case() == kTipHashReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tip_hash_req_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tip_hash_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TipHashRequest& Frame::_internal_tip_hash_req() const {
  return kind_case() == kTipHashReq ? *_impl_.kind_.tip_hash_req_ : reinterpret_cast<::alyncoin::net::TipHashRequest&>(::alyncoin::net::_TipHashRequest_default_instance_);
}
inline const ::alyncoin::net::TipHashRequest& Frame::tip_hash_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tip_hash_req)
  return _internal_tip_hash_req();
}
inline ::alyncoin::net::TipHashRequest* Frame::unsafe_arena_release_tip_hash_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tip_hash_req)
  if (kind_case() == kTipHashReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tip_hash_req_;
    _impl_.kind_.tip_hash_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tip_hash_req(::alyncoin::net::TipHashRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tip_hash_req();
    _impl_.kind_.tip_hash_req_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tip_hash_req)
}
inline ::alyncoin::net::TipHashRequest* Frame::_internal_mutable_tip_hash_req() {
  if (kind_case() != kTipHashReq) {
    clear_kind();
    set_has_tip_hash_req();
    _impl_.kind_.tip_hash_req_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::TipHashRequest>(GetArena());
  }
  return _impl_.kind_.tip_hash_req_;
}
inline ::alyncoin::net::TipHashRequest* Frame::mutable_tip_hash_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::TipHashRequest* _msg = _internal_mutable_tip_hash_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tip_hash_req)
  return _msg;
}

// .alyncoin.net.TipHashResponse tip_hash_res = 16;
inline bool Frame::has_tip_hash_res() const {
  return kind_case() == kTipHashRes;
}
inline bool Frame::_internal_has_tip_hash_res() const {
  return kind_case() == kTipHashRes;
}
inline void Frame::set_has_tip_hash_res() {
  _impl_._oneof_case_[0] = kTipHashRes;
}
inline void Frame::clear_tip_hash_res() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTipHashRes) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tip_hash_res_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tip_hash_res_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TipHashResponse* Frame::release_tip_hash_res() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tip_hash_res)
  if (kind_case() == kTipHashRes) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tip_hash_res_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tip_hash_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TipHashResponse& Frame::_internal_tip_hash_res() const {
  return kind_case() == kTipHashRes ? *_impl_.kind_.tip_hash_res_ : reinterpret_cast<::alyncoin::net::TipHashResponse&>(::alyncoin::net::_TipHashResponse_default_instance_);
}
inline const ::alyncoin::net::TipHashResponse& Frame::tip_hash_res() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tip_hash_res)
  return _internal_tip_hash_res();
}
inline ::alyncoin::net::TipHashResponse* Frame::unsafe_arena_release_tip_hash_res() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tip_hash_res)
  if (kind_case() == kTipHashRes) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tip_hash_res_;
    _impl_.kind_.tip_hash_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tip_hash_res(::alyncoin::net::TipHashResponse* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tip_hash_res();
    _impl_.kind_.tip_hash_res_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tip_hash_res)
}
inline ::alyncoin::net::TipHashResponse* Frame::_internal_mutable_tip_hash_res() {
  if (kind_case() != kTipHashRes) {
    clear_kind();
    set_has_tip_hash_res();
    _impl_.kind_.tip_hash_res_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::TipHashResponse>(GetArena());
  }
  return _impl_.kind_.tip_hash_res_;
}
inline ::alyncoin::net::TipHashResponse* Frame::mutable_tip_hash_res() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::TipHashResponse* _msg = _internal_mutable_tip_hash_res();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tip_hash_res)
  return _msg;
}

// .alyncoin.net.PeerListRequest peer_list_req = 17;
inline bool Frame::has_peer_list_req() const {
  return kind_case() == kPeerListReq;
}
inline bool Frame::_internal_has_peer_list_req() const {
  return kind_case() == kPeerListReq;
}
inline void Frame::set_has_peer_list_req() {
  _impl_._oneof_case_[0] = kPeerListReq;
}
inline void Frame::clear_peer_list_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPeerListReq) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.peer_list_req_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.peer_list_req_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::PeerListRequest* Frame::release_peer_list_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.peer_list_req)
  if (kind_case() == kPeerListReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.peer_list_req_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.peer_list_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::PeerListRequest& Frame::_internal_peer_list_req() const {
  return kind_case() == kPeerListReq ? *_impl_.kind_.peer_list_req_ : reinterpret_cast<::alyncoin::net::PeerListRequest&>(::alyncoin::net::_PeerListRequest_default_instance_);
}
inline const ::alyncoin::net::PeerListRequest& Frame::peer_list_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.peer_list_req)
  return _internal_peer_list_req();
}
inline ::alyncoin::net::PeerListRequest* Frame::unsafe_arena_release_peer_list_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.peer_list_req)
  if (kind_case() == kPeerListReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.peer_list_req_;
    _impl_.kind_.peer_list_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_peer_list_req(::alyncoin::net::PeerListRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_peer_list_req();
    _impl_.kind_.peer_list_req_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.peer_list_req)
}
inline ::alyncoin::net::PeerListRequest* Frame::_internal_mutable_peer_list_req() {
  if (kind_case() != kPeerListReq) {
    clear_kind();
    set_has_peer_list_req();
    _impl_.kind_.peer_list_req_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::PeerListRequest>(GetArena());
  }
  return _impl_.kind_.peer_list_req_;
}
inline ::alyncoin::net::PeerListRequest* Frame::mutable_peer_list_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::PeerListRequest* _msg = _internal_mutable_peer_list_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.peer_list_req)
  return _msg;
}

// .alyncoin.net.PeerList peer_list = 18;
inline bool Frame::has_peer_list() const {
  return kind_case() == kPeerList;
}
inline bool Frame::_internal_has_peer_list() const {
  return kind_case() == kPeerList;
}
inline void Frame::set_has_peer_list() {
  _impl_._oneof_case_[0] = kPeerList;
}
inline void Frame::clear_peer_list() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kPeerList) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.peer_list_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.peer_list_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::PeerList* Frame::release_peer_list() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.peer_list)
  if (kind_case() == kPeerList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.peer_list_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.peer_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::PeerList& Frame::_internal_peer_list() const {
  return kind_case() == kPeerList ? *_impl_.kind_.peer_list_ : reinterpret_cast<::alyncoin::net::PeerList&>(::alyncoin::net::_PeerList_default_instance_);
}
inline const ::alyncoin::net::PeerList& Frame::peer_list() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.peer_list)
  return _internal_peer_list();
}
inline ::alyncoin::net::PeerList* Frame::unsafe_arena_release_peer_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.peer_list)
  if (kind_case() == kPeerList) {
    clear_has_kind();
    auto* temp = _impl_.kind_.peer_list_;
    _impl_.kind_.peer_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_peer_list(::alyncoin::net::PeerList* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_peer_list();
    _impl_.kind_.peer_list_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.peer_list)
}
inline ::alyncoin::net::PeerList* Frame::_internal_mutable_peer_list() {
  if (kind_case() != kPeerList) {
    clear_kind();
    set_has_peer_list();
    _impl_.kind_.peer_list_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::PeerList>(GetArena());
  }
  return _impl_.kind_.peer_list_;
}
inline ::alyncoin::net::PeerList* Frame::mutable_peer_list() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::PeerList* _msg = _internal_mutable_peer_list();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.peer_list)
  return _msg;
}

// .alyncoin.net.RollupBlockMsg rollup_block = 19;
inline bool Frame::has_rollup_block() const {
  return kind_case() == kRollupBlock;
}
inline bool Frame::_internal_has_rollup_block() const {
  return kind_case() == kRollupBlock;
}
inline void Frame::set_has_rollup_block() {
  _impl_._oneof_case_[0] = kRollupBlock;
}
inline void Frame::clear_rollup_block() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kRollupBlock) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.rollup_block_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.rollup_block_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::RollupBlockMsg* Frame::release_rollup_block() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.rollup_block)
  if (kind_case() == kRollupBlock) {
    clear_has_kind();
    auto* temp = _impl_.kind_.rollup_block_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.rollup_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::RollupBlockMsg& Frame::_internal_rollup_block() const {
  return kind_case() == kRollupBlock ? *_impl_.kind_.rollup_block_ : reinterpret_cast<::alyncoin::net::RollupBlockMsg&>(::alyncoin::net::_RollupBlockMsg_default_instance_);
}
inline const ::alyncoin::net::RollupBlockMsg& Frame::rollup_block() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.rollup_block)
  return _internal_rollup_block();
}
inline ::alyncoin::net::RollupBlockMsg* Frame::unsafe_arena_release_rollup_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.rollup_block)
  if (kind_case() == kRollupBlock) {
    clear_has_kind();
    auto* temp = _impl_.kind_.rollup_block_;
    _impl_.kind_.rollup_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_rollup_block(::alyncoin::net::RollupBlockMsg* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_rollup_block();
    _impl_.kind_.rollup_block_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.rollup_block)
}
inline ::alyncoin::net::RollupBlockMsg* Frame::_internal_mutable_rollup_block() {
  if (kind_case() != kRollupBlock) {
    clear_kind();
    set_has_rollup_block();
    _impl_.kind_.rollup_block_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::RollupBlockMsg>(GetArena());
  }
  return _impl_.kind_.rollup_block_;
}
inline ::alyncoin::net::RollupBlockMsg* Frame::mutable_rollup_block() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::RollupBlockMsg* _msg = _internal_mutable_rollup_block();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.rollup_block)
  return _msg;
}

// .alyncoin.net.SnapshotRequest snapshot_req = 20;
inline bool Frame::has_snapshot_req() const {
  return kind_case() == kSnapshotReq;
}
inline bool Frame::_internal_has_snapshot_req() const {
  return kind_case() == kSnapshotReq;
}
inline void Frame::set_has_snapshot_req() {
  _impl_._oneof_case_[0] = kSnapshotReq;
}
inline void Frame::clear_snapshot_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kSnapshotReq) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.snapshot_req_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.snapshot_req_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotRequest* Frame::release_snapshot_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_req)
  if (kind_case() == kSnapshotReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_req_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotRequest& Frame::_internal_snapshot_req() const {
  return kind_case() == kSnapshotReq ? *_impl_.kind_.snapshot_req_ : reinterpret_cast<::alyncoin::net::SnapshotRequest&>(::alyncoin::net::_SnapshotRequest_default_instance_);
}
inline const ::alyncoin::net::SnapshotRequest& Frame::snapshot_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_req)
  return _internal_snapshot_req();
}
inline ::alyncoin::net::SnapshotRequest* Frame::unsafe_arena_release_snapshot_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_req)
  if (kind_case() == kSnapshotReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.snapshot_req_;
    _impl_.kind_.snapshot_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_req(::alyncoin::net::SnapshotRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_snapshot_req();
    _impl_.kind_.snapshot_req_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_req)
}
inline ::alyncoin::net::SnapshotRequest* Frame::_internal_mutable_snapshot_req() {
  if (kind_case() != kSnapshotReq) {
    clear_kind();
    set_has_snapshot_req();
    _impl_.kind_.snapshot_req_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::SnapshotRequest>(GetArena());
  }
  return _impl_.kind_.snapshot_req_;
}
inline ::alyncoin::net::SnapshotRequest* Frame::mutable_snapshot_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::SnapshotRequest* _msg = _internal_mutable_snapshot_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_req)
  return _msg;
}

// .alyncoin.net.TailBlocksRequest tail_req = 21;
inline bool Frame::has_tail_req() const {
  return kind_case() == kTailReq;
}
inline bool Frame::_internal_has_tail_req() const {
  return kind_case() == kTailReq;
}
inline void Frame::set_has_tail_req() {
  _impl_._oneof_case_[0] = kTailReq;
}
inline void Frame::clear_tail_req() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTailReq) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tail_req_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tail_req_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TailBlocksRequest* Frame::release_tail_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tail_req)
  if (kind_case() == kTailReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tail_req_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tail_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TailBlocksRequest& Frame::_internal_tail_req() const {
  return kind_case() == kTailReq ? *_impl_.kind_.tail_req_ : reinterpret_cast<::alyncoin::net::TailBlocksRequest&>(::alyncoin::net::_TailBlocksRequest_default_instance_);
}
inline const ::alyncoin::net::TailBlocksRequest& Frame::tail_req() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tail_req)
  return _internal_tail_req();
}
inline ::alyncoin::net::TailBlocksRequest* Frame::unsafe_arena_release_tail_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tail_req)
  if (kind_case() == kTailReq) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tail_req_;
    _impl_.kind_.tail_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tail_req(::alyncoin::net::TailBlocksRequest* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tail_req();
    _impl_.kind_.tail_req_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tail_req)
}
inline ::alyncoin::net::TailBlocksRequest* Frame::_internal_mutable_tail_req() {
  if (kind_case() != kTailReq) {
    clear_kind();
    set_has_tail_req();
    _impl_.kind_.tail_req_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::TailBlocksRequest>(GetArena());
  }
  return _impl_.kind_.tail_req_;
}
inline ::alyncoin::net::TailBlocksRequest* Frame::mutable_tail_req() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::TailBlocksRequest* _msg = _internal_mutable_tail_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tail_req)
  return _msg;
}

// .alyncoin.net.StateProof state_proof = 22;
inline bool Frame::has_state_proof() const {
  return kind_case() == kStateProof;
}
inline bool Frame::_internal_has_state_proof() const {
  return kind_case() == kStateProof;
}
inline void Frame::set_has_state_proof() {
  _impl_._oneof_case_[0] = kStateProof;
}
inline void Frame::clear_state_proof() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kStateProof) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.state_proof_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.state_proof_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::StateProof* Frame::release_state_proof() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.state_proof)
  if (kind_case() == kStateProof) {
    clear_has_kind();
    auto* temp = _impl_.kind_.state_proof_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.state_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::StateProof& Frame::_internal_state_proof() const {
  return kind_case() == kStateProof ? *_impl_.kind_.state_proof_ : reinterpret_cast<::alyncoin::net::StateProof&>(::alyncoin::net::_StateProof_default_instance_);
}
inline const ::alyncoin::net::StateProof& Frame::state_proof() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.state_proof)
  return _internal_state_proof();
}
inline ::alyncoin::net::StateProof* Frame::unsafe_arena_release_state_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.state_proof)
  if (kind_case() == kStateProof) {
    clear_has_kind();
    auto* temp = _impl_.kind_.state_proof_;
    _impl_.kind_.state_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_state_proof(::alyncoin::net::StateProof* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_state_proof();
    _impl_.kind_.state_proof_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.state_proof)
}
inline ::alyncoin::net::StateProof* Frame::_internal_mutable_state_proof() {
  if (kind_case() != kStateProof) {
    clear_kind();
    set_has_state_proof();
    _impl_.kind_.state_proof_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::StateProof>(GetArena());
  }
  return _impl_.kind_.state_proof_;
}
inline ::alyncoin::net::StateProof* Frame::mutable_state_proof() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::StateProof* _msg = _internal_mutable_state_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.state_proof)
  return _msg;
}

// .alyncoin.net.GetData get_data = 23;
inline bool Frame::has_get_data() const {
  return kind_case() == kGetData;
}
inline bool Frame::_internal_has_get_data() const {
  return kind_case() == kGetData;
}
inline void Frame::set_has_get_data() {
  _impl_._oneof_case_[0] = kGetData;
}
inline void Frame::clear_get_data() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kGetData) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.get_data_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.get_data_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::GetData* Frame::release_get_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.get_data)
  if (kind_case() == kGetData) {
    clear_has_kind();
    auto* temp = _impl_.kind_.get_data_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::GetData& Frame::_internal_get_data() const {
  return kind_case() == kGetData ? *_impl_.kind_.get_data_ : reinterpret_cast<::alyncoin::net::GetData&>(::alyncoin::net::_GetData_default_instance_);
}
inline const ::alyncoin::net::GetData& Frame::get_data() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.get_data)
  return _internal_get_data();
}
inline ::alyncoin::net::GetData* Frame::unsafe_arena_release_get_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.get_data)
  if (kind_case() == kGetData) {
    clear_has_kind();
    auto* temp = _impl_.kind_.get_data_;
    _impl_.kind_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_get_data(::alyncoin::net::GetData* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_get_data();
    _impl_.kind_.get_data_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.get_data)
}
inline ::alyncoin::net::GetData* Frame::_internal_mutable_get_data() {
  if (kind_case() != kGetData) {
    clear_kind();
    set_has_get_data();
    _impl_.kind_.get_data_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::GetData>(GetArena());
  }
  return _impl_.kind_.get_data_;
}
inline ::alyncoin::net::GetData* Frame::mutable_get_data() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::GetData* _msg = _internal_mutable_get_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.get_data)
  return _msg;
}

// .alyncoin.BlockchainSyncProto blockchain_sync_request = 24;
inline bool Frame::has_blockchain_sync_request() const {
  return kind_case() == kBlockchainSyncRequest;
}
inline bool Frame::_internal_has_blockchain_sync_request() const {
  return kind_case() == kBlockchainSyncRequest;
}
inline void Frame::set_has_blockchain_sync_request() {
  _impl_._oneof_case_[0] = kBlockchainSyncRequest;
}
inline ::alyncoin::BlockchainSyncProto* Frame::release_blockchain_sync_request() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.blockchain_sync_request)
  if (kind_case() == kBlockchainSyncRequest) {
    clear_has_kind();
    auto* temp = _impl_.kind_.blockchain_sync_request_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.blockchain_sync_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::BlockchainSyncProto& Frame::_internal_blockchain_sync_request() const {
  return kind_case() == kBlockchainSyncRequest ? *_impl_.kind_.blockchain_sync_request_ : reinterpret_cast<::alyncoin::BlockchainSyncProto&>(::alyncoin::_BlockchainSyncProto_default_instance_);
}
inline const ::alyncoin::BlockchainSyncProto& Frame::blockchain_sync_request() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.blockchain_sync_request)
  return _internal_blockchain_sync_request();
}
inline ::alyncoin::BlockchainSyncProto* Frame::unsafe_arena_release_blockchain_sync_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.blockchain_sync_request)
  if (kind_case() == kBlockchainSyncRequest) {
    clear_has_kind();
    auto* temp = _impl_.kind_.blockchain_sync_request_;
    _impl_.kind_.blockchain_sync_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_blockchain_sync_request(::alyncoin::BlockchainSyncProto* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_blockchain_sync_request();
    _impl_.kind_.blockchain_sync_request_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.blockchain_sync_request)
}
inline ::alyncoin::BlockchainSyncProto* Frame::_internal_mutable_blockchain_sync_request() {
  if (kind_case() != kBlockchainSyncRequest) {
    clear_kind();
    set_has_blockchain_sync_request();
    _impl_.kind_.blockchain_sync_request_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::BlockchainSyncProto>(GetArena());
  }
  return _impl_.kind_.blockchain_sync_request_;
}
inline ::alyncoin::BlockchainSyncProto* Frame::mutable_blockchain_sync_request() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::BlockchainSyncProto* _msg = _internal_mutable_blockchain_sync_request();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.blockchain_sync_request)
  return _msg;
}

// .alyncoin.net.TransactionBroadcast tx_broadcast = 25;
inline bool Frame::has_tx_broadcast() const {
  return kind_case() == kTxBroadcast;
}
inline bool Frame::_internal_has_tx_broadcast() const {
  return kind_case() == kTxBroadcast;
}
inline void Frame::set_has_tx_broadcast() {
  _impl_._oneof_case_[0] = kTxBroadcast;
}
inline void Frame::clear_tx_broadcast() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kTxBroadcast) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.tx_broadcast_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.tx_broadcast_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TransactionBroadcast* Frame::release_tx_broadcast() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tx_broadcast)
  if (kind_case() == kTxBroadcast) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tx_broadcast_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tx_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TransactionBroadcast& Frame::_internal_tx_broadcast() const {
  return kind_case() == kTxBroadcast ? *_impl_.kind_.tx_broadcast_ : reinterpret_cast<::alyncoin::net::TransactionBroadcast&>(::alyncoin::net::_TransactionBroadcast_default_instance_);
}
inline const ::alyncoin::net::TransactionBroadcast& Frame::tx_broadcast() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tx_broadcast)
  return _internal_tx_broadcast();
}
inline ::alyncoin::net::TransactionBroadcast* Frame::unsafe_arena_release_tx_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tx_broadcast)
  if (kind_case() == kTxBroadcast) {
    clear_has_kind();
    auto* temp = _impl_.kind_.tx_broadcast_;
    _impl_.kind_.tx_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tx_broadcast(::alyncoin::net::TransactionBroadcast* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_tx_broadcast();
    _impl_.kind_.tx_broadcast_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tx_broadcast)
}
inline ::alyncoin::net::TransactionBroadcast* Frame::_internal_mutable_tx_broadcast() {
  if (kind_case() != kTxBroadcast) {
    clear_kind();
    set_has_tx_broadcast();
    _impl_.kind_.tx_broadcast_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::TransactionBroadcast>(GetArena());
  }
  return _impl_.kind_.tx_broadcast_;
}
inline ::alyncoin::net::TransactionBroadcast* Frame::mutable_tx_broadcast() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::TransactionBroadcast* _msg = _internal_mutable_tx_broadcast();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tx_broadcast)
  return _msg;
}

// .alyncoin.net.Whisper whisper = 26;
inline bool Frame::has_whisper() const {
  return kind_case() == kWhisper;
}
inline bool Frame::_internal_has_whisper() const {
  return kind_case() == kWhisper;
}
inline void Frame::set_has_whisper() {
  _impl_._oneof_case_[0] = kWhisper;
}
inline void Frame::clear_whisper() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kWhisper) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.whisper_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.whisper_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Whisper* Frame::release_whisper() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.whisper)
  if (kind_case() == kWhisper) {
    clear_has_kind();
    auto* temp = _impl_.kind_.whisper_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.whisper_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Whisper& Frame::_internal_whisper() const {
  return kind_case() == kWhisper ? *_impl_.kind_.whisper_ : reinterpret_cast<::alyncoin::net::Whisper&>(::alyncoin::net::_Whisper_default_instance_);
}
inline const ::alyncoin::net::Whisper& Frame::whisper() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.whisper)
  return _internal_whisper();
}
inline ::alyncoin::net::Whisper* Frame::unsafe_arena_release_whisper() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.whisper)
  if (kind_case() == kWhisper) {
    clear_has_kind();
    auto* temp = _impl_.kind_.whisper_;
    _impl_.kind_.whisper_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_whisper(::alyncoin::net::Whisper* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_whisper();
    _impl_.kind_.whisper_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.whisper)
}
inline ::alyncoin::net::Whisper* Frame::_internal_mutable_whisper() {
  if (kind_case() != kWhisper) {
    clear_kind();
    set_has_whisper();
    _impl_.kind_.whisper_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::Whisper>(GetArena());
  }
  return _impl_.kind_.whisper_;
}
inline ::alyncoin::net::Whisper* Frame::mutable_whisper() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::Whisper* _msg = _internal_mutable_whisper();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.whisper)
  return _msg;
}

// .alyncoin.net.GetHeaders get_headers = 27;
inline bool Frame::has_get_headers() const {
  return kind_case() == kGetHeaders;
}
inline bool Frame::_internal_has_get_headers() const {
  return kind_case() == kGetHeaders;
}
inline void Frame::set_has_get_headers() {
  _impl_._oneof_case_[0] = kGetHeaders;
}
inline void Frame::clear_get_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kGetHeaders) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.get_headers_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.get_headers_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::GetHeaders* Frame::release_get_headers() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.get_headers)
  if (kind_case() == kGetHeaders) {
    clear_has_kind();
    auto* temp = _impl_.kind_.get_headers_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.get_headers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::GetHeaders& Frame::_internal_get_headers() const {
  return kind_case() == kGetHeaders ? *_impl_.kind_.get_headers_ : reinterpret_cast<::alyncoin::net::GetHeaders&>(::alyncoin::net::_GetHeaders_default_instance_);
}
inline const ::alyncoin::net::GetHeaders& Frame::get_headers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.get_headers)
  return _internal_get_headers();
}
inline ::alyncoin::net::GetHeaders* Frame::unsafe_arena_release_get_headers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.get_headers)
  if (kind_case() == kGetHeaders) {
    clear_has_kind();
    auto* temp = _impl_.kind_.get_headers_;
    _impl_.kind_.get_headers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_get_headers(::alyncoin::net::GetHeaders* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_get_headers();
    _impl_.kind_.get_headers_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.get_headers)
}
inline ::alyncoin::net::GetHeaders* Frame::_internal_mutable_get_headers() {
  if (kind_case() != kGetHeaders) {
    clear_kind();
    set_has_get_headers();
    _impl_.kind_.get_headers_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::GetHeaders>(GetArena());
  }
  return _impl_.kind_.get_headers_;
}
inline ::alyncoin::net::GetHeaders* Frame::mutable_get_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::GetHeaders* _msg = _internal_mutable_get_headers();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.get_headers)
  return _msg;
}

// .alyncoin.net.Headers headers = 28;
inline bool Frame::has_headers() const {
  return kind_case() == kHeaders;
}
inline bool Frame::_internal_has_headers() const {
  return kind_case() == kHeaders;
}
inline void Frame::set_has_headers() {
  _impl_._oneof_case_[0] = kHeaders;
}
inline void Frame::clear_headers() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (kind_case() == kHeaders) {
    if (GetArena() == nullptr) {
      delete _impl_.kind_.headers_;
    } else if (::google::protobuf::internal::DebugHardenClearOneofMessageOnArena()) {
      ::google::protobuf::internal::MaybePoisonAfterClear(_impl_.kind_.headers_);
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Headers* Frame::release_headers() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.headers)
  if (kind_case() == kHeaders) {
    clear_has_kind();
    auto* temp = _impl_.kind_.headers_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.headers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Headers& Frame::_internal_headers() const {
  return kind_case() == kHeaders ? *_impl_.kind_.headers_ : reinterpret_cast<::alyncoin::net::Headers&>(::alyncoin::net::_Headers_default_instance_);
}
inline const ::alyncoin::net::Headers& Frame::headers() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.headers)
  return _internal_headers();
}
inline ::alyncoin::net::Headers* Frame::unsafe_arena_release_headers() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.headers)
  if (kind_case() == kHeaders) {
    clear_has_kind();
    auto* temp = _impl_.kind_.headers_;
    _impl_.kind_.headers_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_headers(::alyncoin::net::Headers* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_kind();
  if (value) {
    set_has_headers();
    _impl_.kind_.headers_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.headers)
}
inline ::alyncoin::net::Headers* Frame::_internal_mutable_headers() {
  if (kind_case() != kHeaders) {
    clear_kind();
    set_has_headers();
    _impl_.kind_.headers_ =
        ::google::protobuf::Message::DefaultConstruct<::alyncoin::net::Headers>(GetArena());
  }
  return _impl_.kind_.headers_;
}
inline ::alyncoin::net::Headers* Frame::mutable_headers() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::alyncoin::net::Headers* _msg = _internal_mutable_headers();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.headers)
  return _msg;
}

inline bool Frame::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Frame::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Frame::KindCase Frame::kind_case() const {
  return Frame::KindCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace net
}  // namespace alyncoin


// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // net_5fframe_2eproto_2epb_2eh
