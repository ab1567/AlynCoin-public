// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net_frame.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_5fframe_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_5fframe_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "block_protos.pb.h"
#include "blockchain_protos.pb.h"
#include "sync_protos.pb.h"
#include "transaction_protos.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_5fframe_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_5fframe_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_5fframe_2eproto;
namespace alyncoin {
namespace net {
class BlockBatch;
struct BlockBatchDefaultTypeInternal;
extern BlockBatchDefaultTypeInternal _BlockBatch_default_instance_;
class BlockBroadcast;
struct BlockBroadcastDefaultTypeInternal;
extern BlockBroadcastDefaultTypeInternal _BlockBroadcast_default_instance_;
class EpochProof;
struct EpochProofDefaultTypeInternal;
extern EpochProofDefaultTypeInternal _EpochProof_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class GetData;
struct GetDataDefaultTypeInternal;
extern GetDataDefaultTypeInternal _GetData_default_instance_;
class Handshake;
struct HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class HeightRequest;
struct HeightRequestDefaultTypeInternal;
extern HeightRequestDefaultTypeInternal _HeightRequest_default_instance_;
class HeightResponse;
struct HeightResponseDefaultTypeInternal;
extern HeightResponseDefaultTypeInternal _HeightResponse_default_instance_;
class Inventory;
struct InventoryDefaultTypeInternal;
extern InventoryDefaultTypeInternal _Inventory_default_instance_;
class PeerList;
struct PeerListDefaultTypeInternal;
extern PeerListDefaultTypeInternal _PeerList_default_instance_;
class PeerListRequest;
struct PeerListRequestDefaultTypeInternal;
extern PeerListRequestDefaultTypeInternal _PeerListRequest_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class RollupBlockMsg;
struct RollupBlockMsgDefaultTypeInternal;
extern RollupBlockMsgDefaultTypeInternal _RollupBlockMsg_default_instance_;
class SnapshotChunk;
struct SnapshotChunkDefaultTypeInternal;
extern SnapshotChunkDefaultTypeInternal _SnapshotChunk_default_instance_;
class SnapshotEnd;
struct SnapshotEndDefaultTypeInternal;
extern SnapshotEndDefaultTypeInternal _SnapshotEnd_default_instance_;
class SnapshotRequest;
struct SnapshotRequestDefaultTypeInternal;
extern SnapshotRequestDefaultTypeInternal _SnapshotRequest_default_instance_;
class StateProof;
struct StateProofDefaultTypeInternal;
extern StateProofDefaultTypeInternal _StateProof_default_instance_;
class TailBlocks;
struct TailBlocksDefaultTypeInternal;
extern TailBlocksDefaultTypeInternal _TailBlocks_default_instance_;
class TailBlocksRequest;
struct TailBlocksRequestDefaultTypeInternal;
extern TailBlocksRequestDefaultTypeInternal _TailBlocksRequest_default_instance_;
class TipHashRequest;
struct TipHashRequestDefaultTypeInternal;
extern TipHashRequestDefaultTypeInternal _TipHashRequest_default_instance_;
class TipHashResponse;
struct TipHashResponseDefaultTypeInternal;
extern TipHashResponseDefaultTypeInternal _TipHashResponse_default_instance_;
class TransactionBroadcast;
struct TransactionBroadcastDefaultTypeInternal;
extern TransactionBroadcastDefaultTypeInternal _TransactionBroadcast_default_instance_;
}  // namespace net
}  // namespace alyncoin
PROTOBUF_NAMESPACE_OPEN
template<> ::alyncoin::net::BlockBatch* Arena::CreateMaybeMessage<::alyncoin::net::BlockBatch>(Arena*);
template<> ::alyncoin::net::BlockBroadcast* Arena::CreateMaybeMessage<::alyncoin::net::BlockBroadcast>(Arena*);
template<> ::alyncoin::net::EpochProof* Arena::CreateMaybeMessage<::alyncoin::net::EpochProof>(Arena*);
template<> ::alyncoin::net::Frame* Arena::CreateMaybeMessage<::alyncoin::net::Frame>(Arena*);
template<> ::alyncoin::net::GetData* Arena::CreateMaybeMessage<::alyncoin::net::GetData>(Arena*);
template<> ::alyncoin::net::Handshake* Arena::CreateMaybeMessage<::alyncoin::net::Handshake>(Arena*);
template<> ::alyncoin::net::HeightRequest* Arena::CreateMaybeMessage<::alyncoin::net::HeightRequest>(Arena*);
template<> ::alyncoin::net::HeightResponse* Arena::CreateMaybeMessage<::alyncoin::net::HeightResponse>(Arena*);
template<> ::alyncoin::net::Inventory* Arena::CreateMaybeMessage<::alyncoin::net::Inventory>(Arena*);
template<> ::alyncoin::net::PeerList* Arena::CreateMaybeMessage<::alyncoin::net::PeerList>(Arena*);
template<> ::alyncoin::net::PeerListRequest* Arena::CreateMaybeMessage<::alyncoin::net::PeerListRequest>(Arena*);
template<> ::alyncoin::net::Ping* Arena::CreateMaybeMessage<::alyncoin::net::Ping>(Arena*);
template<> ::alyncoin::net::Pong* Arena::CreateMaybeMessage<::alyncoin::net::Pong>(Arena*);
template<> ::alyncoin::net::RollupBlockMsg* Arena::CreateMaybeMessage<::alyncoin::net::RollupBlockMsg>(Arena*);
template<> ::alyncoin::net::SnapshotChunk* Arena::CreateMaybeMessage<::alyncoin::net::SnapshotChunk>(Arena*);
template<> ::alyncoin::net::SnapshotEnd* Arena::CreateMaybeMessage<::alyncoin::net::SnapshotEnd>(Arena*);
template<> ::alyncoin::net::SnapshotRequest* Arena::CreateMaybeMessage<::alyncoin::net::SnapshotRequest>(Arena*);
template<> ::alyncoin::net::StateProof* Arena::CreateMaybeMessage<::alyncoin::net::StateProof>(Arena*);
template<> ::alyncoin::net::TailBlocks* Arena::CreateMaybeMessage<::alyncoin::net::TailBlocks>(Arena*);
template<> ::alyncoin::net::TailBlocksRequest* Arena::CreateMaybeMessage<::alyncoin::net::TailBlocksRequest>(Arena*);
template<> ::alyncoin::net::TipHashRequest* Arena::CreateMaybeMessage<::alyncoin::net::TipHashRequest>(Arena*);
template<> ::alyncoin::net::TipHashResponse* Arena::CreateMaybeMessage<::alyncoin::net::TipHashResponse>(Arena*);
template<> ::alyncoin::net::TransactionBroadcast* Arena::CreateMaybeMessage<::alyncoin::net::TransactionBroadcast>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace alyncoin {
namespace net {

// ===================================================================

class Handshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.Handshake) */ {
 public:
  inline Handshake() : Handshake(nullptr) {}
  ~Handshake() override;
  explicit PROTOBUF_CONSTEXPR Handshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Handshake(const Handshake& from);
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handshake& operator=(Handshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }
  inline void Swap(Handshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Handshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Handshake& from) {
    Handshake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Handshake";
  }
  protected:
  explicit Handshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 6,
    kVersionFieldNumber = 1,
    kNetworkIdFieldNumber = 2,
    kGenesisHashFieldNumber = 5,
    kHeightFieldNumber = 3,
    kListenPortFieldNumber = 4,
  };
  // repeated string capabilities = 6;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  const std::string& capabilities(int index) const;
  std::string* mutable_capabilities(int index);
  void set_capabilities(int index, const std::string& value);
  void set_capabilities(int index, std::string&& value);
  void set_capabilities(int index, const char* value);
  void set_capabilities(int index, const char* value, size_t size);
  std::string* add_capabilities();
  void add_capabilities(const std::string& value);
  void add_capabilities(std::string&& value);
  void add_capabilities(const char* value);
  void add_capabilities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_capabilities();
  private:
  const std::string& _internal_capabilities(int index) const;
  std::string* _internal_add_capabilities();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string network_id = 2;
  void clear_network_id();
  const std::string& network_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_id();
  PROTOBUF_NODISCARD std::string* release_network_id();
  void set_allocated_network_id(std::string* network_id);
  private:
  const std::string& _internal_network_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_id(const std::string& value);
  std::string* _internal_mutable_network_id();
  public:

  // bytes genesis_hash = 5;
  void clear_genesis_hash();
  const std::string& genesis_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_genesis_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_genesis_hash();
  PROTOBUF_NODISCARD std::string* release_genesis_hash();
  void set_allocated_genesis_hash(std::string* genesis_hash);
  private:
  const std::string& _internal_genesis_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_genesis_hash(const std::string& value);
  std::string* _internal_mutable_genesis_hash();
  public:

  // uint64 height = 3;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // uint32 listen_port = 4;
  void clear_listen_port();
  uint32_t listen_port() const;
  void set_listen_port(uint32_t value);
  private:
  uint32_t _internal_listen_port() const;
  void _internal_set_listen_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.Handshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> capabilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr genesis_hash_;
    uint64_t height_;
    uint32_t listen_port_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Pong final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.HeightRequest) */ {
 public:
  inline HeightRequest() : HeightRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeightRequest(const HeightRequest& from);
  HeightRequest(HeightRequest&& from) noexcept
    : HeightRequest() {
    *this = ::std::move(from);
  }

  inline HeightRequest& operator=(const HeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightRequest& operator=(HeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightRequest* internal_default_instance() {
    return reinterpret_cast<const HeightRequest*>(
               &_HeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HeightRequest& a, HeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeightRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeightRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeightRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.HeightRequest";
  }
  protected:
  explicit HeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.HeightResponse) */ {
 public:
  inline HeightResponse() : HeightResponse(nullptr) {}
  ~HeightResponse() override;
  explicit PROTOBUF_CONSTEXPR HeightResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeightResponse(const HeightResponse& from);
  HeightResponse(HeightResponse&& from) noexcept
    : HeightResponse() {
    *this = ::std::move(from);
  }

  inline HeightResponse& operator=(const HeightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightResponse& operator=(HeightResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightResponse* internal_default_instance() {
    return reinterpret_cast<const HeightResponse*>(
               &_HeightResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HeightResponse& a, HeightResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeightResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeightResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeightResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeightResponse& from) {
    HeightResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeightResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.HeightResponse";
  }
  protected:
  explicit HeightResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockBroadcast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.BlockBroadcast) */ {
 public:
  inline BlockBroadcast() : BlockBroadcast(nullptr) {}
  ~BlockBroadcast() override;
  explicit PROTOBUF_CONSTEXPR BlockBroadcast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBroadcast(const BlockBroadcast& from);
  BlockBroadcast(BlockBroadcast&& from) noexcept
    : BlockBroadcast() {
    *this = ::std::move(from);
  }

  inline BlockBroadcast& operator=(const BlockBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBroadcast& operator=(BlockBroadcast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBroadcast& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBroadcast* internal_default_instance() {
    return reinterpret_cast<const BlockBroadcast*>(
               &_BlockBroadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlockBroadcast& a, BlockBroadcast& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBroadcast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBroadcast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBroadcast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBroadcast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBroadcast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBroadcast& from) {
    BlockBroadcast::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBroadcast* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.BlockBroadcast";
  }
  protected:
  explicit BlockBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .alyncoin.BlockProto block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::alyncoin::BlockProto& block() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockProto* release_block();
  ::alyncoin::BlockProto* mutable_block();
  void set_allocated_block(::alyncoin::BlockProto* block);
  private:
  const ::alyncoin::BlockProto& _internal_block() const;
  ::alyncoin::BlockProto* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::alyncoin::BlockProto* block);
  ::alyncoin::BlockProto* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockBroadcast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::alyncoin::BlockProto* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.BlockBatch) */ {
 public:
  inline BlockBatch() : BlockBatch(nullptr) {}
  ~BlockBatch() override;
  explicit PROTOBUF_CONSTEXPR BlockBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBatch(const BlockBatch& from);
  BlockBatch(BlockBatch&& from) noexcept
    : BlockBatch() {
    *this = ::std::move(from);
  }

  inline BlockBatch& operator=(const BlockBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBatch& operator=(BlockBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBatch* internal_default_instance() {
    return reinterpret_cast<const BlockBatch*>(
               &_BlockBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockBatch& a, BlockBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBatch& from) {
    BlockBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.BlockBatch";
  }
  protected:
  explicit BlockBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainFieldNumber = 1,
  };
  // .alyncoin.BlockchainProto chain = 1;
  bool has_chain() const;
  private:
  bool _internal_has_chain() const;
  public:
  void clear_chain();
  const ::alyncoin::BlockchainProto& chain() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockchainProto* release_chain();
  ::alyncoin::BlockchainProto* mutable_chain();
  void set_allocated_chain(::alyncoin::BlockchainProto* chain);
  private:
  const ::alyncoin::BlockchainProto& _internal_chain() const;
  ::alyncoin::BlockchainProto* _internal_mutable_chain();
  public:
  void unsafe_arena_set_allocated_chain(
      ::alyncoin::BlockchainProto* chain);
  ::alyncoin::BlockchainProto* unsafe_arena_release_chain();

  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::alyncoin::BlockchainProto* chain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotChunk) */ {
 public:
  inline SnapshotChunk() : SnapshotChunk(nullptr) {}
  ~SnapshotChunk() override;
  explicit PROTOBUF_CONSTEXPR SnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotChunk(const SnapshotChunk& from);
  SnapshotChunk(SnapshotChunk&& from) noexcept
    : SnapshotChunk() {
    *this = ::std::move(from);
  }

  inline SnapshotChunk& operator=(const SnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotChunk& operator=(SnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const SnapshotChunk*>(
               &_SnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SnapshotChunk& a, SnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotChunk& from) {
    SnapshotChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.SnapshotChunk";
  }
  protected:
  explicit SnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotEnd final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotEnd) */ {
 public:
  inline SnapshotEnd() : SnapshotEnd(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SnapshotEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotEnd(const SnapshotEnd& from);
  SnapshotEnd(SnapshotEnd&& from) noexcept
    : SnapshotEnd() {
    *this = ::std::move(from);
  }

  inline SnapshotEnd& operator=(const SnapshotEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotEnd& operator=(SnapshotEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotEnd* internal_default_instance() {
    return reinterpret_cast<const SnapshotEnd*>(
               &_SnapshotEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SnapshotEnd& a, SnapshotEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotEnd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotEnd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.SnapshotEnd";
  }
  protected:
  explicit SnapshotEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TailBlocks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.TailBlocks) */ {
 public:
  inline TailBlocks() : TailBlocks(nullptr) {}
  ~TailBlocks() override;
  explicit PROTOBUF_CONSTEXPR TailBlocks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailBlocks(const TailBlocks& from);
  TailBlocks(TailBlocks&& from) noexcept
    : TailBlocks() {
    *this = ::std::move(from);
  }

  inline TailBlocks& operator=(const TailBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailBlocks& operator=(TailBlocks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailBlocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailBlocks* internal_default_instance() {
    return reinterpret_cast<const TailBlocks*>(
               &_TailBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TailBlocks& a, TailBlocks& b) {
    a.Swap(&b);
  }
  inline void Swap(TailBlocks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailBlocks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailBlocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailBlocks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailBlocks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TailBlocks& from) {
    TailBlocks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailBlocks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.TailBlocks";
  }
  protected:
  explicit TailBlocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .alyncoin.BlockProto blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::alyncoin::BlockProto* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >*
      mutable_blocks();
  private:
  const ::alyncoin::BlockProto& _internal_blocks(int index) const;
  ::alyncoin::BlockProto* _internal_add_blocks();
  public:
  const ::alyncoin::BlockProto& blocks(int index) const;
  ::alyncoin::BlockProto* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:alyncoin.net.TailBlocks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto > blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class EpochProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.EpochProof) */ {
 public:
  inline EpochProof() : EpochProof(nullptr) {}
  ~EpochProof() override;
  explicit PROTOBUF_CONSTEXPR EpochProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EpochProof(const EpochProof& from);
  EpochProof(EpochProof&& from) noexcept
    : EpochProof() {
    *this = ::std::move(from);
  }

  inline EpochProof& operator=(const EpochProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochProof& operator=(EpochProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpochProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpochProof* internal_default_instance() {
    return reinterpret_cast<const EpochProof*>(
               &_EpochProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EpochProof& a, EpochProof& b) {
    a.Swap(&b);
  }
  inline void Swap(EpochProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpochProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpochProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EpochProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EpochProof& from) {
    EpochProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.EpochProof";
  }
  protected:
  explicit EpochProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.EpochProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Inventory final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.Inventory) */ {
 public:
  inline Inventory() : Inventory(nullptr) {}
  ~Inventory() override;
  explicit PROTOBUF_CONSTEXPR Inventory(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Inventory(const Inventory& from);
  Inventory(Inventory&& from) noexcept
    : Inventory() {
    *this = ::std::move(from);
  }

  inline Inventory& operator=(const Inventory& from) {
    CopyFrom(from);
    return *this;
  }
  inline Inventory& operator=(Inventory&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Inventory& default_instance() {
    return *internal_default_instance();
  }
  static inline const Inventory* internal_default_instance() {
    return reinterpret_cast<const Inventory*>(
               &_Inventory_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Inventory& a, Inventory& b) {
    a.Swap(&b);
  }
  inline void Swap(Inventory* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Inventory* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Inventory* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Inventory>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Inventory& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Inventory& from) {
    Inventory::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Inventory* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Inventory";
  }
  protected:
  explicit Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated string hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const char* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.Inventory)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TipHashRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.TipHashRequest) */ {
 public:
  inline TipHashRequest() : TipHashRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TipHashRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TipHashRequest(const TipHashRequest& from);
  TipHashRequest(TipHashRequest&& from) noexcept
    : TipHashRequest() {
    *this = ::std::move(from);
  }

  inline TipHashRequest& operator=(const TipHashRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TipHashRequest& operator=(TipHashRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TipHashRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TipHashRequest* internal_default_instance() {
    return reinterpret_cast<const TipHashRequest*>(
               &_TipHashRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(TipHashRequest& a, TipHashRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TipHashRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TipHashRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TipHashRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TipHashRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TipHashRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TipHashRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.TipHashRequest";
  }
  protected:
  explicit TipHashRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.TipHashRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TipHashResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.TipHashResponse) */ {
 public:
  inline TipHashResponse() : TipHashResponse(nullptr) {}
  ~TipHashResponse() override;
  explicit PROTOBUF_CONSTEXPR TipHashResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TipHashResponse(const TipHashResponse& from);
  TipHashResponse(TipHashResponse&& from) noexcept
    : TipHashResponse() {
    *this = ::std::move(from);
  }

  inline TipHashResponse& operator=(const TipHashResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TipHashResponse& operator=(TipHashResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TipHashResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TipHashResponse* internal_default_instance() {
    return reinterpret_cast<const TipHashResponse*>(
               &_TipHashResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TipHashResponse& a, TipHashResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TipHashResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TipHashResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TipHashResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TipHashResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TipHashResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TipHashResponse& from) {
    TipHashResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TipHashResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.TipHashResponse";
  }
  protected:
  explicit TipHashResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashFieldNumber = 1,
  };
  // string hash = 1;
  void clear_hash();
  const std::string& hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hash();
  PROTOBUF_NODISCARD std::string* release_hash();
  void set_allocated_hash(std::string* hash);
  private:
  const std::string& _internal_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hash(const std::string& value);
  std::string* _internal_mutable_hash();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.TipHashResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class PeerListRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.PeerListRequest) */ {
 public:
  inline PeerListRequest() : PeerListRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR PeerListRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerListRequest(const PeerListRequest& from);
  PeerListRequest(PeerListRequest&& from) noexcept
    : PeerListRequest() {
    *this = ::std::move(from);
  }

  inline PeerListRequest& operator=(const PeerListRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerListRequest& operator=(PeerListRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerListRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerListRequest* internal_default_instance() {
    return reinterpret_cast<const PeerListRequest*>(
               &_PeerListRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(PeerListRequest& a, PeerListRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerListRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerListRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerListRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerListRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const PeerListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const PeerListRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.PeerListRequest";
  }
  protected:
  explicit PeerListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.PeerListRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class PeerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.PeerList) */ {
 public:
  inline PeerList() : PeerList(nullptr) {}
  ~PeerList() override;
  explicit PROTOBUF_CONSTEXPR PeerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PeerList(const PeerList& from);
  PeerList(PeerList&& from) noexcept
    : PeerList() {
    *this = ::std::move(from);
  }

  inline PeerList& operator=(const PeerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline PeerList& operator=(PeerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PeerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const PeerList* internal_default_instance() {
    return reinterpret_cast<const PeerList*>(
               &_PeerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(PeerList& a, PeerList& b) {
    a.Swap(&b);
  }
  inline void Swap(PeerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PeerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PeerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PeerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PeerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PeerList& from) {
    PeerList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PeerList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.PeerList";
  }
  protected:
  explicit PeerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeersFieldNumber = 1,
  };
  // repeated string peers = 1;
  int peers_size() const;
  private:
  int _internal_peers_size() const;
  public:
  void clear_peers();
  const std::string& peers(int index) const;
  std::string* mutable_peers(int index);
  void set_peers(int index, const std::string& value);
  void set_peers(int index, std::string&& value);
  void set_peers(int index, const char* value);
  void set_peers(int index, const char* value, size_t size);
  std::string* add_peers();
  void add_peers(const std::string& value);
  void add_peers(std::string&& value);
  void add_peers(const char* value);
  void add_peers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& peers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_peers();
  private:
  const std::string& _internal_peers(int index) const;
  std::string* _internal_add_peers();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.PeerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> peers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class RollupBlockMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.RollupBlockMsg) */ {
 public:
  inline RollupBlockMsg() : RollupBlockMsg(nullptr) {}
  ~RollupBlockMsg() override;
  explicit PROTOBUF_CONSTEXPR RollupBlockMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RollupBlockMsg(const RollupBlockMsg& from);
  RollupBlockMsg(RollupBlockMsg&& from) noexcept
    : RollupBlockMsg() {
    *this = ::std::move(from);
  }

  inline RollupBlockMsg& operator=(const RollupBlockMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline RollupBlockMsg& operator=(RollupBlockMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RollupBlockMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const RollupBlockMsg* internal_default_instance() {
    return reinterpret_cast<const RollupBlockMsg*>(
               &_RollupBlockMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RollupBlockMsg& a, RollupBlockMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(RollupBlockMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RollupBlockMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RollupBlockMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RollupBlockMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RollupBlockMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RollupBlockMsg& from) {
    RollupBlockMsg::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RollupBlockMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.RollupBlockMsg";
  }
  protected:
  explicit RollupBlockMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.RollupBlockMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotRequest) */ {
 public:
  inline SnapshotRequest() : SnapshotRequest(nullptr) {}
  ~SnapshotRequest() override;
  explicit PROTOBUF_CONSTEXPR SnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotRequest(const SnapshotRequest& from);
  SnapshotRequest(SnapshotRequest&& from) noexcept
    : SnapshotRequest() {
    *this = ::std::move(from);
  }

  inline SnapshotRequest& operator=(const SnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotRequest& operator=(SnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const SnapshotRequest*>(
               &_SnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(SnapshotRequest& a, SnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotRequest& from) {
    SnapshotRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.SnapshotRequest";
  }
  protected:
  explicit SnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUntilHashFieldNumber = 1,
  };
  // string until_hash = 1;
  void clear_until_hash();
  const std::string& until_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_until_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_until_hash();
  PROTOBUF_NODISCARD std::string* release_until_hash();
  void set_allocated_until_hash(std::string* until_hash);
  private:
  const std::string& _internal_until_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_until_hash(const std::string& value);
  std::string* _internal_mutable_until_hash();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr until_hash_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TailBlocksRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.TailBlocksRequest) */ {
 public:
  inline TailBlocksRequest() : TailBlocksRequest(nullptr) {}
  ~TailBlocksRequest() override;
  explicit PROTOBUF_CONSTEXPR TailBlocksRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailBlocksRequest(const TailBlocksRequest& from);
  TailBlocksRequest(TailBlocksRequest&& from) noexcept
    : TailBlocksRequest() {
    *this = ::std::move(from);
  }

  inline TailBlocksRequest& operator=(const TailBlocksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailBlocksRequest& operator=(TailBlocksRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailBlocksRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailBlocksRequest* internal_default_instance() {
    return reinterpret_cast<const TailBlocksRequest*>(
               &_TailBlocksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TailBlocksRequest& a, TailBlocksRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TailBlocksRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailBlocksRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailBlocksRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailBlocksRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailBlocksRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TailBlocksRequest& from) {
    TailBlocksRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailBlocksRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.TailBlocksRequest";
  }
  protected:
  explicit TailBlocksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFromHeightFieldNumber = 1,
  };
  // uint64 from_height = 1;
  void clear_from_height();
  uint64_t from_height() const;
  void set_from_height(uint64_t value);
  private:
  uint64_t _internal_from_height() const;
  void _internal_set_from_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.TailBlocksRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t from_height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class GetData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.GetData) */ {
 public:
  inline GetData() : GetData(nullptr) {}
  ~GetData() override;
  explicit PROTOBUF_CONSTEXPR GetData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetData(const GetData& from);
  GetData(GetData&& from) noexcept
    : GetData() {
    *this = ::std::move(from);
  }

  inline GetData& operator=(const GetData& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetData& operator=(GetData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetData& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetData* internal_default_instance() {
    return reinterpret_cast<const GetData*>(
               &_GetData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetData& a, GetData& b) {
    a.Swap(&b);
  }
  inline void Swap(GetData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetData& from) {
    GetData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.GetData";
  }
  protected:
  explicit GetData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHashesFieldNumber = 1,
  };
  // repeated string hashes = 1;
  int hashes_size() const;
  private:
  int _internal_hashes_size() const;
  public:
  void clear_hashes();
  const std::string& hashes(int index) const;
  std::string* mutable_hashes(int index);
  void set_hashes(int index, const std::string& value);
  void set_hashes(int index, std::string&& value);
  void set_hashes(int index, const char* value);
  void set_hashes(int index, const char* value, size_t size);
  std::string* add_hashes();
  void add_hashes(const std::string& value);
  void add_hashes(std::string&& value);
  void add_hashes(const char* value);
  void add_hashes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& hashes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_hashes();
  private:
  const std::string& _internal_hashes(int index) const;
  std::string* _internal_add_hashes();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.GetData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> hashes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class StateProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.StateProof) */ {
 public:
  inline StateProof() : StateProof(nullptr) {}
  ~StateProof() override;
  explicit PROTOBUF_CONSTEXPR StateProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StateProof(const StateProof& from);
  StateProof(StateProof&& from) noexcept
    : StateProof() {
    *this = ::std::move(from);
  }

  inline StateProof& operator=(const StateProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline StateProof& operator=(StateProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StateProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const StateProof* internal_default_instance() {
    return reinterpret_cast<const StateProof*>(
               &_StateProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StateProof& a, StateProof& b) {
    a.Swap(&b);
  }
  inline void Swap(StateProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StateProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StateProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StateProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StateProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StateProof& from) {
    StateProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StateProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.StateProof";
  }
  protected:
  explicit StateProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProofFieldNumber = 1,
  };
  // .alyncoin.StateProofProto proof = 1;
  bool has_proof() const;
  private:
  bool _internal_has_proof() const;
  public:
  void clear_proof();
  const ::alyncoin::StateProofProto& proof() const;
  PROTOBUF_NODISCARD ::alyncoin::StateProofProto* release_proof();
  ::alyncoin::StateProofProto* mutable_proof();
  void set_allocated_proof(::alyncoin::StateProofProto* proof);
  private:
  const ::alyncoin::StateProofProto& _internal_proof() const;
  ::alyncoin::StateProofProto* _internal_mutable_proof();
  public:
  void unsafe_arena_set_allocated_proof(
      ::alyncoin::StateProofProto* proof);
  ::alyncoin::StateProofProto* unsafe_arena_release_proof();

  // @@protoc_insertion_point(class_scope:alyncoin.net.StateProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::alyncoin::StateProofProto* proof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TransactionBroadcast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.TransactionBroadcast) */ {
 public:
  inline TransactionBroadcast() : TransactionBroadcast(nullptr) {}
  ~TransactionBroadcast() override;
  explicit PROTOBUF_CONSTEXPR TransactionBroadcast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionBroadcast(const TransactionBroadcast& from);
  TransactionBroadcast(TransactionBroadcast&& from) noexcept
    : TransactionBroadcast() {
    *this = ::std::move(from);
  }

  inline TransactionBroadcast& operator=(const TransactionBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionBroadcast& operator=(TransactionBroadcast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionBroadcast& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionBroadcast* internal_default_instance() {
    return reinterpret_cast<const TransactionBroadcast*>(
               &_TransactionBroadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TransactionBroadcast& a, TransactionBroadcast& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionBroadcast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionBroadcast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransactionBroadcast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransactionBroadcast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionBroadcast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransactionBroadcast& from) {
    TransactionBroadcast::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionBroadcast* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.TransactionBroadcast";
  }
  protected:
  explicit TransactionBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTxFieldNumber = 1,
  };
  // .alyncoin.TransactionProto tx = 1;
  bool has_tx() const;
  private:
  bool _internal_has_tx() const;
  public:
  void clear_tx();
  const ::alyncoin::TransactionProto& tx() const;
  PROTOBUF_NODISCARD ::alyncoin::TransactionProto* release_tx();
  ::alyncoin::TransactionProto* mutable_tx();
  void set_allocated_tx(::alyncoin::TransactionProto* tx);
  private:
  const ::alyncoin::TransactionProto& _internal_tx() const;
  ::alyncoin::TransactionProto* _internal_mutable_tx();
  public:
  void unsafe_arena_set_allocated_tx(
      ::alyncoin::TransactionProto* tx);
  ::alyncoin::TransactionProto* unsafe_arena_release_tx();

  // @@protoc_insertion_point(class_scope:alyncoin.net.TransactionBroadcast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::alyncoin::TransactionProto* tx_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kHandshake = 1,
    kPing = 2,
    kPong = 3,
    kHeightReq = 4,
    kHeightRes = 5,
    kBlockBroadcast = 6,
    kBlockBatch = 7,
    kSnapshotChunk = 8,
    kSnapshotEnd = 9,
    kTailBlocks = 10,
    kAggProof = 11,
    kInv = 12,
    kTipHashReq = 13,
    kTipHashRes = 14,
    kPeerListReq = 15,
    kPeerList = 16,
    kRollupBlock = 17,
    kSnapshotReq = 18,
    kTailReq = 19,
    kStateProof = 20,
    kGetData = 21,
    kBlockchainSyncRequest = 22,
    kTxBroadcast = 23,
    KIND_NOT_SET = 0,
  };

  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandshakeFieldNumber = 1,
    kPingFieldNumber = 2,
    kPongFieldNumber = 3,
    kHeightReqFieldNumber = 4,
    kHeightResFieldNumber = 5,
    kBlockBroadcastFieldNumber = 6,
    kBlockBatchFieldNumber = 7,
    kSnapshotChunkFieldNumber = 8,
    kSnapshotEndFieldNumber = 9,
    kTailBlocksFieldNumber = 10,
    kAggProofFieldNumber = 11,
    kInvFieldNumber = 12,
    kTipHashReqFieldNumber = 13,
    kTipHashResFieldNumber = 14,
    kPeerListReqFieldNumber = 15,
    kPeerListFieldNumber = 16,
    kRollupBlockFieldNumber = 17,
    kSnapshotReqFieldNumber = 18,
    kTailReqFieldNumber = 19,
    kStateProofFieldNumber = 20,
    kGetDataFieldNumber = 21,
    kBlockchainSyncRequestFieldNumber = 22,
    kTxBroadcastFieldNumber = 23,
  };
  // .alyncoin.net.Handshake handshake = 1;
  bool has_handshake() const;
  private:
  bool _internal_has_handshake() const;
  public:
  void clear_handshake();
  const ::alyncoin::net::Handshake& handshake() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Handshake* release_handshake();
  ::alyncoin::net::Handshake* mutable_handshake();
  void set_allocated_handshake(::alyncoin::net::Handshake* handshake);
  private:
  const ::alyncoin::net::Handshake& _internal_handshake() const;
  ::alyncoin::net::Handshake* _internal_mutable_handshake();
  public:
  void unsafe_arena_set_allocated_handshake(
      ::alyncoin::net::Handshake* handshake);
  ::alyncoin::net::Handshake* unsafe_arena_release_handshake();

  // .alyncoin.net.Ping ping = 2;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::alyncoin::net::Ping& ping() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Ping* release_ping();
  ::alyncoin::net::Ping* mutable_ping();
  void set_allocated_ping(::alyncoin::net::Ping* ping);
  private:
  const ::alyncoin::net::Ping& _internal_ping() const;
  ::alyncoin::net::Ping* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::alyncoin::net::Ping* ping);
  ::alyncoin::net::Ping* unsafe_arena_release_ping();

  // .alyncoin.net.Pong pong = 3;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::alyncoin::net::Pong& pong() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Pong* release_pong();
  ::alyncoin::net::Pong* mutable_pong();
  void set_allocated_pong(::alyncoin::net::Pong* pong);
  private:
  const ::alyncoin::net::Pong& _internal_pong() const;
  ::alyncoin::net::Pong* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::alyncoin::net::Pong* pong);
  ::alyncoin::net::Pong* unsafe_arena_release_pong();

  // .alyncoin.net.HeightRequest height_req = 4;
  bool has_height_req() const;
  private:
  bool _internal_has_height_req() const;
  public:
  void clear_height_req();
  const ::alyncoin::net::HeightRequest& height_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightRequest* release_height_req();
  ::alyncoin::net::HeightRequest* mutable_height_req();
  void set_allocated_height_req(::alyncoin::net::HeightRequest* height_req);
  private:
  const ::alyncoin::net::HeightRequest& _internal_height_req() const;
  ::alyncoin::net::HeightRequest* _internal_mutable_height_req();
  public:
  void unsafe_arena_set_allocated_height_req(
      ::alyncoin::net::HeightRequest* height_req);
  ::alyncoin::net::HeightRequest* unsafe_arena_release_height_req();

  // .alyncoin.net.HeightResponse height_res = 5;
  bool has_height_res() const;
  private:
  bool _internal_has_height_res() const;
  public:
  void clear_height_res();
  const ::alyncoin::net::HeightResponse& height_res() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightResponse* release_height_res();
  ::alyncoin::net::HeightResponse* mutable_height_res();
  void set_allocated_height_res(::alyncoin::net::HeightResponse* height_res);
  private:
  const ::alyncoin::net::HeightResponse& _internal_height_res() const;
  ::alyncoin::net::HeightResponse* _internal_mutable_height_res();
  public:
  void unsafe_arena_set_allocated_height_res(
      ::alyncoin::net::HeightResponse* height_res);
  ::alyncoin::net::HeightResponse* unsafe_arena_release_height_res();

  // .alyncoin.net.BlockBroadcast block_broadcast = 6;
  bool has_block_broadcast() const;
  private:
  bool _internal_has_block_broadcast() const;
  public:
  void clear_block_broadcast();
  const ::alyncoin::net::BlockBroadcast& block_broadcast() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockBroadcast* release_block_broadcast();
  ::alyncoin::net::BlockBroadcast* mutable_block_broadcast();
  void set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* block_broadcast);
  private:
  const ::alyncoin::net::BlockBroadcast& _internal_block_broadcast() const;
  ::alyncoin::net::BlockBroadcast* _internal_mutable_block_broadcast();
  public:
  void unsafe_arena_set_allocated_block_broadcast(
      ::alyncoin::net::BlockBroadcast* block_broadcast);
  ::alyncoin::net::BlockBroadcast* unsafe_arena_release_block_broadcast();

  // .alyncoin.net.BlockBatch block_batch = 7;
  bool has_block_batch() const;
  private:
  bool _internal_has_block_batch() const;
  public:
  void clear_block_batch();
  const ::alyncoin::net::BlockBatch& block_batch() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockBatch* release_block_batch();
  ::alyncoin::net::BlockBatch* mutable_block_batch();
  void set_allocated_block_batch(::alyncoin::net::BlockBatch* block_batch);
  private:
  const ::alyncoin::net::BlockBatch& _internal_block_batch() const;
  ::alyncoin::net::BlockBatch* _internal_mutable_block_batch();
  public:
  void unsafe_arena_set_allocated_block_batch(
      ::alyncoin::net::BlockBatch* block_batch);
  ::alyncoin::net::BlockBatch* unsafe_arena_release_block_batch();

  // .alyncoin.net.SnapshotChunk snapshot_chunk = 8;
  bool has_snapshot_chunk() const;
  private:
  bool _internal_has_snapshot_chunk() const;
  public:
  void clear_snapshot_chunk();
  const ::alyncoin::net::SnapshotChunk& snapshot_chunk() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotChunk* release_snapshot_chunk();
  ::alyncoin::net::SnapshotChunk* mutable_snapshot_chunk();
  void set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* snapshot_chunk);
  private:
  const ::alyncoin::net::SnapshotChunk& _internal_snapshot_chunk() const;
  ::alyncoin::net::SnapshotChunk* _internal_mutable_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_snapshot_chunk(
      ::alyncoin::net::SnapshotChunk* snapshot_chunk);
  ::alyncoin::net::SnapshotChunk* unsafe_arena_release_snapshot_chunk();

  // .alyncoin.net.SnapshotEnd snapshot_end = 9;
  bool has_snapshot_end() const;
  private:
  bool _internal_has_snapshot_end() const;
  public:
  void clear_snapshot_end();
  const ::alyncoin::net::SnapshotEnd& snapshot_end() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotEnd* release_snapshot_end();
  ::alyncoin::net::SnapshotEnd* mutable_snapshot_end();
  void set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* snapshot_end);
  private:
  const ::alyncoin::net::SnapshotEnd& _internal_snapshot_end() const;
  ::alyncoin::net::SnapshotEnd* _internal_mutable_snapshot_end();
  public:
  void unsafe_arena_set_allocated_snapshot_end(
      ::alyncoin::net::SnapshotEnd* snapshot_end);
  ::alyncoin::net::SnapshotEnd* unsafe_arena_release_snapshot_end();

  // .alyncoin.net.TailBlocks tail_blocks = 10;
  bool has_tail_blocks() const;
  private:
  bool _internal_has_tail_blocks() const;
  public:
  void clear_tail_blocks();
  const ::alyncoin::net::TailBlocks& tail_blocks() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TailBlocks* release_tail_blocks();
  ::alyncoin::net::TailBlocks* mutable_tail_blocks();
  void set_allocated_tail_blocks(::alyncoin::net::TailBlocks* tail_blocks);
  private:
  const ::alyncoin::net::TailBlocks& _internal_tail_blocks() const;
  ::alyncoin::net::TailBlocks* _internal_mutable_tail_blocks();
  public:
  void unsafe_arena_set_allocated_tail_blocks(
      ::alyncoin::net::TailBlocks* tail_blocks);
  ::alyncoin::net::TailBlocks* unsafe_arena_release_tail_blocks();

  // .alyncoin.net.EpochProof agg_proof = 11;
  bool has_agg_proof() const;
  private:
  bool _internal_has_agg_proof() const;
  public:
  void clear_agg_proof();
  const ::alyncoin::net::EpochProof& agg_proof() const;
  PROTOBUF_NODISCARD ::alyncoin::net::EpochProof* release_agg_proof();
  ::alyncoin::net::EpochProof* mutable_agg_proof();
  void set_allocated_agg_proof(::alyncoin::net::EpochProof* agg_proof);
  private:
  const ::alyncoin::net::EpochProof& _internal_agg_proof() const;
  ::alyncoin::net::EpochProof* _internal_mutable_agg_proof();
  public:
  void unsafe_arena_set_allocated_agg_proof(
      ::alyncoin::net::EpochProof* agg_proof);
  ::alyncoin::net::EpochProof* unsafe_arena_release_agg_proof();

  // .alyncoin.net.Inventory inv = 12;
  bool has_inv() const;
  private:
  bool _internal_has_inv() const;
  public:
  void clear_inv();
  const ::alyncoin::net::Inventory& inv() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Inventory* release_inv();
  ::alyncoin::net::Inventory* mutable_inv();
  void set_allocated_inv(::alyncoin::net::Inventory* inv);
  private:
  const ::alyncoin::net::Inventory& _internal_inv() const;
  ::alyncoin::net::Inventory* _internal_mutable_inv();
  public:
  void unsafe_arena_set_allocated_inv(
      ::alyncoin::net::Inventory* inv);
  ::alyncoin::net::Inventory* unsafe_arena_release_inv();

  // .alyncoin.net.TipHashRequest tip_hash_req = 13;
  bool has_tip_hash_req() const;
  private:
  bool _internal_has_tip_hash_req() const;
  public:
  void clear_tip_hash_req();
  const ::alyncoin::net::TipHashRequest& tip_hash_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TipHashRequest* release_tip_hash_req();
  ::alyncoin::net::TipHashRequest* mutable_tip_hash_req();
  void set_allocated_tip_hash_req(::alyncoin::net::TipHashRequest* tip_hash_req);
  private:
  const ::alyncoin::net::TipHashRequest& _internal_tip_hash_req() const;
  ::alyncoin::net::TipHashRequest* _internal_mutable_tip_hash_req();
  public:
  void unsafe_arena_set_allocated_tip_hash_req(
      ::alyncoin::net::TipHashRequest* tip_hash_req);
  ::alyncoin::net::TipHashRequest* unsafe_arena_release_tip_hash_req();

  // .alyncoin.net.TipHashResponse tip_hash_res = 14;
  bool has_tip_hash_res() const;
  private:
  bool _internal_has_tip_hash_res() const;
  public:
  void clear_tip_hash_res();
  const ::alyncoin::net::TipHashResponse& tip_hash_res() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TipHashResponse* release_tip_hash_res();
  ::alyncoin::net::TipHashResponse* mutable_tip_hash_res();
  void set_allocated_tip_hash_res(::alyncoin::net::TipHashResponse* tip_hash_res);
  private:
  const ::alyncoin::net::TipHashResponse& _internal_tip_hash_res() const;
  ::alyncoin::net::TipHashResponse* _internal_mutable_tip_hash_res();
  public:
  void unsafe_arena_set_allocated_tip_hash_res(
      ::alyncoin::net::TipHashResponse* tip_hash_res);
  ::alyncoin::net::TipHashResponse* unsafe_arena_release_tip_hash_res();

  // .alyncoin.net.PeerListRequest peer_list_req = 15;
  bool has_peer_list_req() const;
  private:
  bool _internal_has_peer_list_req() const;
  public:
  void clear_peer_list_req();
  const ::alyncoin::net::PeerListRequest& peer_list_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::PeerListRequest* release_peer_list_req();
  ::alyncoin::net::PeerListRequest* mutable_peer_list_req();
  void set_allocated_peer_list_req(::alyncoin::net::PeerListRequest* peer_list_req);
  private:
  const ::alyncoin::net::PeerListRequest& _internal_peer_list_req() const;
  ::alyncoin::net::PeerListRequest* _internal_mutable_peer_list_req();
  public:
  void unsafe_arena_set_allocated_peer_list_req(
      ::alyncoin::net::PeerListRequest* peer_list_req);
  ::alyncoin::net::PeerListRequest* unsafe_arena_release_peer_list_req();

  // .alyncoin.net.PeerList peer_list = 16;
  bool has_peer_list() const;
  private:
  bool _internal_has_peer_list() const;
  public:
  void clear_peer_list();
  const ::alyncoin::net::PeerList& peer_list() const;
  PROTOBUF_NODISCARD ::alyncoin::net::PeerList* release_peer_list();
  ::alyncoin::net::PeerList* mutable_peer_list();
  void set_allocated_peer_list(::alyncoin::net::PeerList* peer_list);
  private:
  const ::alyncoin::net::PeerList& _internal_peer_list() const;
  ::alyncoin::net::PeerList* _internal_mutable_peer_list();
  public:
  void unsafe_arena_set_allocated_peer_list(
      ::alyncoin::net::PeerList* peer_list);
  ::alyncoin::net::PeerList* unsafe_arena_release_peer_list();

  // .alyncoin.net.RollupBlockMsg rollup_block = 17;
  bool has_rollup_block() const;
  private:
  bool _internal_has_rollup_block() const;
  public:
  void clear_rollup_block();
  const ::alyncoin::net::RollupBlockMsg& rollup_block() const;
  PROTOBUF_NODISCARD ::alyncoin::net::RollupBlockMsg* release_rollup_block();
  ::alyncoin::net::RollupBlockMsg* mutable_rollup_block();
  void set_allocated_rollup_block(::alyncoin::net::RollupBlockMsg* rollup_block);
  private:
  const ::alyncoin::net::RollupBlockMsg& _internal_rollup_block() const;
  ::alyncoin::net::RollupBlockMsg* _internal_mutable_rollup_block();
  public:
  void unsafe_arena_set_allocated_rollup_block(
      ::alyncoin::net::RollupBlockMsg* rollup_block);
  ::alyncoin::net::RollupBlockMsg* unsafe_arena_release_rollup_block();

  // .alyncoin.net.SnapshotRequest snapshot_req = 18;
  bool has_snapshot_req() const;
  private:
  bool _internal_has_snapshot_req() const;
  public:
  void clear_snapshot_req();
  const ::alyncoin::net::SnapshotRequest& snapshot_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotRequest* release_snapshot_req();
  ::alyncoin::net::SnapshotRequest* mutable_snapshot_req();
  void set_allocated_snapshot_req(::alyncoin::net::SnapshotRequest* snapshot_req);
  private:
  const ::alyncoin::net::SnapshotRequest& _internal_snapshot_req() const;
  ::alyncoin::net::SnapshotRequest* _internal_mutable_snapshot_req();
  public:
  void unsafe_arena_set_allocated_snapshot_req(
      ::alyncoin::net::SnapshotRequest* snapshot_req);
  ::alyncoin::net::SnapshotRequest* unsafe_arena_release_snapshot_req();

  // .alyncoin.net.TailBlocksRequest tail_req = 19;
  bool has_tail_req() const;
  private:
  bool _internal_has_tail_req() const;
  public:
  void clear_tail_req();
  const ::alyncoin::net::TailBlocksRequest& tail_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TailBlocksRequest* release_tail_req();
  ::alyncoin::net::TailBlocksRequest* mutable_tail_req();
  void set_allocated_tail_req(::alyncoin::net::TailBlocksRequest* tail_req);
  private:
  const ::alyncoin::net::TailBlocksRequest& _internal_tail_req() const;
  ::alyncoin::net::TailBlocksRequest* _internal_mutable_tail_req();
  public:
  void unsafe_arena_set_allocated_tail_req(
      ::alyncoin::net::TailBlocksRequest* tail_req);
  ::alyncoin::net::TailBlocksRequest* unsafe_arena_release_tail_req();

  // .alyncoin.net.StateProof state_proof = 20;
  bool has_state_proof() const;
  private:
  bool _internal_has_state_proof() const;
  public:
  void clear_state_proof();
  const ::alyncoin::net::StateProof& state_proof() const;
  PROTOBUF_NODISCARD ::alyncoin::net::StateProof* release_state_proof();
  ::alyncoin::net::StateProof* mutable_state_proof();
  void set_allocated_state_proof(::alyncoin::net::StateProof* state_proof);
  private:
  const ::alyncoin::net::StateProof& _internal_state_proof() const;
  ::alyncoin::net::StateProof* _internal_mutable_state_proof();
  public:
  void unsafe_arena_set_allocated_state_proof(
      ::alyncoin::net::StateProof* state_proof);
  ::alyncoin::net::StateProof* unsafe_arena_release_state_proof();

  // .alyncoin.net.GetData get_data = 21;
  bool has_get_data() const;
  private:
  bool _internal_has_get_data() const;
  public:
  void clear_get_data();
  const ::alyncoin::net::GetData& get_data() const;
  PROTOBUF_NODISCARD ::alyncoin::net::GetData* release_get_data();
  ::alyncoin::net::GetData* mutable_get_data();
  void set_allocated_get_data(::alyncoin::net::GetData* get_data);
  private:
  const ::alyncoin::net::GetData& _internal_get_data() const;
  ::alyncoin::net::GetData* _internal_mutable_get_data();
  public:
  void unsafe_arena_set_allocated_get_data(
      ::alyncoin::net::GetData* get_data);
  ::alyncoin::net::GetData* unsafe_arena_release_get_data();

  // .alyncoin.BlockchainSyncProto blockchain_sync_request = 22;
  bool has_blockchain_sync_request() const;
  private:
  bool _internal_has_blockchain_sync_request() const;
  public:
  void clear_blockchain_sync_request();
  const ::alyncoin::BlockchainSyncProto& blockchain_sync_request() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockchainSyncProto* release_blockchain_sync_request();
  ::alyncoin::BlockchainSyncProto* mutable_blockchain_sync_request();
  void set_allocated_blockchain_sync_request(::alyncoin::BlockchainSyncProto* blockchain_sync_request);
  private:
  const ::alyncoin::BlockchainSyncProto& _internal_blockchain_sync_request() const;
  ::alyncoin::BlockchainSyncProto* _internal_mutable_blockchain_sync_request();
  public:
  void unsafe_arena_set_allocated_blockchain_sync_request(
      ::alyncoin::BlockchainSyncProto* blockchain_sync_request);
  ::alyncoin::BlockchainSyncProto* unsafe_arena_release_blockchain_sync_request();

  // .alyncoin.net.TransactionBroadcast tx_broadcast = 23;
  bool has_tx_broadcast() const;
  private:
  bool _internal_has_tx_broadcast() const;
  public:
  void clear_tx_broadcast();
  const ::alyncoin::net::TransactionBroadcast& tx_broadcast() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TransactionBroadcast* release_tx_broadcast();
  ::alyncoin::net::TransactionBroadcast* mutable_tx_broadcast();
  void set_allocated_tx_broadcast(::alyncoin::net::TransactionBroadcast* tx_broadcast);
  private:
  const ::alyncoin::net::TransactionBroadcast& _internal_tx_broadcast() const;
  ::alyncoin::net::TransactionBroadcast* _internal_mutable_tx_broadcast();
  public:
  void unsafe_arena_set_allocated_tx_broadcast(
      ::alyncoin::net::TransactionBroadcast* tx_broadcast);
  ::alyncoin::net::TransactionBroadcast* unsafe_arena_release_tx_broadcast();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:alyncoin.net.Frame)
 private:
  class _Internal;
  void set_has_handshake();
  void set_has_ping();
  void set_has_pong();
  void set_has_height_req();
  void set_has_height_res();
  void set_has_block_broadcast();
  void set_has_block_batch();
  void set_has_snapshot_chunk();
  void set_has_snapshot_end();
  void set_has_tail_blocks();
  void set_has_agg_proof();
  void set_has_inv();
  void set_has_tip_hash_req();
  void set_has_tip_hash_res();
  void set_has_peer_list_req();
  void set_has_peer_list();
  void set_has_rollup_block();
  void set_has_snapshot_req();
  void set_has_tail_req();
  void set_has_state_proof();
  void set_has_get_data();
  void set_has_blockchain_sync_request();
  void set_has_tx_broadcast();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::alyncoin::net::Handshake* handshake_;
      ::alyncoin::net::Ping* ping_;
      ::alyncoin::net::Pong* pong_;
      ::alyncoin::net::HeightRequest* height_req_;
      ::alyncoin::net::HeightResponse* height_res_;
      ::alyncoin::net::BlockBroadcast* block_broadcast_;
      ::alyncoin::net::BlockBatch* block_batch_;
      ::alyncoin::net::SnapshotChunk* snapshot_chunk_;
      ::alyncoin::net::SnapshotEnd* snapshot_end_;
      ::alyncoin::net::TailBlocks* tail_blocks_;
      ::alyncoin::net::EpochProof* agg_proof_;
      ::alyncoin::net::Inventory* inv_;
      ::alyncoin::net::TipHashRequest* tip_hash_req_;
      ::alyncoin::net::TipHashResponse* tip_hash_res_;
      ::alyncoin::net::PeerListRequest* peer_list_req_;
      ::alyncoin::net::PeerList* peer_list_;
      ::alyncoin::net::RollupBlockMsg* rollup_block_;
      ::alyncoin::net::SnapshotRequest* snapshot_req_;
      ::alyncoin::net::TailBlocksRequest* tail_req_;
      ::alyncoin::net::StateProof* state_proof_;
      ::alyncoin::net::GetData* get_data_;
      ::alyncoin::BlockchainSyncProto* blockchain_sync_request_;
      ::alyncoin::net::TransactionBroadcast* tx_broadcast_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Handshake

// string version = 1;
inline void Handshake::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Handshake::version() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Handshake::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.version)
}
inline std::string* Handshake::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.version)
  return _s;
}
inline const std::string& Handshake::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Handshake::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Handshake::release_version() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.version)
  return _impl_.version_.Release();
}
inline void Handshake::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.version)
}

// string network_id = 2;
inline void Handshake::clear_network_id() {
  _impl_.network_id_.ClearToEmpty();
}
inline const std::string& Handshake::network_id() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.network_id)
  return _internal_network_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Handshake::set_network_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.network_id)
}
inline std::string* Handshake::mutable_network_id() {
  std::string* _s = _internal_mutable_network_id();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.network_id)
  return _s;
}
inline const std::string& Handshake::_internal_network_id() const {
  return _impl_.network_id_.Get();
}
inline void Handshake::_internal_set_network_id(const std::string& value) {
  
  _impl_.network_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_network_id() {
  
  return _impl_.network_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Handshake::release_network_id() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.network_id)
  return _impl_.network_id_.Release();
}
inline void Handshake::set_allocated_network_id(std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  _impl_.network_id_.SetAllocated(network_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_id_.IsDefault()) {
    _impl_.network_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.network_id)
}

// uint64 height = 3;
inline void Handshake::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t Handshake::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t Handshake::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.height)
  return _internal_height();
}
inline void Handshake::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void Handshake::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.height)
}

// uint32 listen_port = 4;
inline void Handshake::clear_listen_port() {
  _impl_.listen_port_ = 0u;
}
inline uint32_t Handshake::_internal_listen_port() const {
  return _impl_.listen_port_;
}
inline uint32_t Handshake::listen_port() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.listen_port)
  return _internal_listen_port();
}
inline void Handshake::_internal_set_listen_port(uint32_t value) {
  
  _impl_.listen_port_ = value;
}
inline void Handshake::set_listen_port(uint32_t value) {
  _internal_set_listen_port(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.listen_port)
}

// bytes genesis_hash = 5;
inline void Handshake::clear_genesis_hash() {
  _impl_.genesis_hash_.ClearToEmpty();
}
inline const std::string& Handshake::genesis_hash() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.genesis_hash)
  return _internal_genesis_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Handshake::set_genesis_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.genesis_hash_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.genesis_hash)
}
inline std::string* Handshake::mutable_genesis_hash() {
  std::string* _s = _internal_mutable_genesis_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.genesis_hash)
  return _s;
}
inline const std::string& Handshake::_internal_genesis_hash() const {
  return _impl_.genesis_hash_.Get();
}
inline void Handshake::_internal_set_genesis_hash(const std::string& value) {
  
  _impl_.genesis_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_genesis_hash() {
  
  return _impl_.genesis_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* Handshake::release_genesis_hash() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.genesis_hash)
  return _impl_.genesis_hash_.Release();
}
inline void Handshake::set_allocated_genesis_hash(std::string* genesis_hash) {
  if (genesis_hash != nullptr) {
    
  } else {
    
  }
  _impl_.genesis_hash_.SetAllocated(genesis_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.genesis_hash_.IsDefault()) {
    _impl_.genesis_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.genesis_hash)
}

// repeated string capabilities = 6;
inline int Handshake::_internal_capabilities_size() const {
  return _impl_.capabilities_.size();
}
inline int Handshake::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void Handshake::clear_capabilities() {
  _impl_.capabilities_.Clear();
}
inline std::string* Handshake::add_capabilities() {
  std::string* _s = _internal_add_capabilities();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.Handshake.capabilities)
  return _s;
}
inline const std::string& Handshake::_internal_capabilities(int index) const {
  return _impl_.capabilities_.Get(index);
}
inline const std::string& Handshake::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.capabilities)
  return _internal_capabilities(index);
}
inline std::string* Handshake::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.capabilities)
  return _impl_.capabilities_.Mutable(index);
}
inline void Handshake::set_capabilities(int index, const std::string& value) {
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::set_capabilities(int index, std::string&& value) {
  _impl_.capabilities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::set_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::set_capabilities(int index, const char* value, size_t size) {
  _impl_.capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alyncoin.net.Handshake.capabilities)
}
inline std::string* Handshake::_internal_add_capabilities() {
  return _impl_.capabilities_.Add();
}
inline void Handshake::add_capabilities(const std::string& value) {
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::add_capabilities(std::string&& value) {
  _impl_.capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::add_capabilities(const char* value, size_t size) {
  _impl_.capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alyncoin.net.Handshake.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Handshake::capabilities() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.Handshake.capabilities)
  return _impl_.capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Handshake::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.Handshake.capabilities)
  return &_impl_.capabilities_;
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// -------------------------------------------------------------------

// HeightRequest

// -------------------------------------------------------------------

// HeightResponse

// uint64 height = 1;
inline void HeightResponse::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t HeightResponse::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t HeightResponse::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightResponse.height)
  return _internal_height();
}
inline void HeightResponse::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void HeightResponse::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightResponse.height)
}

// -------------------------------------------------------------------

// BlockBroadcast

// .alyncoin.BlockProto block = 1;
inline bool BlockBroadcast::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool BlockBroadcast::has_block() const {
  return _internal_has_block();
}
inline const ::alyncoin::BlockProto& BlockBroadcast::_internal_block() const {
  const ::alyncoin::BlockProto* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockProto&>(
      ::alyncoin::_BlockProto_default_instance_);
}
inline const ::alyncoin::BlockProto& BlockBroadcast::block() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockBroadcast.block)
  return _internal_block();
}
inline void BlockBroadcast::unsafe_arena_set_allocated_block(
    ::alyncoin::BlockProto* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockBroadcast.block)
}
inline ::alyncoin::BlockProto* BlockBroadcast::release_block() {
  
  ::alyncoin::BlockProto* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alyncoin::BlockProto* BlockBroadcast::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockBroadcast.block)
  
  ::alyncoin::BlockProto* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockProto* BlockBroadcast::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::alyncoin::BlockProto>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::alyncoin::BlockProto* BlockBroadcast::mutable_block() {
  ::alyncoin::BlockProto* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockBroadcast.block)
  return _msg;
}
inline void BlockBroadcast::set_allocated_block(::alyncoin::BlockProto* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockBroadcast.block)
}

// -------------------------------------------------------------------

// BlockBatch

// .alyncoin.BlockchainProto chain = 1;
inline bool BlockBatch::_internal_has_chain() const {
  return this != internal_default_instance() && _impl_.chain_ != nullptr;
}
inline bool BlockBatch::has_chain() const {
  return _internal_has_chain();
}
inline const ::alyncoin::BlockchainProto& BlockBatch::_internal_chain() const {
  const ::alyncoin::BlockchainProto* p = _impl_.chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockchainProto&>(
      ::alyncoin::_BlockchainProto_default_instance_);
}
inline const ::alyncoin::BlockchainProto& BlockBatch::chain() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockBatch.chain)
  return _internal_chain();
}
inline void BlockBatch::unsafe_arena_set_allocated_chain(
    ::alyncoin::BlockchainProto* chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chain_);
  }
  _impl_.chain_ = chain;
  if (chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockBatch.chain)
}
inline ::alyncoin::BlockchainProto* BlockBatch::release_chain() {
  
  ::alyncoin::BlockchainProto* temp = _impl_.chain_;
  _impl_.chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alyncoin::BlockchainProto* BlockBatch::unsafe_arena_release_chain() {
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockBatch.chain)
  
  ::alyncoin::BlockchainProto* temp = _impl_.chain_;
  _impl_.chain_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockchainProto* BlockBatch::_internal_mutable_chain() {
  
  if (_impl_.chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::alyncoin::BlockchainProto>(GetArenaForAllocation());
    _impl_.chain_ = p;
  }
  return _impl_.chain_;
}
inline ::alyncoin::BlockchainProto* BlockBatch::mutable_chain() {
  ::alyncoin::BlockchainProto* _msg = _internal_mutable_chain();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockBatch.chain)
  return _msg;
}
inline void BlockBatch::set_allocated_chain(::alyncoin::BlockchainProto* chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chain_);
  }
  if (chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chain));
    if (message_arena != submessage_arena) {
      chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chain, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chain_ = chain;
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockBatch.chain)
}

// -------------------------------------------------------------------

// SnapshotChunk

// bytes data = 1;
inline void SnapshotChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SnapshotChunk::data() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnapshotChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotChunk.data)
}
inline std::string* SnapshotChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.SnapshotChunk.data)
  return _s;
}
inline const std::string& SnapshotChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SnapshotChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SnapshotChunk::release_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.SnapshotChunk.data)
  return _impl_.data_.Release();
}
inline void SnapshotChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.SnapshotChunk.data)
}

// -------------------------------------------------------------------

// SnapshotEnd

// -------------------------------------------------------------------

// TailBlocks

// repeated .alyncoin.BlockProto blocks = 1;
inline int TailBlocks::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int TailBlocks::blocks_size() const {
  return _internal_blocks_size();
}
inline ::alyncoin::BlockProto* TailBlocks::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TailBlocks.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >*
TailBlocks::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.TailBlocks.blocks)
  return &_impl_.blocks_;
}
inline const ::alyncoin::BlockProto& TailBlocks::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::alyncoin::BlockProto& TailBlocks::blocks(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.TailBlocks.blocks)
  return _internal_blocks(index);
}
inline ::alyncoin::BlockProto* TailBlocks::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::alyncoin::BlockProto* TailBlocks::add_blocks() {
  ::alyncoin::BlockProto* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:alyncoin.net.TailBlocks.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >&
TailBlocks::blocks() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.TailBlocks.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// EpochProof

// bytes data = 1;
inline void EpochProof::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& EpochProof::data() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.EpochProof.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EpochProof::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.EpochProof.data)
}
inline std::string* EpochProof::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.EpochProof.data)
  return _s;
}
inline const std::string& EpochProof::_internal_data() const {
  return _impl_.data_.Get();
}
inline void EpochProof::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* EpochProof::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* EpochProof::release_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.EpochProof.data)
  return _impl_.data_.Release();
}
inline void EpochProof::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.EpochProof.data)
}

// -------------------------------------------------------------------

// Inventory

// repeated string hashes = 1;
inline int Inventory::_internal_hashes_size() const {
  return _impl_.hashes_.size();
}
inline int Inventory::hashes_size() const {
  return _internal_hashes_size();
}
inline void Inventory::clear_hashes() {
  _impl_.hashes_.Clear();
}
inline std::string* Inventory::add_hashes() {
  std::string* _s = _internal_add_hashes();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.Inventory.hashes)
  return _s;
}
inline const std::string& Inventory::_internal_hashes(int index) const {
  return _impl_.hashes_.Get(index);
}
inline const std::string& Inventory::hashes(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Inventory.hashes)
  return _internal_hashes(index);
}
inline std::string* Inventory::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Inventory.hashes)
  return _impl_.hashes_.Mutable(index);
}
inline void Inventory::set_hashes(int index, const std::string& value) {
  _impl_.hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Inventory.hashes)
}
inline void Inventory::set_hashes(int index, std::string&& value) {
  _impl_.hashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alyncoin.net.Inventory.hashes)
}
inline void Inventory::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alyncoin.net.Inventory.hashes)
}
inline void Inventory::set_hashes(int index, const char* value, size_t size) {
  _impl_.hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alyncoin.net.Inventory.hashes)
}
inline std::string* Inventory::_internal_add_hashes() {
  return _impl_.hashes_.Add();
}
inline void Inventory::add_hashes(const std::string& value) {
  _impl_.hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alyncoin.net.Inventory.hashes)
}
inline void Inventory::add_hashes(std::string&& value) {
  _impl_.hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alyncoin.net.Inventory.hashes)
}
inline void Inventory::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alyncoin.net.Inventory.hashes)
}
inline void Inventory::add_hashes(const char* value, size_t size) {
  _impl_.hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alyncoin.net.Inventory.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Inventory::hashes() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.Inventory.hashes)
  return _impl_.hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Inventory::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.Inventory.hashes)
  return &_impl_.hashes_;
}

// -------------------------------------------------------------------

// TipHashRequest

// -------------------------------------------------------------------

// TipHashResponse

// string hash = 1;
inline void TipHashResponse::clear_hash() {
  _impl_.hash_.ClearToEmpty();
}
inline const std::string& TipHashResponse::hash() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.TipHashResponse.hash)
  return _internal_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TipHashResponse::set_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.TipHashResponse.hash)
}
inline std::string* TipHashResponse::mutable_hash() {
  std::string* _s = _internal_mutable_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TipHashResponse.hash)
  return _s;
}
inline const std::string& TipHashResponse::_internal_hash() const {
  return _impl_.hash_.Get();
}
inline void TipHashResponse::_internal_set_hash(const std::string& value) {
  
  _impl_.hash_.Set(value, GetArenaForAllocation());
}
inline std::string* TipHashResponse::_internal_mutable_hash() {
  
  return _impl_.hash_.Mutable(GetArenaForAllocation());
}
inline std::string* TipHashResponse::release_hash() {
  // @@protoc_insertion_point(field_release:alyncoin.net.TipHashResponse.hash)
  return _impl_.hash_.Release();
}
inline void TipHashResponse::set_allocated_hash(std::string* hash) {
  if (hash != nullptr) {
    
  } else {
    
  }
  _impl_.hash_.SetAllocated(hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hash_.IsDefault()) {
    _impl_.hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.TipHashResponse.hash)
}

// -------------------------------------------------------------------

// PeerListRequest

// -------------------------------------------------------------------

// PeerList

// repeated string peers = 1;
inline int PeerList::_internal_peers_size() const {
  return _impl_.peers_.size();
}
inline int PeerList::peers_size() const {
  return _internal_peers_size();
}
inline void PeerList::clear_peers() {
  _impl_.peers_.Clear();
}
inline std::string* PeerList::add_peers() {
  std::string* _s = _internal_add_peers();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.PeerList.peers)
  return _s;
}
inline const std::string& PeerList::_internal_peers(int index) const {
  return _impl_.peers_.Get(index);
}
inline const std::string& PeerList::peers(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.PeerList.peers)
  return _internal_peers(index);
}
inline std::string* PeerList::mutable_peers(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.PeerList.peers)
  return _impl_.peers_.Mutable(index);
}
inline void PeerList::set_peers(int index, const std::string& value) {
  _impl_.peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.PeerList.peers)
}
inline void PeerList::set_peers(int index, std::string&& value) {
  _impl_.peers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alyncoin.net.PeerList.peers)
}
inline void PeerList::set_peers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.peers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alyncoin.net.PeerList.peers)
}
inline void PeerList::set_peers(int index, const char* value, size_t size) {
  _impl_.peers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alyncoin.net.PeerList.peers)
}
inline std::string* PeerList::_internal_add_peers() {
  return _impl_.peers_.Add();
}
inline void PeerList::add_peers(const std::string& value) {
  _impl_.peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alyncoin.net.PeerList.peers)
}
inline void PeerList::add_peers(std::string&& value) {
  _impl_.peers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alyncoin.net.PeerList.peers)
}
inline void PeerList::add_peers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.peers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alyncoin.net.PeerList.peers)
}
inline void PeerList::add_peers(const char* value, size_t size) {
  _impl_.peers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alyncoin.net.PeerList.peers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
PeerList::peers() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.PeerList.peers)
  return _impl_.peers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
PeerList::mutable_peers() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.PeerList.peers)
  return &_impl_.peers_;
}

// -------------------------------------------------------------------

// RollupBlockMsg

// bytes data = 1;
inline void RollupBlockMsg::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& RollupBlockMsg::data() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.RollupBlockMsg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RollupBlockMsg::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.RollupBlockMsg.data)
}
inline std::string* RollupBlockMsg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.RollupBlockMsg.data)
  return _s;
}
inline const std::string& RollupBlockMsg::_internal_data() const {
  return _impl_.data_.Get();
}
inline void RollupBlockMsg::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* RollupBlockMsg::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* RollupBlockMsg::release_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.RollupBlockMsg.data)
  return _impl_.data_.Release();
}
inline void RollupBlockMsg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.RollupBlockMsg.data)
}

// -------------------------------------------------------------------

// SnapshotRequest

// string until_hash = 1;
inline void SnapshotRequest::clear_until_hash() {
  _impl_.until_hash_.ClearToEmpty();
}
inline const std::string& SnapshotRequest::until_hash() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotRequest.until_hash)
  return _internal_until_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnapshotRequest::set_until_hash(ArgT0&& arg0, ArgT... args) {
 
 _impl_.until_hash_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotRequest.until_hash)
}
inline std::string* SnapshotRequest::mutable_until_hash() {
  std::string* _s = _internal_mutable_until_hash();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.SnapshotRequest.until_hash)
  return _s;
}
inline const std::string& SnapshotRequest::_internal_until_hash() const {
  return _impl_.until_hash_.Get();
}
inline void SnapshotRequest::_internal_set_until_hash(const std::string& value) {
  
  _impl_.until_hash_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotRequest::_internal_mutable_until_hash() {
  
  return _impl_.until_hash_.Mutable(GetArenaForAllocation());
}
inline std::string* SnapshotRequest::release_until_hash() {
  // @@protoc_insertion_point(field_release:alyncoin.net.SnapshotRequest.until_hash)
  return _impl_.until_hash_.Release();
}
inline void SnapshotRequest::set_allocated_until_hash(std::string* until_hash) {
  if (until_hash != nullptr) {
    
  } else {
    
  }
  _impl_.until_hash_.SetAllocated(until_hash, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.until_hash_.IsDefault()) {
    _impl_.until_hash_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.SnapshotRequest.until_hash)
}

// -------------------------------------------------------------------

// TailBlocksRequest

// uint64 from_height = 1;
inline void TailBlocksRequest::clear_from_height() {
  _impl_.from_height_ = uint64_t{0u};
}
inline uint64_t TailBlocksRequest::_internal_from_height() const {
  return _impl_.from_height_;
}
inline uint64_t TailBlocksRequest::from_height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.TailBlocksRequest.from_height)
  return _internal_from_height();
}
inline void TailBlocksRequest::_internal_set_from_height(uint64_t value) {
  
  _impl_.from_height_ = value;
}
inline void TailBlocksRequest::set_from_height(uint64_t value) {
  _internal_set_from_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.TailBlocksRequest.from_height)
}

// -------------------------------------------------------------------

// GetData

// repeated string hashes = 1;
inline int GetData::_internal_hashes_size() const {
  return _impl_.hashes_.size();
}
inline int GetData::hashes_size() const {
  return _internal_hashes_size();
}
inline void GetData::clear_hashes() {
  _impl_.hashes_.Clear();
}
inline std::string* GetData::add_hashes() {
  std::string* _s = _internal_add_hashes();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.GetData.hashes)
  return _s;
}
inline const std::string& GetData::_internal_hashes(int index) const {
  return _impl_.hashes_.Get(index);
}
inline const std::string& GetData::hashes(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.GetData.hashes)
  return _internal_hashes(index);
}
inline std::string* GetData::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.GetData.hashes)
  return _impl_.hashes_.Mutable(index);
}
inline void GetData::set_hashes(int index, const std::string& value) {
  _impl_.hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.GetData.hashes)
}
inline void GetData::set_hashes(int index, std::string&& value) {
  _impl_.hashes_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alyncoin.net.GetData.hashes)
}
inline void GetData::set_hashes(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hashes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alyncoin.net.GetData.hashes)
}
inline void GetData::set_hashes(int index, const char* value, size_t size) {
  _impl_.hashes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alyncoin.net.GetData.hashes)
}
inline std::string* GetData::_internal_add_hashes() {
  return _impl_.hashes_.Add();
}
inline void GetData::add_hashes(const std::string& value) {
  _impl_.hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alyncoin.net.GetData.hashes)
}
inline void GetData::add_hashes(std::string&& value) {
  _impl_.hashes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alyncoin.net.GetData.hashes)
}
inline void GetData::add_hashes(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.hashes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alyncoin.net.GetData.hashes)
}
inline void GetData::add_hashes(const char* value, size_t size) {
  _impl_.hashes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alyncoin.net.GetData.hashes)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetData::hashes() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.GetData.hashes)
  return _impl_.hashes_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetData::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.GetData.hashes)
  return &_impl_.hashes_;
}

// -------------------------------------------------------------------

// StateProof

// .alyncoin.StateProofProto proof = 1;
inline bool StateProof::_internal_has_proof() const {
  return this != internal_default_instance() && _impl_.proof_ != nullptr;
}
inline bool StateProof::has_proof() const {
  return _internal_has_proof();
}
inline const ::alyncoin::StateProofProto& StateProof::_internal_proof() const {
  const ::alyncoin::StateProofProto* p = _impl_.proof_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::StateProofProto&>(
      ::alyncoin::_StateProofProto_default_instance_);
}
inline const ::alyncoin::StateProofProto& StateProof::proof() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.StateProof.proof)
  return _internal_proof();
}
inline void StateProof::unsafe_arena_set_allocated_proof(
    ::alyncoin::StateProofProto* proof) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_);
  }
  _impl_.proof_ = proof;
  if (proof) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.StateProof.proof)
}
inline ::alyncoin::StateProofProto* StateProof::release_proof() {
  
  ::alyncoin::StateProofProto* temp = _impl_.proof_;
  _impl_.proof_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alyncoin::StateProofProto* StateProof::unsafe_arena_release_proof() {
  // @@protoc_insertion_point(field_release:alyncoin.net.StateProof.proof)
  
  ::alyncoin::StateProofProto* temp = _impl_.proof_;
  _impl_.proof_ = nullptr;
  return temp;
}
inline ::alyncoin::StateProofProto* StateProof::_internal_mutable_proof() {
  
  if (_impl_.proof_ == nullptr) {
    auto* p = CreateMaybeMessage<::alyncoin::StateProofProto>(GetArenaForAllocation());
    _impl_.proof_ = p;
  }
  return _impl_.proof_;
}
inline ::alyncoin::StateProofProto* StateProof::mutable_proof() {
  ::alyncoin::StateProofProto* _msg = _internal_mutable_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.StateProof.proof)
  return _msg;
}
inline void StateProof::set_allocated_proof(::alyncoin::StateProofProto* proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.proof_);
  }
  if (proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proof));
    if (message_arena != submessage_arena) {
      proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proof, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.proof_ = proof;
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.StateProof.proof)
}

// -------------------------------------------------------------------

// TransactionBroadcast

// .alyncoin.TransactionProto tx = 1;
inline bool TransactionBroadcast::_internal_has_tx() const {
  return this != internal_default_instance() && _impl_.tx_ != nullptr;
}
inline bool TransactionBroadcast::has_tx() const {
  return _internal_has_tx();
}
inline const ::alyncoin::TransactionProto& TransactionBroadcast::_internal_tx() const {
  const ::alyncoin::TransactionProto* p = _impl_.tx_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::TransactionProto&>(
      ::alyncoin::_TransactionProto_default_instance_);
}
inline const ::alyncoin::TransactionProto& TransactionBroadcast::tx() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.TransactionBroadcast.tx)
  return _internal_tx();
}
inline void TransactionBroadcast::unsafe_arena_set_allocated_tx(
    ::alyncoin::TransactionProto* tx) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_);
  }
  _impl_.tx_ = tx;
  if (tx) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.TransactionBroadcast.tx)
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::release_tx() {
  
  ::alyncoin::TransactionProto* temp = _impl_.tx_;
  _impl_.tx_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::unsafe_arena_release_tx() {
  // @@protoc_insertion_point(field_release:alyncoin.net.TransactionBroadcast.tx)
  
  ::alyncoin::TransactionProto* temp = _impl_.tx_;
  _impl_.tx_ = nullptr;
  return temp;
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::_internal_mutable_tx() {
  
  if (_impl_.tx_ == nullptr) {
    auto* p = CreateMaybeMessage<::alyncoin::TransactionProto>(GetArenaForAllocation());
    _impl_.tx_ = p;
  }
  return _impl_.tx_;
}
inline ::alyncoin::TransactionProto* TransactionBroadcast::mutable_tx() {
  ::alyncoin::TransactionProto* _msg = _internal_mutable_tx();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TransactionBroadcast.tx)
  return _msg;
}
inline void TransactionBroadcast::set_allocated_tx(::alyncoin::TransactionProto* tx) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.tx_);
  }
  if (tx) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(tx));
    if (message_arena != submessage_arena) {
      tx = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.tx_ = tx;
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.TransactionBroadcast.tx)
}

// -------------------------------------------------------------------

// Frame

// .alyncoin.net.Handshake handshake = 1;
inline bool Frame::_internal_has_handshake() const {
  return kind_case() == kHandshake;
}
inline bool Frame::has_handshake() const {
  return _internal_has_handshake();
}
inline void Frame::set_has_handshake() {
  _impl_._oneof_case_[0] = kHandshake;
}
inline void Frame::clear_handshake() {
  if (_internal_has_handshake()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.handshake_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Handshake* Frame::release_handshake() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.handshake)
  if (_internal_has_handshake()) {
    clear_has_kind();
    ::alyncoin::net::Handshake* temp = _impl_.kind_.handshake_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Handshake& Frame::_internal_handshake() const {
  return _internal_has_handshake()
      ? *_impl_.kind_.handshake_
      : reinterpret_cast< ::alyncoin::net::Handshake&>(::alyncoin::net::_Handshake_default_instance_);
}
inline const ::alyncoin::net::Handshake& Frame::handshake() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.handshake)
  return _internal_handshake();
}
inline ::alyncoin::net::Handshake* Frame::unsafe_arena_release_handshake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.handshake)
  if (_internal_has_handshake()) {
    clear_has_kind();
    ::alyncoin::net::Handshake* temp = _impl_.kind_.handshake_;
    _impl_.kind_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_handshake(::alyncoin::net::Handshake* handshake) {
  clear_kind();
  if (handshake) {
    set_has_handshake();
    _impl_.kind_.handshake_ = handshake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.handshake)
}
inline ::alyncoin::net::Handshake* Frame::_internal_mutable_handshake() {
  if (!_internal_has_handshake()) {
    clear_kind();
    set_has_handshake();
    _impl_.kind_.handshake_ = CreateMaybeMessage< ::alyncoin::net::Handshake >(GetArenaForAllocation());
  }
  return _impl_.kind_.handshake_;
}
inline ::alyncoin::net::Handshake* Frame::mutable_handshake() {
  ::alyncoin::net::Handshake* _msg = _internal_mutable_handshake();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.handshake)
  return _msg;
}

// .alyncoin.net.Ping ping = 2;
inline bool Frame::_internal_has_ping() const {
  return kind_case() == kPing;
}
inline bool Frame::has_ping() const {
  return _internal_has_ping();
}
inline void Frame::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void Frame::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.ping_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Ping* Frame::release_ping() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.ping)
  if (_internal_has_ping()) {
    clear_has_kind();
    ::alyncoin::net::Ping* temp = _impl_.kind_.ping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Ping& Frame::_internal_ping() const {
  return _internal_has_ping()
      ? *_impl_.kind_.ping_
      : reinterpret_cast< ::alyncoin::net::Ping&>(::alyncoin::net::_Ping_default_instance_);
}
inline const ::alyncoin::net::Ping& Frame::ping() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.ping)
  return _internal_ping();
}
inline ::alyncoin::net::Ping* Frame::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.ping)
  if (_internal_has_ping()) {
    clear_has_kind();
    ::alyncoin::net::Ping* temp = _impl_.kind_.ping_;
    _impl_.kind_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_ping(::alyncoin::net::Ping* ping) {
  clear_kind();
  if (ping) {
    set_has_ping();
    _impl_.kind_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.ping)
}
inline ::alyncoin::net::Ping* Frame::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_kind();
    set_has_ping();
    _impl_.kind_.ping_ = CreateMaybeMessage< ::alyncoin::net::Ping >(GetArenaForAllocation());
  }
  return _impl_.kind_.ping_;
}
inline ::alyncoin::net::Ping* Frame::mutable_ping() {
  ::alyncoin::net::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.ping)
  return _msg;
}

// .alyncoin.net.Pong pong = 3;
inline bool Frame::_internal_has_pong() const {
  return kind_case() == kPong;
}
inline bool Frame::has_pong() const {
  return _internal_has_pong();
}
inline void Frame::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void Frame::clear_pong() {
  if (_internal_has_pong()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.pong_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Pong* Frame::release_pong() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.pong)
  if (_internal_has_pong()) {
    clear_has_kind();
    ::alyncoin::net::Pong* temp = _impl_.kind_.pong_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Pong& Frame::_internal_pong() const {
  return _internal_has_pong()
      ? *_impl_.kind_.pong_
      : reinterpret_cast< ::alyncoin::net::Pong&>(::alyncoin::net::_Pong_default_instance_);
}
inline const ::alyncoin::net::Pong& Frame::pong() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.pong)
  return _internal_pong();
}
inline ::alyncoin::net::Pong* Frame::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.pong)
  if (_internal_has_pong()) {
    clear_has_kind();
    ::alyncoin::net::Pong* temp = _impl_.kind_.pong_;
    _impl_.kind_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_pong(::alyncoin::net::Pong* pong) {
  clear_kind();
  if (pong) {
    set_has_pong();
    _impl_.kind_.pong_ = pong;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.pong)
}
inline ::alyncoin::net::Pong* Frame::_internal_mutable_pong() {
  if (!_internal_has_pong()) {
    clear_kind();
    set_has_pong();
    _impl_.kind_.pong_ = CreateMaybeMessage< ::alyncoin::net::Pong >(GetArenaForAllocation());
  }
  return _impl_.kind_.pong_;
}
inline ::alyncoin::net::Pong* Frame::mutable_pong() {
  ::alyncoin::net::Pong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.pong)
  return _msg;
}

// .alyncoin.net.HeightRequest height_req = 4;
inline bool Frame::_internal_has_height_req() const {
  return kind_case() == kHeightReq;
}
inline bool Frame::has_height_req() const {
  return _internal_has_height_req();
}
inline void Frame::set_has_height_req() {
  _impl_._oneof_case_[0] = kHeightReq;
}
inline void Frame::clear_height_req() {
  if (_internal_has_height_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.height_req_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightRequest* Frame::release_height_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_req)
  if (_internal_has_height_req()) {
    clear_has_kind();
    ::alyncoin::net::HeightRequest* temp = _impl_.kind_.height_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightRequest& Frame::_internal_height_req() const {
  return _internal_has_height_req()
      ? *_impl_.kind_.height_req_
      : reinterpret_cast< ::alyncoin::net::HeightRequest&>(::alyncoin::net::_HeightRequest_default_instance_);
}
inline const ::alyncoin::net::HeightRequest& Frame::height_req() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_req)
  return _internal_height_req();
}
inline ::alyncoin::net::HeightRequest* Frame::unsafe_arena_release_height_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_req)
  if (_internal_has_height_req()) {
    clear_has_kind();
    ::alyncoin::net::HeightRequest* temp = _impl_.kind_.height_req_;
    _impl_.kind_.height_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_req(::alyncoin::net::HeightRequest* height_req) {
  clear_kind();
  if (height_req) {
    set_has_height_req();
    _impl_.kind_.height_req_ = height_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_req)
}
inline ::alyncoin::net::HeightRequest* Frame::_internal_mutable_height_req() {
  if (!_internal_has_height_req()) {
    clear_kind();
    set_has_height_req();
    _impl_.kind_.height_req_ = CreateMaybeMessage< ::alyncoin::net::HeightRequest >(GetArenaForAllocation());
  }
  return _impl_.kind_.height_req_;
}
inline ::alyncoin::net::HeightRequest* Frame::mutable_height_req() {
  ::alyncoin::net::HeightRequest* _msg = _internal_mutable_height_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_req)
  return _msg;
}

// .alyncoin.net.HeightResponse height_res = 5;
inline bool Frame::_internal_has_height_res() const {
  return kind_case() == kHeightRes;
}
inline bool Frame::has_height_res() const {
  return _internal_has_height_res();
}
inline void Frame::set_has_height_res() {
  _impl_._oneof_case_[0] = kHeightRes;
}
inline void Frame::clear_height_res() {
  if (_internal_has_height_res()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.height_res_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightResponse* Frame::release_height_res() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_res)
  if (_internal_has_height_res()) {
    clear_has_kind();
    ::alyncoin::net::HeightResponse* temp = _impl_.kind_.height_res_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightResponse& Frame::_internal_height_res() const {
  return _internal_has_height_res()
      ? *_impl_.kind_.height_res_
      : reinterpret_cast< ::alyncoin::net::HeightResponse&>(::alyncoin::net::_HeightResponse_default_instance_);
}
inline const ::alyncoin::net::HeightResponse& Frame::height_res() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_res)
  return _internal_height_res();
}
inline ::alyncoin::net::HeightResponse* Frame::unsafe_arena_release_height_res() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_res)
  if (_internal_has_height_res()) {
    clear_has_kind();
    ::alyncoin::net::HeightResponse* temp = _impl_.kind_.height_res_;
    _impl_.kind_.height_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_res(::alyncoin::net::HeightResponse* height_res) {
  clear_kind();
  if (height_res) {
    set_has_height_res();
    _impl_.kind_.height_res_ = height_res;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_res)
}
inline ::alyncoin::net::HeightResponse* Frame::_internal_mutable_height_res() {
  if (!_internal_has_height_res()) {
    clear_kind();
    set_has_height_res();
    _impl_.kind_.height_res_ = CreateMaybeMessage< ::alyncoin::net::HeightResponse >(GetArenaForAllocation());
  }
  return _impl_.kind_.height_res_;
}
inline ::alyncoin::net::HeightResponse* Frame::mutable_height_res() {
  ::alyncoin::net::HeightResponse* _msg = _internal_mutable_height_res();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_res)
  return _msg;
}

// .alyncoin.net.BlockBroadcast block_broadcast = 6;
inline bool Frame::_internal_has_block_broadcast() const {
  return kind_case() == kBlockBroadcast;
}
inline bool Frame::has_block_broadcast() const {
  return _internal_has_block_broadcast();
}
inline void Frame::set_has_block_broadcast() {
  _impl_._oneof_case_[0] = kBlockBroadcast;
}
inline void Frame::clear_block_broadcast() {
  if (_internal_has_block_broadcast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.block_broadcast_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockBroadcast* Frame::release_block_broadcast() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_broadcast)
  if (_internal_has_block_broadcast()) {
    clear_has_kind();
    ::alyncoin::net::BlockBroadcast* temp = _impl_.kind_.block_broadcast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockBroadcast& Frame::_internal_block_broadcast() const {
  return _internal_has_block_broadcast()
      ? *_impl_.kind_.block_broadcast_
      : reinterpret_cast< ::alyncoin::net::BlockBroadcast&>(::alyncoin::net::_BlockBroadcast_default_instance_);
}
inline const ::alyncoin::net::BlockBroadcast& Frame::block_broadcast() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_broadcast)
  return _internal_block_broadcast();
}
inline ::alyncoin::net::BlockBroadcast* Frame::unsafe_arena_release_block_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_broadcast)
  if (_internal_has_block_broadcast()) {
    clear_has_kind();
    ::alyncoin::net::BlockBroadcast* temp = _impl_.kind_.block_broadcast_;
    _impl_.kind_.block_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* block_broadcast) {
  clear_kind();
  if (block_broadcast) {
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ = block_broadcast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_broadcast)
}
inline ::alyncoin::net::BlockBroadcast* Frame::_internal_mutable_block_broadcast() {
  if (!_internal_has_block_broadcast()) {
    clear_kind();
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ = CreateMaybeMessage< ::alyncoin::net::BlockBroadcast >(GetArenaForAllocation());
  }
  return _impl_.kind_.block_broadcast_;
}
inline ::alyncoin::net::BlockBroadcast* Frame::mutable_block_broadcast() {
  ::alyncoin::net::BlockBroadcast* _msg = _internal_mutable_block_broadcast();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_broadcast)
  return _msg;
}

// .alyncoin.net.BlockBatch block_batch = 7;
inline bool Frame::_internal_has_block_batch() const {
  return kind_case() == kBlockBatch;
}
inline bool Frame::has_block_batch() const {
  return _internal_has_block_batch();
}
inline void Frame::set_has_block_batch() {
  _impl_._oneof_case_[0] = kBlockBatch;
}
inline void Frame::clear_block_batch() {
  if (_internal_has_block_batch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.block_batch_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockBatch* Frame::release_block_batch() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_batch)
  if (_internal_has_block_batch()) {
    clear_has_kind();
    ::alyncoin::net::BlockBatch* temp = _impl_.kind_.block_batch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockBatch& Frame::_internal_block_batch() const {
  return _internal_has_block_batch()
      ? *_impl_.kind_.block_batch_
      : reinterpret_cast< ::alyncoin::net::BlockBatch&>(::alyncoin::net::_BlockBatch_default_instance_);
}
inline const ::alyncoin::net::BlockBatch& Frame::block_batch() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_batch)
  return _internal_block_batch();
}
inline ::alyncoin::net::BlockBatch* Frame::unsafe_arena_release_block_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_batch)
  if (_internal_has_block_batch()) {
    clear_has_kind();
    ::alyncoin::net::BlockBatch* temp = _impl_.kind_.block_batch_;
    _impl_.kind_.block_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_batch(::alyncoin::net::BlockBatch* block_batch) {
  clear_kind();
  if (block_batch) {
    set_has_block_batch();
    _impl_.kind_.block_batch_ = block_batch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_batch)
}
inline ::alyncoin::net::BlockBatch* Frame::_internal_mutable_block_batch() {
  if (!_internal_has_block_batch()) {
    clear_kind();
    set_has_block_batch();
    _impl_.kind_.block_batch_ = CreateMaybeMessage< ::alyncoin::net::BlockBatch >(GetArenaForAllocation());
  }
  return _impl_.kind_.block_batch_;
}
inline ::alyncoin::net::BlockBatch* Frame::mutable_block_batch() {
  ::alyncoin::net::BlockBatch* _msg = _internal_mutable_block_batch();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_batch)
  return _msg;
}

// .alyncoin.net.SnapshotChunk snapshot_chunk = 8;
inline bool Frame::_internal_has_snapshot_chunk() const {
  return kind_case() == kSnapshotChunk;
}
inline bool Frame::has_snapshot_chunk() const {
  return _internal_has_snapshot_chunk();
}
inline void Frame::set_has_snapshot_chunk() {
  _impl_._oneof_case_[0] = kSnapshotChunk;
}
inline void Frame::clear_snapshot_chunk() {
  if (_internal_has_snapshot_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.snapshot_chunk_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotChunk* Frame::release_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_chunk)
  if (_internal_has_snapshot_chunk()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotChunk* temp = _impl_.kind_.snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotChunk& Frame::_internal_snapshot_chunk() const {
  return _internal_has_snapshot_chunk()
      ? *_impl_.kind_.snapshot_chunk_
      : reinterpret_cast< ::alyncoin::net::SnapshotChunk&>(::alyncoin::net::_SnapshotChunk_default_instance_);
}
inline const ::alyncoin::net::SnapshotChunk& Frame::snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_chunk)
  return _internal_snapshot_chunk();
}
inline ::alyncoin::net::SnapshotChunk* Frame::unsafe_arena_release_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_chunk)
  if (_internal_has_snapshot_chunk()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotChunk* temp = _impl_.kind_.snapshot_chunk_;
    _impl_.kind_.snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* snapshot_chunk) {
  clear_kind();
  if (snapshot_chunk) {
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ = snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_chunk)
}
inline ::alyncoin::net::SnapshotChunk* Frame::_internal_mutable_snapshot_chunk() {
  if (!_internal_has_snapshot_chunk()) {
    clear_kind();
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ = CreateMaybeMessage< ::alyncoin::net::SnapshotChunk >(GetArenaForAllocation());
  }
  return _impl_.kind_.snapshot_chunk_;
}
inline ::alyncoin::net::SnapshotChunk* Frame::mutable_snapshot_chunk() {
  ::alyncoin::net::SnapshotChunk* _msg = _internal_mutable_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_chunk)
  return _msg;
}

// .alyncoin.net.SnapshotEnd snapshot_end = 9;
inline bool Frame::_internal_has_snapshot_end() const {
  return kind_case() == kSnapshotEnd;
}
inline bool Frame::has_snapshot_end() const {
  return _internal_has_snapshot_end();
}
inline void Frame::set_has_snapshot_end() {
  _impl_._oneof_case_[0] = kSnapshotEnd;
}
inline void Frame::clear_snapshot_end() {
  if (_internal_has_snapshot_end()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.snapshot_end_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotEnd* Frame::release_snapshot_end() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_end)
  if (_internal_has_snapshot_end()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotEnd* temp = _impl_.kind_.snapshot_end_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotEnd& Frame::_internal_snapshot_end() const {
  return _internal_has_snapshot_end()
      ? *_impl_.kind_.snapshot_end_
      : reinterpret_cast< ::alyncoin::net::SnapshotEnd&>(::alyncoin::net::_SnapshotEnd_default_instance_);
}
inline const ::alyncoin::net::SnapshotEnd& Frame::snapshot_end() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_end)
  return _internal_snapshot_end();
}
inline ::alyncoin::net::SnapshotEnd* Frame::unsafe_arena_release_snapshot_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_end)
  if (_internal_has_snapshot_end()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotEnd* temp = _impl_.kind_.snapshot_end_;
    _impl_.kind_.snapshot_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* snapshot_end) {
  clear_kind();
  if (snapshot_end) {
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ = snapshot_end;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_end)
}
inline ::alyncoin::net::SnapshotEnd* Frame::_internal_mutable_snapshot_end() {
  if (!_internal_has_snapshot_end()) {
    clear_kind();
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ = CreateMaybeMessage< ::alyncoin::net::SnapshotEnd >(GetArenaForAllocation());
  }
  return _impl_.kind_.snapshot_end_;
}
inline ::alyncoin::net::SnapshotEnd* Frame::mutable_snapshot_end() {
  ::alyncoin::net::SnapshotEnd* _msg = _internal_mutable_snapshot_end();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_end)
  return _msg;
}

// .alyncoin.net.TailBlocks tail_blocks = 10;
inline bool Frame::_internal_has_tail_blocks() const {
  return kind_case() == kTailBlocks;
}
inline bool Frame::has_tail_blocks() const {
  return _internal_has_tail_blocks();
}
inline void Frame::set_has_tail_blocks() {
  _impl_._oneof_case_[0] = kTailBlocks;
}
inline void Frame::clear_tail_blocks() {
  if (_internal_has_tail_blocks()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tail_blocks_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TailBlocks* Frame::release_tail_blocks() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tail_blocks)
  if (_internal_has_tail_blocks()) {
    clear_has_kind();
    ::alyncoin::net::TailBlocks* temp = _impl_.kind_.tail_blocks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tail_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TailBlocks& Frame::_internal_tail_blocks() const {
  return _internal_has_tail_blocks()
      ? *_impl_.kind_.tail_blocks_
      : reinterpret_cast< ::alyncoin::net::TailBlocks&>(::alyncoin::net::_TailBlocks_default_instance_);
}
inline const ::alyncoin::net::TailBlocks& Frame::tail_blocks() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tail_blocks)
  return _internal_tail_blocks();
}
inline ::alyncoin::net::TailBlocks* Frame::unsafe_arena_release_tail_blocks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tail_blocks)
  if (_internal_has_tail_blocks()) {
    clear_has_kind();
    ::alyncoin::net::TailBlocks* temp = _impl_.kind_.tail_blocks_;
    _impl_.kind_.tail_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tail_blocks(::alyncoin::net::TailBlocks* tail_blocks) {
  clear_kind();
  if (tail_blocks) {
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ = tail_blocks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tail_blocks)
}
inline ::alyncoin::net::TailBlocks* Frame::_internal_mutable_tail_blocks() {
  if (!_internal_has_tail_blocks()) {
    clear_kind();
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ = CreateMaybeMessage< ::alyncoin::net::TailBlocks >(GetArenaForAllocation());
  }
  return _impl_.kind_.tail_blocks_;
}
inline ::alyncoin::net::TailBlocks* Frame::mutable_tail_blocks() {
  ::alyncoin::net::TailBlocks* _msg = _internal_mutable_tail_blocks();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tail_blocks)
  return _msg;
}

// .alyncoin.net.EpochProof agg_proof = 11;
inline bool Frame::_internal_has_agg_proof() const {
  return kind_case() == kAggProof;
}
inline bool Frame::has_agg_proof() const {
  return _internal_has_agg_proof();
}
inline void Frame::set_has_agg_proof() {
  _impl_._oneof_case_[0] = kAggProof;
}
inline void Frame::clear_agg_proof() {
  if (_internal_has_agg_proof()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.agg_proof_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::EpochProof* Frame::release_agg_proof() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.agg_proof)
  if (_internal_has_agg_proof()) {
    clear_has_kind();
    ::alyncoin::net::EpochProof* temp = _impl_.kind_.agg_proof_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.agg_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::EpochProof& Frame::_internal_agg_proof() const {
  return _internal_has_agg_proof()
      ? *_impl_.kind_.agg_proof_
      : reinterpret_cast< ::alyncoin::net::EpochProof&>(::alyncoin::net::_EpochProof_default_instance_);
}
inline const ::alyncoin::net::EpochProof& Frame::agg_proof() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.agg_proof)
  return _internal_agg_proof();
}
inline ::alyncoin::net::EpochProof* Frame::unsafe_arena_release_agg_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.agg_proof)
  if (_internal_has_agg_proof()) {
    clear_has_kind();
    ::alyncoin::net::EpochProof* temp = _impl_.kind_.agg_proof_;
    _impl_.kind_.agg_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_agg_proof(::alyncoin::net::EpochProof* agg_proof) {
  clear_kind();
  if (agg_proof) {
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ = agg_proof;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.agg_proof)
}
inline ::alyncoin::net::EpochProof* Frame::_internal_mutable_agg_proof() {
  if (!_internal_has_agg_proof()) {
    clear_kind();
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ = CreateMaybeMessage< ::alyncoin::net::EpochProof >(GetArenaForAllocation());
  }
  return _impl_.kind_.agg_proof_;
}
inline ::alyncoin::net::EpochProof* Frame::mutable_agg_proof() {
  ::alyncoin::net::EpochProof* _msg = _internal_mutable_agg_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.agg_proof)
  return _msg;
}

// .alyncoin.net.Inventory inv = 12;
inline bool Frame::_internal_has_inv() const {
  return kind_case() == kInv;
}
inline bool Frame::has_inv() const {
  return _internal_has_inv();
}
inline void Frame::set_has_inv() {
  _impl_._oneof_case_[0] = kInv;
}
inline void Frame::clear_inv() {
  if (_internal_has_inv()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.inv_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Inventory* Frame::release_inv() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.inv)
  if (_internal_has_inv()) {
    clear_has_kind();
    ::alyncoin::net::Inventory* temp = _impl_.kind_.inv_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.inv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Inventory& Frame::_internal_inv() const {
  return _internal_has_inv()
      ? *_impl_.kind_.inv_
      : reinterpret_cast< ::alyncoin::net::Inventory&>(::alyncoin::net::_Inventory_default_instance_);
}
inline const ::alyncoin::net::Inventory& Frame::inv() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.inv)
  return _internal_inv();
}
inline ::alyncoin::net::Inventory* Frame::unsafe_arena_release_inv() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.inv)
  if (_internal_has_inv()) {
    clear_has_kind();
    ::alyncoin::net::Inventory* temp = _impl_.kind_.inv_;
    _impl_.kind_.inv_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_inv(::alyncoin::net::Inventory* inv) {
  clear_kind();
  if (inv) {
    set_has_inv();
    _impl_.kind_.inv_ = inv;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.inv)
}
inline ::alyncoin::net::Inventory* Frame::_internal_mutable_inv() {
  if (!_internal_has_inv()) {
    clear_kind();
    set_has_inv();
    _impl_.kind_.inv_ = CreateMaybeMessage< ::alyncoin::net::Inventory >(GetArenaForAllocation());
  }
  return _impl_.kind_.inv_;
}
inline ::alyncoin::net::Inventory* Frame::mutable_inv() {
  ::alyncoin::net::Inventory* _msg = _internal_mutable_inv();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.inv)
  return _msg;
}

// .alyncoin.net.TipHashRequest tip_hash_req = 13;
inline bool Frame::_internal_has_tip_hash_req() const {
  return kind_case() == kTipHashReq;
}
inline bool Frame::has_tip_hash_req() const {
  return _internal_has_tip_hash_req();
}
inline void Frame::set_has_tip_hash_req() {
  _impl_._oneof_case_[0] = kTipHashReq;
}
inline void Frame::clear_tip_hash_req() {
  if (_internal_has_tip_hash_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tip_hash_req_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TipHashRequest* Frame::release_tip_hash_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tip_hash_req)
  if (_internal_has_tip_hash_req()) {
    clear_has_kind();
    ::alyncoin::net::TipHashRequest* temp = _impl_.kind_.tip_hash_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tip_hash_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TipHashRequest& Frame::_internal_tip_hash_req() const {
  return _internal_has_tip_hash_req()
      ? *_impl_.kind_.tip_hash_req_
      : reinterpret_cast< ::alyncoin::net::TipHashRequest&>(::alyncoin::net::_TipHashRequest_default_instance_);
}
inline const ::alyncoin::net::TipHashRequest& Frame::tip_hash_req() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tip_hash_req)
  return _internal_tip_hash_req();
}
inline ::alyncoin::net::TipHashRequest* Frame::unsafe_arena_release_tip_hash_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tip_hash_req)
  if (_internal_has_tip_hash_req()) {
    clear_has_kind();
    ::alyncoin::net::TipHashRequest* temp = _impl_.kind_.tip_hash_req_;
    _impl_.kind_.tip_hash_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tip_hash_req(::alyncoin::net::TipHashRequest* tip_hash_req) {
  clear_kind();
  if (tip_hash_req) {
    set_has_tip_hash_req();
    _impl_.kind_.tip_hash_req_ = tip_hash_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tip_hash_req)
}
inline ::alyncoin::net::TipHashRequest* Frame::_internal_mutable_tip_hash_req() {
  if (!_internal_has_tip_hash_req()) {
    clear_kind();
    set_has_tip_hash_req();
    _impl_.kind_.tip_hash_req_ = CreateMaybeMessage< ::alyncoin::net::TipHashRequest >(GetArenaForAllocation());
  }
  return _impl_.kind_.tip_hash_req_;
}
inline ::alyncoin::net::TipHashRequest* Frame::mutable_tip_hash_req() {
  ::alyncoin::net::TipHashRequest* _msg = _internal_mutable_tip_hash_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tip_hash_req)
  return _msg;
}

// .alyncoin.net.TipHashResponse tip_hash_res = 14;
inline bool Frame::_internal_has_tip_hash_res() const {
  return kind_case() == kTipHashRes;
}
inline bool Frame::has_tip_hash_res() const {
  return _internal_has_tip_hash_res();
}
inline void Frame::set_has_tip_hash_res() {
  _impl_._oneof_case_[0] = kTipHashRes;
}
inline void Frame::clear_tip_hash_res() {
  if (_internal_has_tip_hash_res()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tip_hash_res_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TipHashResponse* Frame::release_tip_hash_res() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tip_hash_res)
  if (_internal_has_tip_hash_res()) {
    clear_has_kind();
    ::alyncoin::net::TipHashResponse* temp = _impl_.kind_.tip_hash_res_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tip_hash_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TipHashResponse& Frame::_internal_tip_hash_res() const {
  return _internal_has_tip_hash_res()
      ? *_impl_.kind_.tip_hash_res_
      : reinterpret_cast< ::alyncoin::net::TipHashResponse&>(::alyncoin::net::_TipHashResponse_default_instance_);
}
inline const ::alyncoin::net::TipHashResponse& Frame::tip_hash_res() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tip_hash_res)
  return _internal_tip_hash_res();
}
inline ::alyncoin::net::TipHashResponse* Frame::unsafe_arena_release_tip_hash_res() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tip_hash_res)
  if (_internal_has_tip_hash_res()) {
    clear_has_kind();
    ::alyncoin::net::TipHashResponse* temp = _impl_.kind_.tip_hash_res_;
    _impl_.kind_.tip_hash_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tip_hash_res(::alyncoin::net::TipHashResponse* tip_hash_res) {
  clear_kind();
  if (tip_hash_res) {
    set_has_tip_hash_res();
    _impl_.kind_.tip_hash_res_ = tip_hash_res;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tip_hash_res)
}
inline ::alyncoin::net::TipHashResponse* Frame::_internal_mutable_tip_hash_res() {
  if (!_internal_has_tip_hash_res()) {
    clear_kind();
    set_has_tip_hash_res();
    _impl_.kind_.tip_hash_res_ = CreateMaybeMessage< ::alyncoin::net::TipHashResponse >(GetArenaForAllocation());
  }
  return _impl_.kind_.tip_hash_res_;
}
inline ::alyncoin::net::TipHashResponse* Frame::mutable_tip_hash_res() {
  ::alyncoin::net::TipHashResponse* _msg = _internal_mutable_tip_hash_res();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tip_hash_res)
  return _msg;
}

// .alyncoin.net.PeerListRequest peer_list_req = 15;
inline bool Frame::_internal_has_peer_list_req() const {
  return kind_case() == kPeerListReq;
}
inline bool Frame::has_peer_list_req() const {
  return _internal_has_peer_list_req();
}
inline void Frame::set_has_peer_list_req() {
  _impl_._oneof_case_[0] = kPeerListReq;
}
inline void Frame::clear_peer_list_req() {
  if (_internal_has_peer_list_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.peer_list_req_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::PeerListRequest* Frame::release_peer_list_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.peer_list_req)
  if (_internal_has_peer_list_req()) {
    clear_has_kind();
    ::alyncoin::net::PeerListRequest* temp = _impl_.kind_.peer_list_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.peer_list_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::PeerListRequest& Frame::_internal_peer_list_req() const {
  return _internal_has_peer_list_req()
      ? *_impl_.kind_.peer_list_req_
      : reinterpret_cast< ::alyncoin::net::PeerListRequest&>(::alyncoin::net::_PeerListRequest_default_instance_);
}
inline const ::alyncoin::net::PeerListRequest& Frame::peer_list_req() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.peer_list_req)
  return _internal_peer_list_req();
}
inline ::alyncoin::net::PeerListRequest* Frame::unsafe_arena_release_peer_list_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.peer_list_req)
  if (_internal_has_peer_list_req()) {
    clear_has_kind();
    ::alyncoin::net::PeerListRequest* temp = _impl_.kind_.peer_list_req_;
    _impl_.kind_.peer_list_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_peer_list_req(::alyncoin::net::PeerListRequest* peer_list_req) {
  clear_kind();
  if (peer_list_req) {
    set_has_peer_list_req();
    _impl_.kind_.peer_list_req_ = peer_list_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.peer_list_req)
}
inline ::alyncoin::net::PeerListRequest* Frame::_internal_mutable_peer_list_req() {
  if (!_internal_has_peer_list_req()) {
    clear_kind();
    set_has_peer_list_req();
    _impl_.kind_.peer_list_req_ = CreateMaybeMessage< ::alyncoin::net::PeerListRequest >(GetArenaForAllocation());
  }
  return _impl_.kind_.peer_list_req_;
}
inline ::alyncoin::net::PeerListRequest* Frame::mutable_peer_list_req() {
  ::alyncoin::net::PeerListRequest* _msg = _internal_mutable_peer_list_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.peer_list_req)
  return _msg;
}

// .alyncoin.net.PeerList peer_list = 16;
inline bool Frame::_internal_has_peer_list() const {
  return kind_case() == kPeerList;
}
inline bool Frame::has_peer_list() const {
  return _internal_has_peer_list();
}
inline void Frame::set_has_peer_list() {
  _impl_._oneof_case_[0] = kPeerList;
}
inline void Frame::clear_peer_list() {
  if (_internal_has_peer_list()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.peer_list_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::PeerList* Frame::release_peer_list() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.peer_list)
  if (_internal_has_peer_list()) {
    clear_has_kind();
    ::alyncoin::net::PeerList* temp = _impl_.kind_.peer_list_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.peer_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::PeerList& Frame::_internal_peer_list() const {
  return _internal_has_peer_list()
      ? *_impl_.kind_.peer_list_
      : reinterpret_cast< ::alyncoin::net::PeerList&>(::alyncoin::net::_PeerList_default_instance_);
}
inline const ::alyncoin::net::PeerList& Frame::peer_list() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.peer_list)
  return _internal_peer_list();
}
inline ::alyncoin::net::PeerList* Frame::unsafe_arena_release_peer_list() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.peer_list)
  if (_internal_has_peer_list()) {
    clear_has_kind();
    ::alyncoin::net::PeerList* temp = _impl_.kind_.peer_list_;
    _impl_.kind_.peer_list_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_peer_list(::alyncoin::net::PeerList* peer_list) {
  clear_kind();
  if (peer_list) {
    set_has_peer_list();
    _impl_.kind_.peer_list_ = peer_list;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.peer_list)
}
inline ::alyncoin::net::PeerList* Frame::_internal_mutable_peer_list() {
  if (!_internal_has_peer_list()) {
    clear_kind();
    set_has_peer_list();
    _impl_.kind_.peer_list_ = CreateMaybeMessage< ::alyncoin::net::PeerList >(GetArenaForAllocation());
  }
  return _impl_.kind_.peer_list_;
}
inline ::alyncoin::net::PeerList* Frame::mutable_peer_list() {
  ::alyncoin::net::PeerList* _msg = _internal_mutable_peer_list();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.peer_list)
  return _msg;
}

// .alyncoin.net.RollupBlockMsg rollup_block = 17;
inline bool Frame::_internal_has_rollup_block() const {
  return kind_case() == kRollupBlock;
}
inline bool Frame::has_rollup_block() const {
  return _internal_has_rollup_block();
}
inline void Frame::set_has_rollup_block() {
  _impl_._oneof_case_[0] = kRollupBlock;
}
inline void Frame::clear_rollup_block() {
  if (_internal_has_rollup_block()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.rollup_block_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::RollupBlockMsg* Frame::release_rollup_block() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.rollup_block)
  if (_internal_has_rollup_block()) {
    clear_has_kind();
    ::alyncoin::net::RollupBlockMsg* temp = _impl_.kind_.rollup_block_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.rollup_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::RollupBlockMsg& Frame::_internal_rollup_block() const {
  return _internal_has_rollup_block()
      ? *_impl_.kind_.rollup_block_
      : reinterpret_cast< ::alyncoin::net::RollupBlockMsg&>(::alyncoin::net::_RollupBlockMsg_default_instance_);
}
inline const ::alyncoin::net::RollupBlockMsg& Frame::rollup_block() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.rollup_block)
  return _internal_rollup_block();
}
inline ::alyncoin::net::RollupBlockMsg* Frame::unsafe_arena_release_rollup_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.rollup_block)
  if (_internal_has_rollup_block()) {
    clear_has_kind();
    ::alyncoin::net::RollupBlockMsg* temp = _impl_.kind_.rollup_block_;
    _impl_.kind_.rollup_block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_rollup_block(::alyncoin::net::RollupBlockMsg* rollup_block) {
  clear_kind();
  if (rollup_block) {
    set_has_rollup_block();
    _impl_.kind_.rollup_block_ = rollup_block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.rollup_block)
}
inline ::alyncoin::net::RollupBlockMsg* Frame::_internal_mutable_rollup_block() {
  if (!_internal_has_rollup_block()) {
    clear_kind();
    set_has_rollup_block();
    _impl_.kind_.rollup_block_ = CreateMaybeMessage< ::alyncoin::net::RollupBlockMsg >(GetArenaForAllocation());
  }
  return _impl_.kind_.rollup_block_;
}
inline ::alyncoin::net::RollupBlockMsg* Frame::mutable_rollup_block() {
  ::alyncoin::net::RollupBlockMsg* _msg = _internal_mutable_rollup_block();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.rollup_block)
  return _msg;
}

// .alyncoin.net.SnapshotRequest snapshot_req = 18;
inline bool Frame::_internal_has_snapshot_req() const {
  return kind_case() == kSnapshotReq;
}
inline bool Frame::has_snapshot_req() const {
  return _internal_has_snapshot_req();
}
inline void Frame::set_has_snapshot_req() {
  _impl_._oneof_case_[0] = kSnapshotReq;
}
inline void Frame::clear_snapshot_req() {
  if (_internal_has_snapshot_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.snapshot_req_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotRequest* Frame::release_snapshot_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_req)
  if (_internal_has_snapshot_req()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotRequest* temp = _impl_.kind_.snapshot_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotRequest& Frame::_internal_snapshot_req() const {
  return _internal_has_snapshot_req()
      ? *_impl_.kind_.snapshot_req_
      : reinterpret_cast< ::alyncoin::net::SnapshotRequest&>(::alyncoin::net::_SnapshotRequest_default_instance_);
}
inline const ::alyncoin::net::SnapshotRequest& Frame::snapshot_req() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_req)
  return _internal_snapshot_req();
}
inline ::alyncoin::net::SnapshotRequest* Frame::unsafe_arena_release_snapshot_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_req)
  if (_internal_has_snapshot_req()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotRequest* temp = _impl_.kind_.snapshot_req_;
    _impl_.kind_.snapshot_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_req(::alyncoin::net::SnapshotRequest* snapshot_req) {
  clear_kind();
  if (snapshot_req) {
    set_has_snapshot_req();
    _impl_.kind_.snapshot_req_ = snapshot_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_req)
}
inline ::alyncoin::net::SnapshotRequest* Frame::_internal_mutable_snapshot_req() {
  if (!_internal_has_snapshot_req()) {
    clear_kind();
    set_has_snapshot_req();
    _impl_.kind_.snapshot_req_ = CreateMaybeMessage< ::alyncoin::net::SnapshotRequest >(GetArenaForAllocation());
  }
  return _impl_.kind_.snapshot_req_;
}
inline ::alyncoin::net::SnapshotRequest* Frame::mutable_snapshot_req() {
  ::alyncoin::net::SnapshotRequest* _msg = _internal_mutable_snapshot_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_req)
  return _msg;
}

// .alyncoin.net.TailBlocksRequest tail_req = 19;
inline bool Frame::_internal_has_tail_req() const {
  return kind_case() == kTailReq;
}
inline bool Frame::has_tail_req() const {
  return _internal_has_tail_req();
}
inline void Frame::set_has_tail_req() {
  _impl_._oneof_case_[0] = kTailReq;
}
inline void Frame::clear_tail_req() {
  if (_internal_has_tail_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tail_req_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TailBlocksRequest* Frame::release_tail_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tail_req)
  if (_internal_has_tail_req()) {
    clear_has_kind();
    ::alyncoin::net::TailBlocksRequest* temp = _impl_.kind_.tail_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tail_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TailBlocksRequest& Frame::_internal_tail_req() const {
  return _internal_has_tail_req()
      ? *_impl_.kind_.tail_req_
      : reinterpret_cast< ::alyncoin::net::TailBlocksRequest&>(::alyncoin::net::_TailBlocksRequest_default_instance_);
}
inline const ::alyncoin::net::TailBlocksRequest& Frame::tail_req() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tail_req)
  return _internal_tail_req();
}
inline ::alyncoin::net::TailBlocksRequest* Frame::unsafe_arena_release_tail_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tail_req)
  if (_internal_has_tail_req()) {
    clear_has_kind();
    ::alyncoin::net::TailBlocksRequest* temp = _impl_.kind_.tail_req_;
    _impl_.kind_.tail_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tail_req(::alyncoin::net::TailBlocksRequest* tail_req) {
  clear_kind();
  if (tail_req) {
    set_has_tail_req();
    _impl_.kind_.tail_req_ = tail_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tail_req)
}
inline ::alyncoin::net::TailBlocksRequest* Frame::_internal_mutable_tail_req() {
  if (!_internal_has_tail_req()) {
    clear_kind();
    set_has_tail_req();
    _impl_.kind_.tail_req_ = CreateMaybeMessage< ::alyncoin::net::TailBlocksRequest >(GetArenaForAllocation());
  }
  return _impl_.kind_.tail_req_;
}
inline ::alyncoin::net::TailBlocksRequest* Frame::mutable_tail_req() {
  ::alyncoin::net::TailBlocksRequest* _msg = _internal_mutable_tail_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tail_req)
  return _msg;
}

// .alyncoin.net.StateProof state_proof = 20;
inline bool Frame::_internal_has_state_proof() const {
  return kind_case() == kStateProof;
}
inline bool Frame::has_state_proof() const {
  return _internal_has_state_proof();
}
inline void Frame::set_has_state_proof() {
  _impl_._oneof_case_[0] = kStateProof;
}
inline void Frame::clear_state_proof() {
  if (_internal_has_state_proof()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.state_proof_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::StateProof* Frame::release_state_proof() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.state_proof)
  if (_internal_has_state_proof()) {
    clear_has_kind();
    ::alyncoin::net::StateProof* temp = _impl_.kind_.state_proof_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.state_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::StateProof& Frame::_internal_state_proof() const {
  return _internal_has_state_proof()
      ? *_impl_.kind_.state_proof_
      : reinterpret_cast< ::alyncoin::net::StateProof&>(::alyncoin::net::_StateProof_default_instance_);
}
inline const ::alyncoin::net::StateProof& Frame::state_proof() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.state_proof)
  return _internal_state_proof();
}
inline ::alyncoin::net::StateProof* Frame::unsafe_arena_release_state_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.state_proof)
  if (_internal_has_state_proof()) {
    clear_has_kind();
    ::alyncoin::net::StateProof* temp = _impl_.kind_.state_proof_;
    _impl_.kind_.state_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_state_proof(::alyncoin::net::StateProof* state_proof) {
  clear_kind();
  if (state_proof) {
    set_has_state_proof();
    _impl_.kind_.state_proof_ = state_proof;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.state_proof)
}
inline ::alyncoin::net::StateProof* Frame::_internal_mutable_state_proof() {
  if (!_internal_has_state_proof()) {
    clear_kind();
    set_has_state_proof();
    _impl_.kind_.state_proof_ = CreateMaybeMessage< ::alyncoin::net::StateProof >(GetArenaForAllocation());
  }
  return _impl_.kind_.state_proof_;
}
inline ::alyncoin::net::StateProof* Frame::mutable_state_proof() {
  ::alyncoin::net::StateProof* _msg = _internal_mutable_state_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.state_proof)
  return _msg;
}

// .alyncoin.net.GetData get_data = 21;
inline bool Frame::_internal_has_get_data() const {
  return kind_case() == kGetData;
}
inline bool Frame::has_get_data() const {
  return _internal_has_get_data();
}
inline void Frame::set_has_get_data() {
  _impl_._oneof_case_[0] = kGetData;
}
inline void Frame::clear_get_data() {
  if (_internal_has_get_data()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.get_data_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::GetData* Frame::release_get_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.get_data)
  if (_internal_has_get_data()) {
    clear_has_kind();
    ::alyncoin::net::GetData* temp = _impl_.kind_.get_data_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::GetData& Frame::_internal_get_data() const {
  return _internal_has_get_data()
      ? *_impl_.kind_.get_data_
      : reinterpret_cast< ::alyncoin::net::GetData&>(::alyncoin::net::_GetData_default_instance_);
}
inline const ::alyncoin::net::GetData& Frame::get_data() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.get_data)
  return _internal_get_data();
}
inline ::alyncoin::net::GetData* Frame::unsafe_arena_release_get_data() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.get_data)
  if (_internal_has_get_data()) {
    clear_has_kind();
    ::alyncoin::net::GetData* temp = _impl_.kind_.get_data_;
    _impl_.kind_.get_data_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_get_data(::alyncoin::net::GetData* get_data) {
  clear_kind();
  if (get_data) {
    set_has_get_data();
    _impl_.kind_.get_data_ = get_data;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.get_data)
}
inline ::alyncoin::net::GetData* Frame::_internal_mutable_get_data() {
  if (!_internal_has_get_data()) {
    clear_kind();
    set_has_get_data();
    _impl_.kind_.get_data_ = CreateMaybeMessage< ::alyncoin::net::GetData >(GetArenaForAllocation());
  }
  return _impl_.kind_.get_data_;
}
inline ::alyncoin::net::GetData* Frame::mutable_get_data() {
  ::alyncoin::net::GetData* _msg = _internal_mutable_get_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.get_data)
  return _msg;
}

// .alyncoin.BlockchainSyncProto blockchain_sync_request = 22;
inline bool Frame::_internal_has_blockchain_sync_request() const {
  return kind_case() == kBlockchainSyncRequest;
}
inline bool Frame::has_blockchain_sync_request() const {
  return _internal_has_blockchain_sync_request();
}
inline void Frame::set_has_blockchain_sync_request() {
  _impl_._oneof_case_[0] = kBlockchainSyncRequest;
}
inline ::alyncoin::BlockchainSyncProto* Frame::release_blockchain_sync_request() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.blockchain_sync_request)
  if (_internal_has_blockchain_sync_request()) {
    clear_has_kind();
    ::alyncoin::BlockchainSyncProto* temp = _impl_.kind_.blockchain_sync_request_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.blockchain_sync_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::BlockchainSyncProto& Frame::_internal_blockchain_sync_request() const {
  return _internal_has_blockchain_sync_request()
      ? *_impl_.kind_.blockchain_sync_request_
      : reinterpret_cast< ::alyncoin::BlockchainSyncProto&>(::alyncoin::_BlockchainSyncProto_default_instance_);
}
inline const ::alyncoin::BlockchainSyncProto& Frame::blockchain_sync_request() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.blockchain_sync_request)
  return _internal_blockchain_sync_request();
}
inline ::alyncoin::BlockchainSyncProto* Frame::unsafe_arena_release_blockchain_sync_request() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.blockchain_sync_request)
  if (_internal_has_blockchain_sync_request()) {
    clear_has_kind();
    ::alyncoin::BlockchainSyncProto* temp = _impl_.kind_.blockchain_sync_request_;
    _impl_.kind_.blockchain_sync_request_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_blockchain_sync_request(::alyncoin::BlockchainSyncProto* blockchain_sync_request) {
  clear_kind();
  if (blockchain_sync_request) {
    set_has_blockchain_sync_request();
    _impl_.kind_.blockchain_sync_request_ = blockchain_sync_request;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.blockchain_sync_request)
}
inline ::alyncoin::BlockchainSyncProto* Frame::_internal_mutable_blockchain_sync_request() {
  if (!_internal_has_blockchain_sync_request()) {
    clear_kind();
    set_has_blockchain_sync_request();
    _impl_.kind_.blockchain_sync_request_ = CreateMaybeMessage< ::alyncoin::BlockchainSyncProto >(GetArenaForAllocation());
  }
  return _impl_.kind_.blockchain_sync_request_;
}
inline ::alyncoin::BlockchainSyncProto* Frame::mutable_blockchain_sync_request() {
  ::alyncoin::BlockchainSyncProto* _msg = _internal_mutable_blockchain_sync_request();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.blockchain_sync_request)
  return _msg;
}

// .alyncoin.net.TransactionBroadcast tx_broadcast = 23;
inline bool Frame::_internal_has_tx_broadcast() const {
  return kind_case() == kTxBroadcast;
}
inline bool Frame::has_tx_broadcast() const {
  return _internal_has_tx_broadcast();
}
inline void Frame::set_has_tx_broadcast() {
  _impl_._oneof_case_[0] = kTxBroadcast;
}
inline void Frame::clear_tx_broadcast() {
  if (_internal_has_tx_broadcast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tx_broadcast_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TransactionBroadcast* Frame::release_tx_broadcast() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tx_broadcast)
  if (_internal_has_tx_broadcast()) {
    clear_has_kind();
    ::alyncoin::net::TransactionBroadcast* temp = _impl_.kind_.tx_broadcast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tx_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TransactionBroadcast& Frame::_internal_tx_broadcast() const {
  return _internal_has_tx_broadcast()
      ? *_impl_.kind_.tx_broadcast_
      : reinterpret_cast< ::alyncoin::net::TransactionBroadcast&>(::alyncoin::net::_TransactionBroadcast_default_instance_);
}
inline const ::alyncoin::net::TransactionBroadcast& Frame::tx_broadcast() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tx_broadcast)
  return _internal_tx_broadcast();
}
inline ::alyncoin::net::TransactionBroadcast* Frame::unsafe_arena_release_tx_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tx_broadcast)
  if (_internal_has_tx_broadcast()) {
    clear_has_kind();
    ::alyncoin::net::TransactionBroadcast* temp = _impl_.kind_.tx_broadcast_;
    _impl_.kind_.tx_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tx_broadcast(::alyncoin::net::TransactionBroadcast* tx_broadcast) {
  clear_kind();
  if (tx_broadcast) {
    set_has_tx_broadcast();
    _impl_.kind_.tx_broadcast_ = tx_broadcast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tx_broadcast)
}
inline ::alyncoin::net::TransactionBroadcast* Frame::_internal_mutable_tx_broadcast() {
  if (!_internal_has_tx_broadcast()) {
    clear_kind();
    set_has_tx_broadcast();
    _impl_.kind_.tx_broadcast_ = CreateMaybeMessage< ::alyncoin::net::TransactionBroadcast >(GetArenaForAllocation());
  }
  return _impl_.kind_.tx_broadcast_;
}
inline ::alyncoin::net::TransactionBroadcast* Frame::mutable_tx_broadcast() {
  ::alyncoin::net::TransactionBroadcast* _msg = _internal_mutable_tx_broadcast();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tx_broadcast)
  return _msg;
}

inline bool Frame::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Frame::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Frame::KindCase Frame::kind_case() const {
  return Frame::KindCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace net
}  // namespace alyncoin

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_5fframe_2eproto
