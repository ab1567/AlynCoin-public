#ifndef BLOCK_H
#define BLOCK_H

#include "crypto_utils.h"
#include "generated/block_protos.pb.h"
#include "generated/blockchain_protos.pb.h"
#include "crypto_protos.pb.h"
#include "generated/transaction_protos.pb.h"
#include "transaction.h"
#include "zk/winterfell_stark.h"
#include <cstddef>
#include <ctime>
#include <json/json.h>
#include <string>
#include <vector>

class Block {
private:
  int index;
  std::string previousHash;
  std::vector<Transaction> transactions;
  std::string hash;
  std::string minerAddress;
  int nonce;
  time_t timestamp;
  std::string blockSignature;
  std::string zkProof;
  std::string transactionsToString() const;
  std::string dilithiumSignature;
  std::string falconSignature;
  std::string publicKeyDilithium;
  std::string publicKeyFalcon;
  std::string merkleRoot;

public:
  std::string keccakHash;
  int difficulty;

  static constexpr double INITIAL_REWARD = 10.0;
  static constexpr double DECAY_RATE = 0.00005;

  // --- Constructors ---
  Block();
  Block(int index, const std::string &previousHash,
        const std::vector<Transaction> &transactions,
        const std::string &minerAddress, int difficulty, uint64_t timestamp,
        uint64_t nonce);
  Block(const Block &other);
  Block &operator=(const Block &other);

  // --- Getters ---
  int getIndex() const { return index; }
  std::string getPreviousHash() const { return previousHash; }
  const std::vector<Transaction> &getTransactions() const {
    return transactions;
  }
  std::string getHash() const { return hash; }
  std::string getMinerAddress() const { return minerAddress; }
  int getNonce() const { return nonce; }
  time_t getTimestamp() const { return timestamp; }
  std::string getBlockSignature() const { return blockSignature; }
  std::string getZkProof() const;
  void setZkProof(const std::string &proof);

  std::string getMerkleRoot() const { return merkleRoot; }
  std::string getTxRoot() const { return getTransactionsHash(); }

  const std::string &getDilithiumSignature() const {
    return dilithiumSignature;
  }
  const std::string &getFalconSignature() const { return falconSignature; }
  const std::string &getPublicKeyDilithium() const {
    return publicKeyDilithium;
  }
  const std::string &getPublicKeyFalcon() const { return publicKeyFalcon; }
  // --- Setters ---
  void setIndex(int idx) { index = idx; }
  void setPreviousHash(const std::string &prev) { previousHash = prev; }
  void setTransactions(const std::vector<Transaction> &txs) {
    transactions = txs;
  }
  void setHash(const std::string &value) { hash = value; }
  void setMinerAddress(const std::string &addr) { minerAddress = addr; }
  void setNonce(int value) { nonce = value; }
  void setSignature(const std::string &signature) {
    blockSignature = signature;
  }
  void setTimestamp(time_t ts) { timestamp = ts; }
  void setKeccakHash(const std::string &khash) { keccakHash = khash; }
  void setDifficulty(int diff) { difficulty = diff; }
  void setDilithiumSignature(const std::string &sig) {
    dilithiumSignature = sig;
  }
  void setFalconSignature(const std::string &sig) { falconSignature = sig; }
  void setMerkleRoot(const std::string &merkle) { merkleRoot = merkle; }

  // --- Other Functions ---
  bool isGenesisBlock() const {
    return index == 0 && previousHash == "00000000000000000000000000000000";
  }
  void incrementNonce() { nonce++; }
  std::string getTransactionsHash() const;
  bool mineBlock(int difficulty);
  void signBlock(const std::string &minerPrivateKeyPath);
  double calculateMiningReward(int blockIndex, int recentTxCount);
  bool hasValidProofOfWork() const;
  std::string calculateHash() const;
  bool verifyBlockSignature(const std::string &publicKeyPath) const;
  void computeKeccakHash();
  bool isValid(const std::string &prevHash) const;
  bool containsTransaction(const Transaction &tx) const;
  std::string getHashInput() const {
    return previousHash + std::to_string(timestamp) + std::to_string(nonce);
  }
  std::string generateRollupProof(const std::vector<Transaction> &offChainTxs);
  // --- Serialization / Deserialization ---
  void serializeToProtobuf(alyncoin::BlockProto &proto) const;
  bool deserializeFromProtobuf(const alyncoin::BlockProto &proto);
  static Block fromProto(const alyncoin::BlockProto &proto);

  Json::Value toJSON() const;
  static Block fromJSON(const Json::Value &blockJson);
  alyncoin::BlockProto toProtobuf() const;
};

#endif // BLOCK_H
