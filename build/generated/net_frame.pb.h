// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net_frame.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_net_5fframe_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_net_5fframe_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "block_protos.pb.h"
#include "blockchain_protos.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_net_5fframe_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_net_5fframe_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_net_5fframe_2eproto;
namespace alyncoin {
namespace net {
class BlockBatch;
struct BlockBatchDefaultTypeInternal;
extern BlockBatchDefaultTypeInternal _BlockBatch_default_instance_;
class BlockBroadcast;
struct BlockBroadcastDefaultTypeInternal;
extern BlockBroadcastDefaultTypeInternal _BlockBroadcast_default_instance_;
class EpochProof;
struct EpochProofDefaultTypeInternal;
extern EpochProofDefaultTypeInternal _EpochProof_default_instance_;
class Frame;
struct FrameDefaultTypeInternal;
extern FrameDefaultTypeInternal _Frame_default_instance_;
class Handshake;
struct HandshakeDefaultTypeInternal;
extern HandshakeDefaultTypeInternal _Handshake_default_instance_;
class HeightRequest;
struct HeightRequestDefaultTypeInternal;
extern HeightRequestDefaultTypeInternal _HeightRequest_default_instance_;
class HeightResponse;
struct HeightResponseDefaultTypeInternal;
extern HeightResponseDefaultTypeInternal _HeightResponse_default_instance_;
class Ping;
struct PingDefaultTypeInternal;
extern PingDefaultTypeInternal _Ping_default_instance_;
class Pong;
struct PongDefaultTypeInternal;
extern PongDefaultTypeInternal _Pong_default_instance_;
class SnapshotChunk;
struct SnapshotChunkDefaultTypeInternal;
extern SnapshotChunkDefaultTypeInternal _SnapshotChunk_default_instance_;
class SnapshotEnd;
struct SnapshotEndDefaultTypeInternal;
extern SnapshotEndDefaultTypeInternal _SnapshotEnd_default_instance_;
class TailBlocks;
struct TailBlocksDefaultTypeInternal;
extern TailBlocksDefaultTypeInternal _TailBlocks_default_instance_;
}  // namespace net
}  // namespace alyncoin
PROTOBUF_NAMESPACE_OPEN
template<> ::alyncoin::net::BlockBatch* Arena::CreateMaybeMessage<::alyncoin::net::BlockBatch>(Arena*);
template<> ::alyncoin::net::BlockBroadcast* Arena::CreateMaybeMessage<::alyncoin::net::BlockBroadcast>(Arena*);
template<> ::alyncoin::net::EpochProof* Arena::CreateMaybeMessage<::alyncoin::net::EpochProof>(Arena*);
template<> ::alyncoin::net::Frame* Arena::CreateMaybeMessage<::alyncoin::net::Frame>(Arena*);
template<> ::alyncoin::net::Handshake* Arena::CreateMaybeMessage<::alyncoin::net::Handshake>(Arena*);
template<> ::alyncoin::net::HeightRequest* Arena::CreateMaybeMessage<::alyncoin::net::HeightRequest>(Arena*);
template<> ::alyncoin::net::HeightResponse* Arena::CreateMaybeMessage<::alyncoin::net::HeightResponse>(Arena*);
template<> ::alyncoin::net::Ping* Arena::CreateMaybeMessage<::alyncoin::net::Ping>(Arena*);
template<> ::alyncoin::net::Pong* Arena::CreateMaybeMessage<::alyncoin::net::Pong>(Arena*);
template<> ::alyncoin::net::SnapshotChunk* Arena::CreateMaybeMessage<::alyncoin::net::SnapshotChunk>(Arena*);
template<> ::alyncoin::net::SnapshotEnd* Arena::CreateMaybeMessage<::alyncoin::net::SnapshotEnd>(Arena*);
template<> ::alyncoin::net::TailBlocks* Arena::CreateMaybeMessage<::alyncoin::net::TailBlocks>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace alyncoin {
namespace net {

// ===================================================================

class Handshake final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.Handshake) */ {
 public:
  inline Handshake() : Handshake(nullptr) {}
  ~Handshake() override;
  explicit PROTOBUF_CONSTEXPR Handshake(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Handshake(const Handshake& from);
  Handshake(Handshake&& from) noexcept
    : Handshake() {
    *this = ::std::move(from);
  }

  inline Handshake& operator=(const Handshake& from) {
    CopyFrom(from);
    return *this;
  }
  inline Handshake& operator=(Handshake&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Handshake& default_instance() {
    return *internal_default_instance();
  }
  static inline const Handshake* internal_default_instance() {
    return reinterpret_cast<const Handshake*>(
               &_Handshake_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Handshake& a, Handshake& b) {
    a.Swap(&b);
  }
  inline void Swap(Handshake* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Handshake* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Handshake* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Handshake>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Handshake& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Handshake& from) {
    Handshake::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Handshake* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Handshake";
  }
  protected:
  explicit Handshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 4,
    kVersionFieldNumber = 1,
    kNetworkIdFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // repeated string capabilities = 4;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  const std::string& capabilities(int index) const;
  std::string* mutable_capabilities(int index);
  void set_capabilities(int index, const std::string& value);
  void set_capabilities(int index, std::string&& value);
  void set_capabilities(int index, const char* value);
  void set_capabilities(int index, const char* value, size_t size);
  std::string* add_capabilities();
  void add_capabilities(const std::string& value);
  void add_capabilities(std::string&& value);
  void add_capabilities(const char* value);
  void add_capabilities(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& capabilities() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_capabilities();
  private:
  const std::string& _internal_capabilities(int index) const;
  std::string* _internal_add_capabilities();
  public:

  // string version = 1;
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // string network_id = 2;
  void clear_network_id();
  const std::string& network_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network_id();
  PROTOBUF_NODISCARD std::string* release_network_id();
  void set_allocated_network_id(std::string* network_id);
  private:
  const std::string& _internal_network_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network_id(const std::string& value);
  std::string* _internal_mutable_network_id();
  public:

  // uint64 height = 3;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.Handshake)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> capabilities_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_id_;
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Ping final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.Ping) */ {
 public:
  inline Ping() : Ping(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Ping(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ping(const Ping& from);
  Ping(Ping&& from) noexcept
    : Ping() {
    *this = ::std::move(from);
  }

  inline Ping& operator=(const Ping& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ping& operator=(Ping&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ping& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ping* internal_default_instance() {
    return reinterpret_cast<const Ping*>(
               &_Ping_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ping& a, Ping& b) {
    a.Swap(&b);
  }
  inline void Swap(Ping* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ping* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ping* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ping>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Ping& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Ping";
  }
  protected:
  explicit Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.Ping)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Pong final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.Pong) */ {
 public:
  inline Pong() : Pong(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Pong(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Pong(const Pong& from);
  Pong(Pong&& from) noexcept
    : Pong() {
    *this = ::std::move(from);
  }

  inline Pong& operator=(const Pong& from) {
    CopyFrom(from);
    return *this;
  }
  inline Pong& operator=(Pong&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Pong& default_instance() {
    return *internal_default_instance();
  }
  static inline const Pong* internal_default_instance() {
    return reinterpret_cast<const Pong*>(
               &_Pong_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Pong& a, Pong& b) {
    a.Swap(&b);
  }
  inline void Swap(Pong* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Pong* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Pong* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Pong>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Pong& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Pong";
  }
  protected:
  explicit Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.Pong)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.HeightRequest) */ {
 public:
  inline HeightRequest() : HeightRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeightRequest(const HeightRequest& from);
  HeightRequest(HeightRequest&& from) noexcept
    : HeightRequest() {
    *this = ::std::move(from);
  }

  inline HeightRequest& operator=(const HeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightRequest& operator=(HeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightRequest* internal_default_instance() {
    return reinterpret_cast<const HeightRequest*>(
               &_HeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HeightRequest& a, HeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeightRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeightRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeightRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.HeightRequest";
  }
  protected:
  explicit HeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class HeightResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.HeightResponse) */ {
 public:
  inline HeightResponse() : HeightResponse(nullptr) {}
  ~HeightResponse() override;
  explicit PROTOBUF_CONSTEXPR HeightResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeightResponse(const HeightResponse& from);
  HeightResponse(HeightResponse&& from) noexcept
    : HeightResponse() {
    *this = ::std::move(from);
  }

  inline HeightResponse& operator=(const HeightResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeightResponse& operator=(HeightResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeightResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeightResponse* internal_default_instance() {
    return reinterpret_cast<const HeightResponse*>(
               &_HeightResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(HeightResponse& a, HeightResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(HeightResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeightResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeightResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeightResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeightResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeightResponse& from) {
    HeightResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeightResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.HeightResponse";
  }
  protected:
  explicit HeightResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  uint64_t height() const;
  void set_height(uint64_t value);
  private:
  uint64_t _internal_height() const;
  void _internal_set_height(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.HeightResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint64_t height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockBroadcast final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.BlockBroadcast) */ {
 public:
  inline BlockBroadcast() : BlockBroadcast(nullptr) {}
  ~BlockBroadcast() override;
  explicit PROTOBUF_CONSTEXPR BlockBroadcast(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBroadcast(const BlockBroadcast& from);
  BlockBroadcast(BlockBroadcast&& from) noexcept
    : BlockBroadcast() {
    *this = ::std::move(from);
  }

  inline BlockBroadcast& operator=(const BlockBroadcast& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBroadcast& operator=(BlockBroadcast&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBroadcast& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBroadcast* internal_default_instance() {
    return reinterpret_cast<const BlockBroadcast*>(
               &_BlockBroadcast_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(BlockBroadcast& a, BlockBroadcast& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBroadcast* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBroadcast* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBroadcast* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBroadcast>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBroadcast& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBroadcast& from) {
    BlockBroadcast::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBroadcast* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.BlockBroadcast";
  }
  protected:
  explicit BlockBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .alyncoin.BlockProto block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::alyncoin::BlockProto& block() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockProto* release_block();
  ::alyncoin::BlockProto* mutable_block();
  void set_allocated_block(::alyncoin::BlockProto* block);
  private:
  const ::alyncoin::BlockProto& _internal_block() const;
  ::alyncoin::BlockProto* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::alyncoin::BlockProto* block);
  ::alyncoin::BlockProto* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockBroadcast)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::alyncoin::BlockProto* block_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class BlockBatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.BlockBatch) */ {
 public:
  inline BlockBatch() : BlockBatch(nullptr) {}
  ~BlockBatch() override;
  explicit PROTOBUF_CONSTEXPR BlockBatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockBatch(const BlockBatch& from);
  BlockBatch(BlockBatch&& from) noexcept
    : BlockBatch() {
    *this = ::std::move(from);
  }

  inline BlockBatch& operator=(const BlockBatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockBatch& operator=(BlockBatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockBatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockBatch* internal_default_instance() {
    return reinterpret_cast<const BlockBatch*>(
               &_BlockBatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockBatch& a, BlockBatch& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockBatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockBatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BlockBatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BlockBatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockBatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BlockBatch& from) {
    BlockBatch::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockBatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.BlockBatch";
  }
  protected:
  explicit BlockBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainFieldNumber = 1,
  };
  // .alyncoin.BlockchainProto chain = 1;
  bool has_chain() const;
  private:
  bool _internal_has_chain() const;
  public:
  void clear_chain();
  const ::alyncoin::BlockchainProto& chain() const;
  PROTOBUF_NODISCARD ::alyncoin::BlockchainProto* release_chain();
  ::alyncoin::BlockchainProto* mutable_chain();
  void set_allocated_chain(::alyncoin::BlockchainProto* chain);
  private:
  const ::alyncoin::BlockchainProto& _internal_chain() const;
  ::alyncoin::BlockchainProto* _internal_mutable_chain();
  public:
  void unsafe_arena_set_allocated_chain(
      ::alyncoin::BlockchainProto* chain);
  ::alyncoin::BlockchainProto* unsafe_arena_release_chain();

  // @@protoc_insertion_point(class_scope:alyncoin.net.BlockBatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::alyncoin::BlockchainProto* chain_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotChunk) */ {
 public:
  inline SnapshotChunk() : SnapshotChunk(nullptr) {}
  ~SnapshotChunk() override;
  explicit PROTOBUF_CONSTEXPR SnapshotChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotChunk(const SnapshotChunk& from);
  SnapshotChunk(SnapshotChunk&& from) noexcept
    : SnapshotChunk() {
    *this = ::std::move(from);
  }

  inline SnapshotChunk& operator=(const SnapshotChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotChunk& operator=(SnapshotChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotChunk* internal_default_instance() {
    return reinterpret_cast<const SnapshotChunk*>(
               &_SnapshotChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SnapshotChunk& a, SnapshotChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotChunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SnapshotChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SnapshotChunk& from) {
    SnapshotChunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SnapshotChunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.SnapshotChunk";
  }
  protected:
  explicit SnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class SnapshotEnd final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:alyncoin.net.SnapshotEnd) */ {
 public:
  inline SnapshotEnd() : SnapshotEnd(nullptr) {}
  explicit PROTOBUF_CONSTEXPR SnapshotEnd(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SnapshotEnd(const SnapshotEnd& from);
  SnapshotEnd(SnapshotEnd&& from) noexcept
    : SnapshotEnd() {
    *this = ::std::move(from);
  }

  inline SnapshotEnd& operator=(const SnapshotEnd& from) {
    CopyFrom(from);
    return *this;
  }
  inline SnapshotEnd& operator=(SnapshotEnd&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SnapshotEnd& default_instance() {
    return *internal_default_instance();
  }
  static inline const SnapshotEnd* internal_default_instance() {
    return reinterpret_cast<const SnapshotEnd*>(
               &_SnapshotEnd_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(SnapshotEnd& a, SnapshotEnd& b) {
    a.Swap(&b);
  }
  inline void Swap(SnapshotEnd* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SnapshotEnd* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SnapshotEnd* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SnapshotEnd>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const SnapshotEnd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const SnapshotEnd& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.SnapshotEnd";
  }
  protected:
  explicit SnapshotEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:alyncoin.net.SnapshotEnd)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class TailBlocks final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.TailBlocks) */ {
 public:
  inline TailBlocks() : TailBlocks(nullptr) {}
  ~TailBlocks() override;
  explicit PROTOBUF_CONSTEXPR TailBlocks(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TailBlocks(const TailBlocks& from);
  TailBlocks(TailBlocks&& from) noexcept
    : TailBlocks() {
    *this = ::std::move(from);
  }

  inline TailBlocks& operator=(const TailBlocks& from) {
    CopyFrom(from);
    return *this;
  }
  inline TailBlocks& operator=(TailBlocks&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TailBlocks& default_instance() {
    return *internal_default_instance();
  }
  static inline const TailBlocks* internal_default_instance() {
    return reinterpret_cast<const TailBlocks*>(
               &_TailBlocks_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(TailBlocks& a, TailBlocks& b) {
    a.Swap(&b);
  }
  inline void Swap(TailBlocks* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TailBlocks* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TailBlocks* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TailBlocks>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TailBlocks& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TailBlocks& from) {
    TailBlocks::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TailBlocks* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.TailBlocks";
  }
  protected:
  explicit TailBlocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlocksFieldNumber = 1,
  };
  // repeated .alyncoin.BlockProto blocks = 1;
  int blocks_size() const;
  private:
  int _internal_blocks_size() const;
  public:
  void clear_blocks();
  ::alyncoin::BlockProto* mutable_blocks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >*
      mutable_blocks();
  private:
  const ::alyncoin::BlockProto& _internal_blocks(int index) const;
  ::alyncoin::BlockProto* _internal_add_blocks();
  public:
  const ::alyncoin::BlockProto& blocks(int index) const;
  ::alyncoin::BlockProto* add_blocks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >&
      blocks() const;

  // @@protoc_insertion_point(class_scope:alyncoin.net.TailBlocks)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto > blocks_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class EpochProof final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.EpochProof) */ {
 public:
  inline EpochProof() : EpochProof(nullptr) {}
  ~EpochProof() override;
  explicit PROTOBUF_CONSTEXPR EpochProof(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EpochProof(const EpochProof& from);
  EpochProof(EpochProof&& from) noexcept
    : EpochProof() {
    *this = ::std::move(from);
  }

  inline EpochProof& operator=(const EpochProof& from) {
    CopyFrom(from);
    return *this;
  }
  inline EpochProof& operator=(EpochProof&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EpochProof& default_instance() {
    return *internal_default_instance();
  }
  static inline const EpochProof* internal_default_instance() {
    return reinterpret_cast<const EpochProof*>(
               &_EpochProof_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(EpochProof& a, EpochProof& b) {
    a.Swap(&b);
  }
  inline void Swap(EpochProof* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EpochProof* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  EpochProof* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<EpochProof>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EpochProof& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const EpochProof& from) {
    EpochProof::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EpochProof* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.EpochProof";
  }
  protected:
  explicit EpochProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // @@protoc_insertion_point(class_scope:alyncoin.net.EpochProof)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// -------------------------------------------------------------------

class Frame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:alyncoin.net.Frame) */ {
 public:
  inline Frame() : Frame(nullptr) {}
  ~Frame() override;
  explicit PROTOBUF_CONSTEXPR Frame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Frame(const Frame& from);
  Frame(Frame&& from) noexcept
    : Frame() {
    *this = ::std::move(from);
  }

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }
  inline Frame& operator=(Frame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Frame& default_instance() {
    return *internal_default_instance();
  }
  enum KindCase {
    kHandshake = 1,
    kPing = 2,
    kPong = 3,
    kHeightReq = 4,
    kHeightRes = 5,
    kBlockBroadcast = 6,
    kBlockBatch = 7,
    kSnapshotChunk = 8,
    kSnapshotEnd = 9,
    kTailBlocks = 10,
    kAggProof = 11,
    KIND_NOT_SET = 0,
  };

  static inline const Frame* internal_default_instance() {
    return reinterpret_cast<const Frame*>(
               &_Frame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Frame& a, Frame& b) {
    a.Swap(&b);
  }
  inline void Swap(Frame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Frame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Frame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Frame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Frame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Frame& from) {
    Frame::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Frame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "alyncoin.net.Frame";
  }
  protected:
  explicit Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandshakeFieldNumber = 1,
    kPingFieldNumber = 2,
    kPongFieldNumber = 3,
    kHeightReqFieldNumber = 4,
    kHeightResFieldNumber = 5,
    kBlockBroadcastFieldNumber = 6,
    kBlockBatchFieldNumber = 7,
    kSnapshotChunkFieldNumber = 8,
    kSnapshotEndFieldNumber = 9,
    kTailBlocksFieldNumber = 10,
    kAggProofFieldNumber = 11,
  };
  // .alyncoin.net.Handshake handshake = 1;
  bool has_handshake() const;
  private:
  bool _internal_has_handshake() const;
  public:
  void clear_handshake();
  const ::alyncoin::net::Handshake& handshake() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Handshake* release_handshake();
  ::alyncoin::net::Handshake* mutable_handshake();
  void set_allocated_handshake(::alyncoin::net::Handshake* handshake);
  private:
  const ::alyncoin::net::Handshake& _internal_handshake() const;
  ::alyncoin::net::Handshake* _internal_mutable_handshake();
  public:
  void unsafe_arena_set_allocated_handshake(
      ::alyncoin::net::Handshake* handshake);
  ::alyncoin::net::Handshake* unsafe_arena_release_handshake();

  // .alyncoin.net.Ping ping = 2;
  bool has_ping() const;
  private:
  bool _internal_has_ping() const;
  public:
  void clear_ping();
  const ::alyncoin::net::Ping& ping() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Ping* release_ping();
  ::alyncoin::net::Ping* mutable_ping();
  void set_allocated_ping(::alyncoin::net::Ping* ping);
  private:
  const ::alyncoin::net::Ping& _internal_ping() const;
  ::alyncoin::net::Ping* _internal_mutable_ping();
  public:
  void unsafe_arena_set_allocated_ping(
      ::alyncoin::net::Ping* ping);
  ::alyncoin::net::Ping* unsafe_arena_release_ping();

  // .alyncoin.net.Pong pong = 3;
  bool has_pong() const;
  private:
  bool _internal_has_pong() const;
  public:
  void clear_pong();
  const ::alyncoin::net::Pong& pong() const;
  PROTOBUF_NODISCARD ::alyncoin::net::Pong* release_pong();
  ::alyncoin::net::Pong* mutable_pong();
  void set_allocated_pong(::alyncoin::net::Pong* pong);
  private:
  const ::alyncoin::net::Pong& _internal_pong() const;
  ::alyncoin::net::Pong* _internal_mutable_pong();
  public:
  void unsafe_arena_set_allocated_pong(
      ::alyncoin::net::Pong* pong);
  ::alyncoin::net::Pong* unsafe_arena_release_pong();

  // .alyncoin.net.HeightRequest height_req = 4;
  bool has_height_req() const;
  private:
  bool _internal_has_height_req() const;
  public:
  void clear_height_req();
  const ::alyncoin::net::HeightRequest& height_req() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightRequest* release_height_req();
  ::alyncoin::net::HeightRequest* mutable_height_req();
  void set_allocated_height_req(::alyncoin::net::HeightRequest* height_req);
  private:
  const ::alyncoin::net::HeightRequest& _internal_height_req() const;
  ::alyncoin::net::HeightRequest* _internal_mutable_height_req();
  public:
  void unsafe_arena_set_allocated_height_req(
      ::alyncoin::net::HeightRequest* height_req);
  ::alyncoin::net::HeightRequest* unsafe_arena_release_height_req();

  // .alyncoin.net.HeightResponse height_res = 5;
  bool has_height_res() const;
  private:
  bool _internal_has_height_res() const;
  public:
  void clear_height_res();
  const ::alyncoin::net::HeightResponse& height_res() const;
  PROTOBUF_NODISCARD ::alyncoin::net::HeightResponse* release_height_res();
  ::alyncoin::net::HeightResponse* mutable_height_res();
  void set_allocated_height_res(::alyncoin::net::HeightResponse* height_res);
  private:
  const ::alyncoin::net::HeightResponse& _internal_height_res() const;
  ::alyncoin::net::HeightResponse* _internal_mutable_height_res();
  public:
  void unsafe_arena_set_allocated_height_res(
      ::alyncoin::net::HeightResponse* height_res);
  ::alyncoin::net::HeightResponse* unsafe_arena_release_height_res();

  // .alyncoin.net.BlockBroadcast block_broadcast = 6;
  bool has_block_broadcast() const;
  private:
  bool _internal_has_block_broadcast() const;
  public:
  void clear_block_broadcast();
  const ::alyncoin::net::BlockBroadcast& block_broadcast() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockBroadcast* release_block_broadcast();
  ::alyncoin::net::BlockBroadcast* mutable_block_broadcast();
  void set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* block_broadcast);
  private:
  const ::alyncoin::net::BlockBroadcast& _internal_block_broadcast() const;
  ::alyncoin::net::BlockBroadcast* _internal_mutable_block_broadcast();
  public:
  void unsafe_arena_set_allocated_block_broadcast(
      ::alyncoin::net::BlockBroadcast* block_broadcast);
  ::alyncoin::net::BlockBroadcast* unsafe_arena_release_block_broadcast();

  // .alyncoin.net.BlockBatch block_batch = 7;
  bool has_block_batch() const;
  private:
  bool _internal_has_block_batch() const;
  public:
  void clear_block_batch();
  const ::alyncoin::net::BlockBatch& block_batch() const;
  PROTOBUF_NODISCARD ::alyncoin::net::BlockBatch* release_block_batch();
  ::alyncoin::net::BlockBatch* mutable_block_batch();
  void set_allocated_block_batch(::alyncoin::net::BlockBatch* block_batch);
  private:
  const ::alyncoin::net::BlockBatch& _internal_block_batch() const;
  ::alyncoin::net::BlockBatch* _internal_mutable_block_batch();
  public:
  void unsafe_arena_set_allocated_block_batch(
      ::alyncoin::net::BlockBatch* block_batch);
  ::alyncoin::net::BlockBatch* unsafe_arena_release_block_batch();

  // .alyncoin.net.SnapshotChunk snapshot_chunk = 8;
  bool has_snapshot_chunk() const;
  private:
  bool _internal_has_snapshot_chunk() const;
  public:
  void clear_snapshot_chunk();
  const ::alyncoin::net::SnapshotChunk& snapshot_chunk() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotChunk* release_snapshot_chunk();
  ::alyncoin::net::SnapshotChunk* mutable_snapshot_chunk();
  void set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* snapshot_chunk);
  private:
  const ::alyncoin::net::SnapshotChunk& _internal_snapshot_chunk() const;
  ::alyncoin::net::SnapshotChunk* _internal_mutable_snapshot_chunk();
  public:
  void unsafe_arena_set_allocated_snapshot_chunk(
      ::alyncoin::net::SnapshotChunk* snapshot_chunk);
  ::alyncoin::net::SnapshotChunk* unsafe_arena_release_snapshot_chunk();

  // .alyncoin.net.SnapshotEnd snapshot_end = 9;
  bool has_snapshot_end() const;
  private:
  bool _internal_has_snapshot_end() const;
  public:
  void clear_snapshot_end();
  const ::alyncoin::net::SnapshotEnd& snapshot_end() const;
  PROTOBUF_NODISCARD ::alyncoin::net::SnapshotEnd* release_snapshot_end();
  ::alyncoin::net::SnapshotEnd* mutable_snapshot_end();
  void set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* snapshot_end);
  private:
  const ::alyncoin::net::SnapshotEnd& _internal_snapshot_end() const;
  ::alyncoin::net::SnapshotEnd* _internal_mutable_snapshot_end();
  public:
  void unsafe_arena_set_allocated_snapshot_end(
      ::alyncoin::net::SnapshotEnd* snapshot_end);
  ::alyncoin::net::SnapshotEnd* unsafe_arena_release_snapshot_end();

  // .alyncoin.net.TailBlocks tail_blocks = 10;
  bool has_tail_blocks() const;
  private:
  bool _internal_has_tail_blocks() const;
  public:
  void clear_tail_blocks();
  const ::alyncoin::net::TailBlocks& tail_blocks() const;
  PROTOBUF_NODISCARD ::alyncoin::net::TailBlocks* release_tail_blocks();
  ::alyncoin::net::TailBlocks* mutable_tail_blocks();
  void set_allocated_tail_blocks(::alyncoin::net::TailBlocks* tail_blocks);
  private:
  const ::alyncoin::net::TailBlocks& _internal_tail_blocks() const;
  ::alyncoin::net::TailBlocks* _internal_mutable_tail_blocks();
  public:
  void unsafe_arena_set_allocated_tail_blocks(
      ::alyncoin::net::TailBlocks* tail_blocks);
  ::alyncoin::net::TailBlocks* unsafe_arena_release_tail_blocks();

  // .alyncoin.net.EpochProof agg_proof = 11;
  bool has_agg_proof() const;
  private:
  bool _internal_has_agg_proof() const;
  public:
  void clear_agg_proof();
  const ::alyncoin::net::EpochProof& agg_proof() const;
  PROTOBUF_NODISCARD ::alyncoin::net::EpochProof* release_agg_proof();
  ::alyncoin::net::EpochProof* mutable_agg_proof();
  void set_allocated_agg_proof(::alyncoin::net::EpochProof* agg_proof);
  private:
  const ::alyncoin::net::EpochProof& _internal_agg_proof() const;
  ::alyncoin::net::EpochProof* _internal_mutable_agg_proof();
  public:
  void unsafe_arena_set_allocated_agg_proof(
      ::alyncoin::net::EpochProof* agg_proof);
  ::alyncoin::net::EpochProof* unsafe_arena_release_agg_proof();

  void clear_kind();
  KindCase kind_case() const;
  // @@protoc_insertion_point(class_scope:alyncoin.net.Frame)
 private:
  class _Internal;
  void set_has_handshake();
  void set_has_ping();
  void set_has_pong();
  void set_has_height_req();
  void set_has_height_res();
  void set_has_block_broadcast();
  void set_has_block_batch();
  void set_has_snapshot_chunk();
  void set_has_snapshot_end();
  void set_has_tail_blocks();
  void set_has_agg_proof();

  inline bool has_kind() const;
  inline void clear_has_kind();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union KindUnion {
      constexpr KindUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::alyncoin::net::Handshake* handshake_;
      ::alyncoin::net::Ping* ping_;
      ::alyncoin::net::Pong* pong_;
      ::alyncoin::net::HeightRequest* height_req_;
      ::alyncoin::net::HeightResponse* height_res_;
      ::alyncoin::net::BlockBroadcast* block_broadcast_;
      ::alyncoin::net::BlockBatch* block_batch_;
      ::alyncoin::net::SnapshotChunk* snapshot_chunk_;
      ::alyncoin::net::SnapshotEnd* snapshot_end_;
      ::alyncoin::net::TailBlocks* tail_blocks_;
      ::alyncoin::net::EpochProof* agg_proof_;
    } kind_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_net_5fframe_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Handshake

// string version = 1;
inline void Handshake::clear_version() {
  _impl_.version_.ClearToEmpty();
}
inline const std::string& Handshake::version() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Handshake::set_version(ArgT0&& arg0, ArgT... args) {
 
 _impl_.version_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.version)
}
inline std::string* Handshake::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.version)
  return _s;
}
inline const std::string& Handshake::_internal_version() const {
  return _impl_.version_.Get();
}
inline void Handshake::_internal_set_version(const std::string& value) {
  
  _impl_.version_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_version() {
  
  return _impl_.version_.Mutable(GetArenaForAllocation());
}
inline std::string* Handshake::release_version() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.version)
  return _impl_.version_.Release();
}
inline void Handshake::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    
  } else {
    
  }
  _impl_.version_.SetAllocated(version, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.version_.IsDefault()) {
    _impl_.version_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.version)
}

// string network_id = 2;
inline void Handshake::clear_network_id() {
  _impl_.network_id_.ClearToEmpty();
}
inline const std::string& Handshake::network_id() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.network_id)
  return _internal_network_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Handshake::set_network_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.network_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.network_id)
}
inline std::string* Handshake::mutable_network_id() {
  std::string* _s = _internal_mutable_network_id();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.network_id)
  return _s;
}
inline const std::string& Handshake::_internal_network_id() const {
  return _impl_.network_id_.Get();
}
inline void Handshake::_internal_set_network_id(const std::string& value) {
  
  _impl_.network_id_.Set(value, GetArenaForAllocation());
}
inline std::string* Handshake::_internal_mutable_network_id() {
  
  return _impl_.network_id_.Mutable(GetArenaForAllocation());
}
inline std::string* Handshake::release_network_id() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Handshake.network_id)
  return _impl_.network_id_.Release();
}
inline void Handshake::set_allocated_network_id(std::string* network_id) {
  if (network_id != nullptr) {
    
  } else {
    
  }
  _impl_.network_id_.SetAllocated(network_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.network_id_.IsDefault()) {
    _impl_.network_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Handshake.network_id)
}

// uint64 height = 3;
inline void Handshake::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t Handshake::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t Handshake::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.height)
  return _internal_height();
}
inline void Handshake::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void Handshake::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.height)
}

// repeated string capabilities = 4;
inline int Handshake::_internal_capabilities_size() const {
  return _impl_.capabilities_.size();
}
inline int Handshake::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void Handshake::clear_capabilities() {
  _impl_.capabilities_.Clear();
}
inline std::string* Handshake::add_capabilities() {
  std::string* _s = _internal_add_capabilities();
  // @@protoc_insertion_point(field_add_mutable:alyncoin.net.Handshake.capabilities)
  return _s;
}
inline const std::string& Handshake::_internal_capabilities(int index) const {
  return _impl_.capabilities_.Get(index);
}
inline const std::string& Handshake::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Handshake.capabilities)
  return _internal_capabilities(index);
}
inline std::string* Handshake::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Handshake.capabilities)
  return _impl_.capabilities_.Mutable(index);
}
inline void Handshake::set_capabilities(int index, const std::string& value) {
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::set_capabilities(int index, std::string&& value) {
  _impl_.capabilities_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::set_capabilities(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::set_capabilities(int index, const char* value, size_t size) {
  _impl_.capabilities_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:alyncoin.net.Handshake.capabilities)
}
inline std::string* Handshake::_internal_add_capabilities() {
  return _impl_.capabilities_.Add();
}
inline void Handshake::add_capabilities(const std::string& value) {
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::add_capabilities(std::string&& value) {
  _impl_.capabilities_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::add_capabilities(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.capabilities_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:alyncoin.net.Handshake.capabilities)
}
inline void Handshake::add_capabilities(const char* value, size_t size) {
  _impl_.capabilities_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:alyncoin.net.Handshake.capabilities)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Handshake::capabilities() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.Handshake.capabilities)
  return _impl_.capabilities_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Handshake::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.Handshake.capabilities)
  return &_impl_.capabilities_;
}

// -------------------------------------------------------------------

// Ping

// -------------------------------------------------------------------

// Pong

// -------------------------------------------------------------------

// HeightRequest

// -------------------------------------------------------------------

// HeightResponse

// uint64 height = 1;
inline void HeightResponse::clear_height() {
  _impl_.height_ = uint64_t{0u};
}
inline uint64_t HeightResponse::_internal_height() const {
  return _impl_.height_;
}
inline uint64_t HeightResponse::height() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.HeightResponse.height)
  return _internal_height();
}
inline void HeightResponse::_internal_set_height(uint64_t value) {
  
  _impl_.height_ = value;
}
inline void HeightResponse::set_height(uint64_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:alyncoin.net.HeightResponse.height)
}

// -------------------------------------------------------------------

// BlockBroadcast

// .alyncoin.BlockProto block = 1;
inline bool BlockBroadcast::_internal_has_block() const {
  return this != internal_default_instance() && _impl_.block_ != nullptr;
}
inline bool BlockBroadcast::has_block() const {
  return _internal_has_block();
}
inline const ::alyncoin::BlockProto& BlockBroadcast::_internal_block() const {
  const ::alyncoin::BlockProto* p = _impl_.block_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockProto&>(
      ::alyncoin::_BlockProto_default_instance_);
}
inline const ::alyncoin::BlockProto& BlockBroadcast::block() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockBroadcast.block)
  return _internal_block();
}
inline void BlockBroadcast::unsafe_arena_set_allocated_block(
    ::alyncoin::BlockProto* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  _impl_.block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockBroadcast.block)
}
inline ::alyncoin::BlockProto* BlockBroadcast::release_block() {
  
  ::alyncoin::BlockProto* temp = _impl_.block_;
  _impl_.block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alyncoin::BlockProto* BlockBroadcast::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockBroadcast.block)
  
  ::alyncoin::BlockProto* temp = _impl_.block_;
  _impl_.block_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockProto* BlockBroadcast::_internal_mutable_block() {
  
  if (_impl_.block_ == nullptr) {
    auto* p = CreateMaybeMessage<::alyncoin::BlockProto>(GetArenaForAllocation());
    _impl_.block_ = p;
  }
  return _impl_.block_;
}
inline ::alyncoin::BlockProto* BlockBroadcast::mutable_block() {
  ::alyncoin::BlockProto* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockBroadcast.block)
  return _msg;
}
inline void BlockBroadcast::set_allocated_block(::alyncoin::BlockProto* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.block_);
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block));
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.block_ = block;
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockBroadcast.block)
}

// -------------------------------------------------------------------

// BlockBatch

// .alyncoin.BlockchainProto chain = 1;
inline bool BlockBatch::_internal_has_chain() const {
  return this != internal_default_instance() && _impl_.chain_ != nullptr;
}
inline bool BlockBatch::has_chain() const {
  return _internal_has_chain();
}
inline const ::alyncoin::BlockchainProto& BlockBatch::_internal_chain() const {
  const ::alyncoin::BlockchainProto* p = _impl_.chain_;
  return p != nullptr ? *p : reinterpret_cast<const ::alyncoin::BlockchainProto&>(
      ::alyncoin::_BlockchainProto_default_instance_);
}
inline const ::alyncoin::BlockchainProto& BlockBatch::chain() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.BlockBatch.chain)
  return _internal_chain();
}
inline void BlockBatch::unsafe_arena_set_allocated_chain(
    ::alyncoin::BlockchainProto* chain) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chain_);
  }
  _impl_.chain_ = chain;
  if (chain) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.BlockBatch.chain)
}
inline ::alyncoin::BlockchainProto* BlockBatch::release_chain() {
  
  ::alyncoin::BlockchainProto* temp = _impl_.chain_;
  _impl_.chain_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::alyncoin::BlockchainProto* BlockBatch::unsafe_arena_release_chain() {
  // @@protoc_insertion_point(field_release:alyncoin.net.BlockBatch.chain)
  
  ::alyncoin::BlockchainProto* temp = _impl_.chain_;
  _impl_.chain_ = nullptr;
  return temp;
}
inline ::alyncoin::BlockchainProto* BlockBatch::_internal_mutable_chain() {
  
  if (_impl_.chain_ == nullptr) {
    auto* p = CreateMaybeMessage<::alyncoin::BlockchainProto>(GetArenaForAllocation());
    _impl_.chain_ = p;
  }
  return _impl_.chain_;
}
inline ::alyncoin::BlockchainProto* BlockBatch::mutable_chain() {
  ::alyncoin::BlockchainProto* _msg = _internal_mutable_chain();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.BlockBatch.chain)
  return _msg;
}
inline void BlockBatch::set_allocated_chain(::alyncoin::BlockchainProto* chain) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.chain_);
  }
  if (chain) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(chain));
    if (message_arena != submessage_arena) {
      chain = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, chain, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.chain_ = chain;
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.BlockBatch.chain)
}

// -------------------------------------------------------------------

// SnapshotChunk

// bytes data = 1;
inline void SnapshotChunk::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& SnapshotChunk::data() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.SnapshotChunk.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SnapshotChunk::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.SnapshotChunk.data)
}
inline std::string* SnapshotChunk::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.SnapshotChunk.data)
  return _s;
}
inline const std::string& SnapshotChunk::_internal_data() const {
  return _impl_.data_.Get();
}
inline void SnapshotChunk::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* SnapshotChunk::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* SnapshotChunk::release_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.SnapshotChunk.data)
  return _impl_.data_.Release();
}
inline void SnapshotChunk::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.SnapshotChunk.data)
}

// -------------------------------------------------------------------

// SnapshotEnd

// -------------------------------------------------------------------

// TailBlocks

// repeated .alyncoin.BlockProto blocks = 1;
inline int TailBlocks::_internal_blocks_size() const {
  return _impl_.blocks_.size();
}
inline int TailBlocks::blocks_size() const {
  return _internal_blocks_size();
}
inline ::alyncoin::BlockProto* TailBlocks::mutable_blocks(int index) {
  // @@protoc_insertion_point(field_mutable:alyncoin.net.TailBlocks.blocks)
  return _impl_.blocks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >*
TailBlocks::mutable_blocks() {
  // @@protoc_insertion_point(field_mutable_list:alyncoin.net.TailBlocks.blocks)
  return &_impl_.blocks_;
}
inline const ::alyncoin::BlockProto& TailBlocks::_internal_blocks(int index) const {
  return _impl_.blocks_.Get(index);
}
inline const ::alyncoin::BlockProto& TailBlocks::blocks(int index) const {
  // @@protoc_insertion_point(field_get:alyncoin.net.TailBlocks.blocks)
  return _internal_blocks(index);
}
inline ::alyncoin::BlockProto* TailBlocks::_internal_add_blocks() {
  return _impl_.blocks_.Add();
}
inline ::alyncoin::BlockProto* TailBlocks::add_blocks() {
  ::alyncoin::BlockProto* _add = _internal_add_blocks();
  // @@protoc_insertion_point(field_add:alyncoin.net.TailBlocks.blocks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::alyncoin::BlockProto >&
TailBlocks::blocks() const {
  // @@protoc_insertion_point(field_list:alyncoin.net.TailBlocks.blocks)
  return _impl_.blocks_;
}

// -------------------------------------------------------------------

// EpochProof

// bytes data = 1;
inline void EpochProof::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& EpochProof::data() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.EpochProof.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EpochProof::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:alyncoin.net.EpochProof.data)
}
inline std::string* EpochProof::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.EpochProof.data)
  return _s;
}
inline const std::string& EpochProof::_internal_data() const {
  return _impl_.data_.Get();
}
inline void EpochProof::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* EpochProof::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* EpochProof::release_data() {
  // @@protoc_insertion_point(field_release:alyncoin.net.EpochProof.data)
  return _impl_.data_.Release();
}
inline void EpochProof::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.EpochProof.data)
}

// -------------------------------------------------------------------

// Frame

// .alyncoin.net.Handshake handshake = 1;
inline bool Frame::_internal_has_handshake() const {
  return kind_case() == kHandshake;
}
inline bool Frame::has_handshake() const {
  return _internal_has_handshake();
}
inline void Frame::set_has_handshake() {
  _impl_._oneof_case_[0] = kHandshake;
}
inline void Frame::clear_handshake() {
  if (_internal_has_handshake()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.handshake_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Handshake* Frame::release_handshake() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.handshake)
  if (_internal_has_handshake()) {
    clear_has_kind();
    ::alyncoin::net::Handshake* temp = _impl_.kind_.handshake_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Handshake& Frame::_internal_handshake() const {
  return _internal_has_handshake()
      ? *_impl_.kind_.handshake_
      : reinterpret_cast< ::alyncoin::net::Handshake&>(::alyncoin::net::_Handshake_default_instance_);
}
inline const ::alyncoin::net::Handshake& Frame::handshake() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.handshake)
  return _internal_handshake();
}
inline ::alyncoin::net::Handshake* Frame::unsafe_arena_release_handshake() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.handshake)
  if (_internal_has_handshake()) {
    clear_has_kind();
    ::alyncoin::net::Handshake* temp = _impl_.kind_.handshake_;
    _impl_.kind_.handshake_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_handshake(::alyncoin::net::Handshake* handshake) {
  clear_kind();
  if (handshake) {
    set_has_handshake();
    _impl_.kind_.handshake_ = handshake;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.handshake)
}
inline ::alyncoin::net::Handshake* Frame::_internal_mutable_handshake() {
  if (!_internal_has_handshake()) {
    clear_kind();
    set_has_handshake();
    _impl_.kind_.handshake_ = CreateMaybeMessage< ::alyncoin::net::Handshake >(GetArenaForAllocation());
  }
  return _impl_.kind_.handshake_;
}
inline ::alyncoin::net::Handshake* Frame::mutable_handshake() {
  ::alyncoin::net::Handshake* _msg = _internal_mutable_handshake();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.handshake)
  return _msg;
}

// .alyncoin.net.Ping ping = 2;
inline bool Frame::_internal_has_ping() const {
  return kind_case() == kPing;
}
inline bool Frame::has_ping() const {
  return _internal_has_ping();
}
inline void Frame::set_has_ping() {
  _impl_._oneof_case_[0] = kPing;
}
inline void Frame::clear_ping() {
  if (_internal_has_ping()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.ping_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Ping* Frame::release_ping() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.ping)
  if (_internal_has_ping()) {
    clear_has_kind();
    ::alyncoin::net::Ping* temp = _impl_.kind_.ping_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Ping& Frame::_internal_ping() const {
  return _internal_has_ping()
      ? *_impl_.kind_.ping_
      : reinterpret_cast< ::alyncoin::net::Ping&>(::alyncoin::net::_Ping_default_instance_);
}
inline const ::alyncoin::net::Ping& Frame::ping() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.ping)
  return _internal_ping();
}
inline ::alyncoin::net::Ping* Frame::unsafe_arena_release_ping() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.ping)
  if (_internal_has_ping()) {
    clear_has_kind();
    ::alyncoin::net::Ping* temp = _impl_.kind_.ping_;
    _impl_.kind_.ping_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_ping(::alyncoin::net::Ping* ping) {
  clear_kind();
  if (ping) {
    set_has_ping();
    _impl_.kind_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.ping)
}
inline ::alyncoin::net::Ping* Frame::_internal_mutable_ping() {
  if (!_internal_has_ping()) {
    clear_kind();
    set_has_ping();
    _impl_.kind_.ping_ = CreateMaybeMessage< ::alyncoin::net::Ping >(GetArenaForAllocation());
  }
  return _impl_.kind_.ping_;
}
inline ::alyncoin::net::Ping* Frame::mutable_ping() {
  ::alyncoin::net::Ping* _msg = _internal_mutable_ping();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.ping)
  return _msg;
}

// .alyncoin.net.Pong pong = 3;
inline bool Frame::_internal_has_pong() const {
  return kind_case() == kPong;
}
inline bool Frame::has_pong() const {
  return _internal_has_pong();
}
inline void Frame::set_has_pong() {
  _impl_._oneof_case_[0] = kPong;
}
inline void Frame::clear_pong() {
  if (_internal_has_pong()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.pong_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::Pong* Frame::release_pong() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.pong)
  if (_internal_has_pong()) {
    clear_has_kind();
    ::alyncoin::net::Pong* temp = _impl_.kind_.pong_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::Pong& Frame::_internal_pong() const {
  return _internal_has_pong()
      ? *_impl_.kind_.pong_
      : reinterpret_cast< ::alyncoin::net::Pong&>(::alyncoin::net::_Pong_default_instance_);
}
inline const ::alyncoin::net::Pong& Frame::pong() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.pong)
  return _internal_pong();
}
inline ::alyncoin::net::Pong* Frame::unsafe_arena_release_pong() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.pong)
  if (_internal_has_pong()) {
    clear_has_kind();
    ::alyncoin::net::Pong* temp = _impl_.kind_.pong_;
    _impl_.kind_.pong_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_pong(::alyncoin::net::Pong* pong) {
  clear_kind();
  if (pong) {
    set_has_pong();
    _impl_.kind_.pong_ = pong;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.pong)
}
inline ::alyncoin::net::Pong* Frame::_internal_mutable_pong() {
  if (!_internal_has_pong()) {
    clear_kind();
    set_has_pong();
    _impl_.kind_.pong_ = CreateMaybeMessage< ::alyncoin::net::Pong >(GetArenaForAllocation());
  }
  return _impl_.kind_.pong_;
}
inline ::alyncoin::net::Pong* Frame::mutable_pong() {
  ::alyncoin::net::Pong* _msg = _internal_mutable_pong();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.pong)
  return _msg;
}

// .alyncoin.net.HeightRequest height_req = 4;
inline bool Frame::_internal_has_height_req() const {
  return kind_case() == kHeightReq;
}
inline bool Frame::has_height_req() const {
  return _internal_has_height_req();
}
inline void Frame::set_has_height_req() {
  _impl_._oneof_case_[0] = kHeightReq;
}
inline void Frame::clear_height_req() {
  if (_internal_has_height_req()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.height_req_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightRequest* Frame::release_height_req() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_req)
  if (_internal_has_height_req()) {
    clear_has_kind();
    ::alyncoin::net::HeightRequest* temp = _impl_.kind_.height_req_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightRequest& Frame::_internal_height_req() const {
  return _internal_has_height_req()
      ? *_impl_.kind_.height_req_
      : reinterpret_cast< ::alyncoin::net::HeightRequest&>(::alyncoin::net::_HeightRequest_default_instance_);
}
inline const ::alyncoin::net::HeightRequest& Frame::height_req() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_req)
  return _internal_height_req();
}
inline ::alyncoin::net::HeightRequest* Frame::unsafe_arena_release_height_req() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_req)
  if (_internal_has_height_req()) {
    clear_has_kind();
    ::alyncoin::net::HeightRequest* temp = _impl_.kind_.height_req_;
    _impl_.kind_.height_req_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_req(::alyncoin::net::HeightRequest* height_req) {
  clear_kind();
  if (height_req) {
    set_has_height_req();
    _impl_.kind_.height_req_ = height_req;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_req)
}
inline ::alyncoin::net::HeightRequest* Frame::_internal_mutable_height_req() {
  if (!_internal_has_height_req()) {
    clear_kind();
    set_has_height_req();
    _impl_.kind_.height_req_ = CreateMaybeMessage< ::alyncoin::net::HeightRequest >(GetArenaForAllocation());
  }
  return _impl_.kind_.height_req_;
}
inline ::alyncoin::net::HeightRequest* Frame::mutable_height_req() {
  ::alyncoin::net::HeightRequest* _msg = _internal_mutable_height_req();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_req)
  return _msg;
}

// .alyncoin.net.HeightResponse height_res = 5;
inline bool Frame::_internal_has_height_res() const {
  return kind_case() == kHeightRes;
}
inline bool Frame::has_height_res() const {
  return _internal_has_height_res();
}
inline void Frame::set_has_height_res() {
  _impl_._oneof_case_[0] = kHeightRes;
}
inline void Frame::clear_height_res() {
  if (_internal_has_height_res()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.height_res_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::HeightResponse* Frame::release_height_res() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.height_res)
  if (_internal_has_height_res()) {
    clear_has_kind();
    ::alyncoin::net::HeightResponse* temp = _impl_.kind_.height_res_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.height_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::HeightResponse& Frame::_internal_height_res() const {
  return _internal_has_height_res()
      ? *_impl_.kind_.height_res_
      : reinterpret_cast< ::alyncoin::net::HeightResponse&>(::alyncoin::net::_HeightResponse_default_instance_);
}
inline const ::alyncoin::net::HeightResponse& Frame::height_res() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.height_res)
  return _internal_height_res();
}
inline ::alyncoin::net::HeightResponse* Frame::unsafe_arena_release_height_res() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.height_res)
  if (_internal_has_height_res()) {
    clear_has_kind();
    ::alyncoin::net::HeightResponse* temp = _impl_.kind_.height_res_;
    _impl_.kind_.height_res_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_height_res(::alyncoin::net::HeightResponse* height_res) {
  clear_kind();
  if (height_res) {
    set_has_height_res();
    _impl_.kind_.height_res_ = height_res;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.height_res)
}
inline ::alyncoin::net::HeightResponse* Frame::_internal_mutable_height_res() {
  if (!_internal_has_height_res()) {
    clear_kind();
    set_has_height_res();
    _impl_.kind_.height_res_ = CreateMaybeMessage< ::alyncoin::net::HeightResponse >(GetArenaForAllocation());
  }
  return _impl_.kind_.height_res_;
}
inline ::alyncoin::net::HeightResponse* Frame::mutable_height_res() {
  ::alyncoin::net::HeightResponse* _msg = _internal_mutable_height_res();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.height_res)
  return _msg;
}

// .alyncoin.net.BlockBroadcast block_broadcast = 6;
inline bool Frame::_internal_has_block_broadcast() const {
  return kind_case() == kBlockBroadcast;
}
inline bool Frame::has_block_broadcast() const {
  return _internal_has_block_broadcast();
}
inline void Frame::set_has_block_broadcast() {
  _impl_._oneof_case_[0] = kBlockBroadcast;
}
inline void Frame::clear_block_broadcast() {
  if (_internal_has_block_broadcast()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.block_broadcast_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockBroadcast* Frame::release_block_broadcast() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_broadcast)
  if (_internal_has_block_broadcast()) {
    clear_has_kind();
    ::alyncoin::net::BlockBroadcast* temp = _impl_.kind_.block_broadcast_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockBroadcast& Frame::_internal_block_broadcast() const {
  return _internal_has_block_broadcast()
      ? *_impl_.kind_.block_broadcast_
      : reinterpret_cast< ::alyncoin::net::BlockBroadcast&>(::alyncoin::net::_BlockBroadcast_default_instance_);
}
inline const ::alyncoin::net::BlockBroadcast& Frame::block_broadcast() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_broadcast)
  return _internal_block_broadcast();
}
inline ::alyncoin::net::BlockBroadcast* Frame::unsafe_arena_release_block_broadcast() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_broadcast)
  if (_internal_has_block_broadcast()) {
    clear_has_kind();
    ::alyncoin::net::BlockBroadcast* temp = _impl_.kind_.block_broadcast_;
    _impl_.kind_.block_broadcast_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* block_broadcast) {
  clear_kind();
  if (block_broadcast) {
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ = block_broadcast;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_broadcast)
}
inline ::alyncoin::net::BlockBroadcast* Frame::_internal_mutable_block_broadcast() {
  if (!_internal_has_block_broadcast()) {
    clear_kind();
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ = CreateMaybeMessage< ::alyncoin::net::BlockBroadcast >(GetArenaForAllocation());
  }
  return _impl_.kind_.block_broadcast_;
}
inline ::alyncoin::net::BlockBroadcast* Frame::mutable_block_broadcast() {
  ::alyncoin::net::BlockBroadcast* _msg = _internal_mutable_block_broadcast();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_broadcast)
  return _msg;
}

// .alyncoin.net.BlockBatch block_batch = 7;
inline bool Frame::_internal_has_block_batch() const {
  return kind_case() == kBlockBatch;
}
inline bool Frame::has_block_batch() const {
  return _internal_has_block_batch();
}
inline void Frame::set_has_block_batch() {
  _impl_._oneof_case_[0] = kBlockBatch;
}
inline void Frame::clear_block_batch() {
  if (_internal_has_block_batch()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.block_batch_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::BlockBatch* Frame::release_block_batch() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.block_batch)
  if (_internal_has_block_batch()) {
    clear_has_kind();
    ::alyncoin::net::BlockBatch* temp = _impl_.kind_.block_batch_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.block_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::BlockBatch& Frame::_internal_block_batch() const {
  return _internal_has_block_batch()
      ? *_impl_.kind_.block_batch_
      : reinterpret_cast< ::alyncoin::net::BlockBatch&>(::alyncoin::net::_BlockBatch_default_instance_);
}
inline const ::alyncoin::net::BlockBatch& Frame::block_batch() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.block_batch)
  return _internal_block_batch();
}
inline ::alyncoin::net::BlockBatch* Frame::unsafe_arena_release_block_batch() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.block_batch)
  if (_internal_has_block_batch()) {
    clear_has_kind();
    ::alyncoin::net::BlockBatch* temp = _impl_.kind_.block_batch_;
    _impl_.kind_.block_batch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_block_batch(::alyncoin::net::BlockBatch* block_batch) {
  clear_kind();
  if (block_batch) {
    set_has_block_batch();
    _impl_.kind_.block_batch_ = block_batch;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.block_batch)
}
inline ::alyncoin::net::BlockBatch* Frame::_internal_mutable_block_batch() {
  if (!_internal_has_block_batch()) {
    clear_kind();
    set_has_block_batch();
    _impl_.kind_.block_batch_ = CreateMaybeMessage< ::alyncoin::net::BlockBatch >(GetArenaForAllocation());
  }
  return _impl_.kind_.block_batch_;
}
inline ::alyncoin::net::BlockBatch* Frame::mutable_block_batch() {
  ::alyncoin::net::BlockBatch* _msg = _internal_mutable_block_batch();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.block_batch)
  return _msg;
}

// .alyncoin.net.SnapshotChunk snapshot_chunk = 8;
inline bool Frame::_internal_has_snapshot_chunk() const {
  return kind_case() == kSnapshotChunk;
}
inline bool Frame::has_snapshot_chunk() const {
  return _internal_has_snapshot_chunk();
}
inline void Frame::set_has_snapshot_chunk() {
  _impl_._oneof_case_[0] = kSnapshotChunk;
}
inline void Frame::clear_snapshot_chunk() {
  if (_internal_has_snapshot_chunk()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.snapshot_chunk_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotChunk* Frame::release_snapshot_chunk() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_chunk)
  if (_internal_has_snapshot_chunk()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotChunk* temp = _impl_.kind_.snapshot_chunk_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotChunk& Frame::_internal_snapshot_chunk() const {
  return _internal_has_snapshot_chunk()
      ? *_impl_.kind_.snapshot_chunk_
      : reinterpret_cast< ::alyncoin::net::SnapshotChunk&>(::alyncoin::net::_SnapshotChunk_default_instance_);
}
inline const ::alyncoin::net::SnapshotChunk& Frame::snapshot_chunk() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_chunk)
  return _internal_snapshot_chunk();
}
inline ::alyncoin::net::SnapshotChunk* Frame::unsafe_arena_release_snapshot_chunk() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_chunk)
  if (_internal_has_snapshot_chunk()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotChunk* temp = _impl_.kind_.snapshot_chunk_;
    _impl_.kind_.snapshot_chunk_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* snapshot_chunk) {
  clear_kind();
  if (snapshot_chunk) {
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ = snapshot_chunk;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_chunk)
}
inline ::alyncoin::net::SnapshotChunk* Frame::_internal_mutable_snapshot_chunk() {
  if (!_internal_has_snapshot_chunk()) {
    clear_kind();
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ = CreateMaybeMessage< ::alyncoin::net::SnapshotChunk >(GetArenaForAllocation());
  }
  return _impl_.kind_.snapshot_chunk_;
}
inline ::alyncoin::net::SnapshotChunk* Frame::mutable_snapshot_chunk() {
  ::alyncoin::net::SnapshotChunk* _msg = _internal_mutable_snapshot_chunk();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_chunk)
  return _msg;
}

// .alyncoin.net.SnapshotEnd snapshot_end = 9;
inline bool Frame::_internal_has_snapshot_end() const {
  return kind_case() == kSnapshotEnd;
}
inline bool Frame::has_snapshot_end() const {
  return _internal_has_snapshot_end();
}
inline void Frame::set_has_snapshot_end() {
  _impl_._oneof_case_[0] = kSnapshotEnd;
}
inline void Frame::clear_snapshot_end() {
  if (_internal_has_snapshot_end()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.snapshot_end_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::SnapshotEnd* Frame::release_snapshot_end() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.snapshot_end)
  if (_internal_has_snapshot_end()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotEnd* temp = _impl_.kind_.snapshot_end_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.snapshot_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::SnapshotEnd& Frame::_internal_snapshot_end() const {
  return _internal_has_snapshot_end()
      ? *_impl_.kind_.snapshot_end_
      : reinterpret_cast< ::alyncoin::net::SnapshotEnd&>(::alyncoin::net::_SnapshotEnd_default_instance_);
}
inline const ::alyncoin::net::SnapshotEnd& Frame::snapshot_end() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.snapshot_end)
  return _internal_snapshot_end();
}
inline ::alyncoin::net::SnapshotEnd* Frame::unsafe_arena_release_snapshot_end() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.snapshot_end)
  if (_internal_has_snapshot_end()) {
    clear_has_kind();
    ::alyncoin::net::SnapshotEnd* temp = _impl_.kind_.snapshot_end_;
    _impl_.kind_.snapshot_end_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* snapshot_end) {
  clear_kind();
  if (snapshot_end) {
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ = snapshot_end;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.snapshot_end)
}
inline ::alyncoin::net::SnapshotEnd* Frame::_internal_mutable_snapshot_end() {
  if (!_internal_has_snapshot_end()) {
    clear_kind();
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ = CreateMaybeMessage< ::alyncoin::net::SnapshotEnd >(GetArenaForAllocation());
  }
  return _impl_.kind_.snapshot_end_;
}
inline ::alyncoin::net::SnapshotEnd* Frame::mutable_snapshot_end() {
  ::alyncoin::net::SnapshotEnd* _msg = _internal_mutable_snapshot_end();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.snapshot_end)
  return _msg;
}

// .alyncoin.net.TailBlocks tail_blocks = 10;
inline bool Frame::_internal_has_tail_blocks() const {
  return kind_case() == kTailBlocks;
}
inline bool Frame::has_tail_blocks() const {
  return _internal_has_tail_blocks();
}
inline void Frame::set_has_tail_blocks() {
  _impl_._oneof_case_[0] = kTailBlocks;
}
inline void Frame::clear_tail_blocks() {
  if (_internal_has_tail_blocks()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.tail_blocks_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::TailBlocks* Frame::release_tail_blocks() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.tail_blocks)
  if (_internal_has_tail_blocks()) {
    clear_has_kind();
    ::alyncoin::net::TailBlocks* temp = _impl_.kind_.tail_blocks_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.tail_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::TailBlocks& Frame::_internal_tail_blocks() const {
  return _internal_has_tail_blocks()
      ? *_impl_.kind_.tail_blocks_
      : reinterpret_cast< ::alyncoin::net::TailBlocks&>(::alyncoin::net::_TailBlocks_default_instance_);
}
inline const ::alyncoin::net::TailBlocks& Frame::tail_blocks() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.tail_blocks)
  return _internal_tail_blocks();
}
inline ::alyncoin::net::TailBlocks* Frame::unsafe_arena_release_tail_blocks() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.tail_blocks)
  if (_internal_has_tail_blocks()) {
    clear_has_kind();
    ::alyncoin::net::TailBlocks* temp = _impl_.kind_.tail_blocks_;
    _impl_.kind_.tail_blocks_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_tail_blocks(::alyncoin::net::TailBlocks* tail_blocks) {
  clear_kind();
  if (tail_blocks) {
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ = tail_blocks;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.tail_blocks)
}
inline ::alyncoin::net::TailBlocks* Frame::_internal_mutable_tail_blocks() {
  if (!_internal_has_tail_blocks()) {
    clear_kind();
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ = CreateMaybeMessage< ::alyncoin::net::TailBlocks >(GetArenaForAllocation());
  }
  return _impl_.kind_.tail_blocks_;
}
inline ::alyncoin::net::TailBlocks* Frame::mutable_tail_blocks() {
  ::alyncoin::net::TailBlocks* _msg = _internal_mutable_tail_blocks();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.tail_blocks)
  return _msg;
}

// .alyncoin.net.EpochProof agg_proof = 11;
inline bool Frame::_internal_has_agg_proof() const {
  return kind_case() == kAggProof;
}
inline bool Frame::has_agg_proof() const {
  return _internal_has_agg_proof();
}
inline void Frame::set_has_agg_proof() {
  _impl_._oneof_case_[0] = kAggProof;
}
inline void Frame::clear_agg_proof() {
  if (_internal_has_agg_proof()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.agg_proof_;
    }
    clear_has_kind();
  }
}
inline ::alyncoin::net::EpochProof* Frame::release_agg_proof() {
  // @@protoc_insertion_point(field_release:alyncoin.net.Frame.agg_proof)
  if (_internal_has_agg_proof()) {
    clear_has_kind();
    ::alyncoin::net::EpochProof* temp = _impl_.kind_.agg_proof_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.kind_.agg_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::alyncoin::net::EpochProof& Frame::_internal_agg_proof() const {
  return _internal_has_agg_proof()
      ? *_impl_.kind_.agg_proof_
      : reinterpret_cast< ::alyncoin::net::EpochProof&>(::alyncoin::net::_EpochProof_default_instance_);
}
inline const ::alyncoin::net::EpochProof& Frame::agg_proof() const {
  // @@protoc_insertion_point(field_get:alyncoin.net.Frame.agg_proof)
  return _internal_agg_proof();
}
inline ::alyncoin::net::EpochProof* Frame::unsafe_arena_release_agg_proof() {
  // @@protoc_insertion_point(field_unsafe_arena_release:alyncoin.net.Frame.agg_proof)
  if (_internal_has_agg_proof()) {
    clear_has_kind();
    ::alyncoin::net::EpochProof* temp = _impl_.kind_.agg_proof_;
    _impl_.kind_.agg_proof_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void Frame::unsafe_arena_set_allocated_agg_proof(::alyncoin::net::EpochProof* agg_proof) {
  clear_kind();
  if (agg_proof) {
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ = agg_proof;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:alyncoin.net.Frame.agg_proof)
}
inline ::alyncoin::net::EpochProof* Frame::_internal_mutable_agg_proof() {
  if (!_internal_has_agg_proof()) {
    clear_kind();
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ = CreateMaybeMessage< ::alyncoin::net::EpochProof >(GetArenaForAllocation());
  }
  return _impl_.kind_.agg_proof_;
}
inline ::alyncoin::net::EpochProof* Frame::mutable_agg_proof() {
  ::alyncoin::net::EpochProof* _msg = _internal_mutable_agg_proof();
  // @@protoc_insertion_point(field_mutable:alyncoin.net.Frame.agg_proof)
  return _msg;
}

inline bool Frame::has_kind() const {
  return kind_case() != KIND_NOT_SET;
}
inline void Frame::clear_has_kind() {
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}
inline Frame::KindCase Frame::kind_case() const {
  return Frame::KindCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace net
}  // namespace alyncoin

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_net_5fframe_2eproto
