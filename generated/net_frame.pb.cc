// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net_frame.proto

#include "net_frame.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace alyncoin {
namespace net {
PROTOBUF_CONSTEXPR Handshake::Handshake(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.capabilities_)*/{}
  , /*decltype(_impl_.version_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.network_id_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.genesis_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.pub_key_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.height_)*/uint64_t{0u}
  , /*decltype(_impl_.listen_port_)*/0u
  , /*decltype(_impl_.frame_rev_)*/0u
  , /*decltype(_impl_.total_work_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HandshakeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HandshakeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HandshakeDefaultTypeInternal() {}
  union {
    Handshake _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HandshakeDefaultTypeInternal _Handshake_default_instance_;
PROTOBUF_CONSTEXPR Ping::Ping(
    ::_pbi::ConstantInitialized) {}
struct PingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PingDefaultTypeInternal() {}
  union {
    Ping _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PingDefaultTypeInternal _Ping_default_instance_;
PROTOBUF_CONSTEXPR Pong::Pong(
    ::_pbi::ConstantInitialized) {}
struct PongDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PongDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PongDefaultTypeInternal() {}
  union {
    Pong _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PongDefaultTypeInternal _Pong_default_instance_;
PROTOBUF_CONSTEXPR HeightRequest::HeightRequest(
    ::_pbi::ConstantInitialized) {}
struct HeightRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeightRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeightRequestDefaultTypeInternal() {}
  union {
    HeightRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeightRequestDefaultTypeInternal _HeightRequest_default_instance_;
PROTOBUF_CONSTEXPR HeightResponse::HeightResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.height_)*/uint64_t{0u}
  , /*decltype(_impl_.total_work_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeightResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeightResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeightResponseDefaultTypeInternal() {}
  union {
    HeightResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeightResponseDefaultTypeInternal _HeightResponse_default_instance_;
PROTOBUF_CONSTEXPR HeightProbe::HeightProbe(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tip_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.total_work_)*/uint64_t{0u}
  , /*decltype(_impl_.height_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeightProbeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeightProbeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeightProbeDefaultTypeInternal() {}
  union {
    HeightProbe _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeightProbeDefaultTypeInternal _HeightProbe_default_instance_;
PROTOBUF_CONSTEXPR BlockBroadcast::BlockBroadcast(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockBroadcastDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockBroadcastDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockBroadcastDefaultTypeInternal() {}
  union {
    BlockBroadcast _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockBroadcastDefaultTypeInternal _BlockBroadcast_default_instance_;
PROTOBUF_CONSTEXPR BlockBatch::BlockBatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.chain_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockBatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockBatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockBatchDefaultTypeInternal() {}
  union {
    BlockBatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockBatchDefaultTypeInternal _BlockBatch_default_instance_;
PROTOBUF_CONSTEXPR BlockRequest::BlockRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.index_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockRequestDefaultTypeInternal() {}
  union {
    BlockRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockRequestDefaultTypeInternal _BlockRequest_default_instance_;
PROTOBUF_CONSTEXPR BlockResponse::BlockResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.block_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BlockResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BlockResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BlockResponseDefaultTypeInternal() {}
  union {
    BlockResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
PROTOBUF_CONSTEXPR SnapshotMeta::SnapshotMeta(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.root_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.height_)*/uint64_t{0u}
  , /*decltype(_impl_.total_bytes_)*/uint64_t{0u}
  , /*decltype(_impl_.chunk_size_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SnapshotMetaDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotMetaDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotMetaDefaultTypeInternal() {}
  union {
    SnapshotMeta _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotMetaDefaultTypeInternal _SnapshotMeta_default_instance_;
PROTOBUF_CONSTEXPR SnapshotChunk::SnapshotChunk(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SnapshotChunkDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotChunkDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotChunkDefaultTypeInternal() {}
  union {
    SnapshotChunk _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotChunkDefaultTypeInternal _SnapshotChunk_default_instance_;
PROTOBUF_CONSTEXPR SnapshotAck::SnapshotAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.seq_)*/0u
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SnapshotAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotAckDefaultTypeInternal() {}
  union {
    SnapshotAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotAckDefaultTypeInternal _SnapshotAck_default_instance_;
PROTOBUF_CONSTEXPR SnapshotEnd::SnapshotEnd(
    ::_pbi::ConstantInitialized) {}
struct SnapshotEndDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotEndDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotEndDefaultTypeInternal() {}
  union {
    SnapshotEnd _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotEndDefaultTypeInternal _SnapshotEnd_default_instance_;
PROTOBUF_CONSTEXPR TailBlocks::TailBlocks(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.blocks_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TailBlocksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TailBlocksDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TailBlocksDefaultTypeInternal() {}
  union {
    TailBlocks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TailBlocksDefaultTypeInternal _TailBlocks_default_instance_;
PROTOBUF_CONSTEXPR EpochProof::EpochProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct EpochProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR EpochProofDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~EpochProofDefaultTypeInternal() {}
  union {
    EpochProof _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 EpochProofDefaultTypeInternal _EpochProof_default_instance_;
PROTOBUF_CONSTEXPR Inventory::Inventory(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hashes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct InventoryDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InventoryDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~InventoryDefaultTypeInternal() {}
  union {
    Inventory _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InventoryDefaultTypeInternal _Inventory_default_instance_;
PROTOBUF_CONSTEXPR TipHashRequest::TipHashRequest(
    ::_pbi::ConstantInitialized) {}
struct TipHashRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TipHashRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TipHashRequestDefaultTypeInternal() {}
  union {
    TipHashRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TipHashRequestDefaultTypeInternal _TipHashRequest_default_instance_;
PROTOBUF_CONSTEXPR TipHashResponse::TipHashResponse(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TipHashResponseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TipHashResponseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TipHashResponseDefaultTypeInternal() {}
  union {
    TipHashResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TipHashResponseDefaultTypeInternal _TipHashResponse_default_instance_;
PROTOBUF_CONSTEXPR PeerListRequest::PeerListRequest(
    ::_pbi::ConstantInitialized) {}
struct PeerListRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeerListRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeerListRequestDefaultTypeInternal() {}
  union {
    PeerListRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeerListRequestDefaultTypeInternal _PeerListRequest_default_instance_;
PROTOBUF_CONSTEXPR PeerList::PeerList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PeerListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PeerListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PeerListDefaultTypeInternal() {}
  union {
    PeerList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PeerListDefaultTypeInternal _PeerList_default_instance_;
PROTOBUF_CONSTEXPR RollupBlockMsg::RollupBlockMsg(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RollupBlockMsgDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RollupBlockMsgDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RollupBlockMsgDefaultTypeInternal() {}
  union {
    RollupBlockMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RollupBlockMsgDefaultTypeInternal _RollupBlockMsg_default_instance_;
PROTOBUF_CONSTEXPR SnapshotRequest::SnapshotRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.until_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SnapshotRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SnapshotRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SnapshotRequestDefaultTypeInternal() {}
  union {
    SnapshotRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SnapshotRequestDefaultTypeInternal _SnapshotRequest_default_instance_;
PROTOBUF_CONSTEXPR TailBlocksRequest::TailBlocksRequest(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_height_)*/uint64_t{0u}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TailBlocksRequestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TailBlocksRequestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TailBlocksRequestDefaultTypeInternal() {}
  union {
    TailBlocksRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TailBlocksRequestDefaultTypeInternal _TailBlocksRequest_default_instance_;
PROTOBUF_CONSTEXPR GetData::GetData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.hashes_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetDataDefaultTypeInternal() {}
  union {
    GetData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetDataDefaultTypeInternal _GetData_default_instance_;
PROTOBUF_CONSTEXPR GetHeaders::GetHeaders(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.from_hash_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct GetHeadersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR GetHeadersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~GetHeadersDefaultTypeInternal() {}
  union {
    GetHeaders _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 GetHeadersDefaultTypeInternal _GetHeaders_default_instance_;
PROTOBUF_CONSTEXPR Headers::Headers(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.headers_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct HeadersDefaultTypeInternal {
  PROTOBUF_CONSTEXPR HeadersDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~HeadersDefaultTypeInternal() {}
  union {
    Headers _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 HeadersDefaultTypeInternal _Headers_default_instance_;
PROTOBUF_CONSTEXPR StateProof::StateProof(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.proof_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct StateProofDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StateProofDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StateProofDefaultTypeInternal() {}
  union {
    StateProof _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StateProofDefaultTypeInternal _StateProof_default_instance_;
PROTOBUF_CONSTEXPR TransactionBroadcast::TransactionBroadcast(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.tx_)*/nullptr
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct TransactionBroadcastDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TransactionBroadcastDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TransactionBroadcastDefaultTypeInternal() {}
  union {
    TransactionBroadcast _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TransactionBroadcastDefaultTypeInternal _TransactionBroadcast_default_instance_;
PROTOBUF_CONSTEXPR Whisper::Whisper(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct WhisperDefaultTypeInternal {
  PROTOBUF_CONSTEXPR WhisperDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~WhisperDefaultTypeInternal() {}
  union {
    Whisper _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 WhisperDefaultTypeInternal _Whisper_default_instance_;
PROTOBUF_CONSTEXPR Frame::Frame(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.kind_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct FrameDefaultTypeInternal {
  PROTOBUF_CONSTEXPR FrameDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~FrameDefaultTypeInternal() {}
  union {
    Frame _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 FrameDefaultTypeInternal _Frame_default_instance_;
}  // namespace net
}  // namespace alyncoin
static ::_pb::Metadata file_level_metadata_net_5fframe_2eproto[31];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_net_5fframe_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_net_5fframe_2eproto = nullptr;

const uint32_t TableStruct_net_5fframe_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.version_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.network_id_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.listen_port_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.genesis_hash_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.capabilities_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.pub_key_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.frame_rev_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Handshake, _impl_.total_work_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Ping, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Pong, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightResponse, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightResponse, _impl_.total_work_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightProbe, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightProbe, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightProbe, _impl_.tip_hash_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::HeightProbe, _impl_.total_work_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockBroadcast, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockBroadcast, _impl_.block_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockBatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockBatch, _impl_.chain_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockRequest, _impl_.index_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::BlockResponse, _impl_.block_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotMeta, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotMeta, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotMeta, _impl_.root_hash_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotMeta, _impl_.total_bytes_),
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotMeta, _impl_.chunk_size_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotChunk, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotChunk, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotAck, _impl_.seq_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotEnd, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TailBlocks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TailBlocks, _impl_.blocks_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::EpochProof, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::EpochProof, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Inventory, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Inventory, _impl_.hashes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TipHashRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TipHashResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TipHashResponse, _impl_.hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::PeerListRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::PeerList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::PeerList, _impl_.peers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::RollupBlockMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::RollupBlockMsg, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::SnapshotRequest, _impl_.until_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TailBlocksRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TailBlocksRequest, _impl_.from_height_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::GetData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::GetData, _impl_.hashes_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::GetHeaders, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::GetHeaders, _impl_.from_hash_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Headers, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Headers, _impl_.headers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::StateProof, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::StateProof, _impl_.proof_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TransactionBroadcast, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::TransactionBroadcast, _impl_.tx_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Whisper, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Whisper, _impl_.data_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Frame, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Frame, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::alyncoin::net::Frame, _impl_.kind_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, -1, sizeof(::alyncoin::net::Handshake)},
  { 15, -1, -1, sizeof(::alyncoin::net::Ping)},
  { 21, -1, -1, sizeof(::alyncoin::net::Pong)},
  { 27, -1, -1, sizeof(::alyncoin::net::HeightRequest)},
  { 33, -1, -1, sizeof(::alyncoin::net::HeightResponse)},
  { 41, -1, -1, sizeof(::alyncoin::net::HeightProbe)},
  { 50, -1, -1, sizeof(::alyncoin::net::BlockBroadcast)},
  { 57, -1, -1, sizeof(::alyncoin::net::BlockBatch)},
  { 64, -1, -1, sizeof(::alyncoin::net::BlockRequest)},
  { 71, -1, -1, sizeof(::alyncoin::net::BlockResponse)},
  { 78, -1, -1, sizeof(::alyncoin::net::SnapshotMeta)},
  { 88, -1, -1, sizeof(::alyncoin::net::SnapshotChunk)},
  { 95, -1, -1, sizeof(::alyncoin::net::SnapshotAck)},
  { 102, -1, -1, sizeof(::alyncoin::net::SnapshotEnd)},
  { 108, -1, -1, sizeof(::alyncoin::net::TailBlocks)},
  { 115, -1, -1, sizeof(::alyncoin::net::EpochProof)},
  { 122, -1, -1, sizeof(::alyncoin::net::Inventory)},
  { 129, -1, -1, sizeof(::alyncoin::net::TipHashRequest)},
  { 135, -1, -1, sizeof(::alyncoin::net::TipHashResponse)},
  { 142, -1, -1, sizeof(::alyncoin::net::PeerListRequest)},
  { 148, -1, -1, sizeof(::alyncoin::net::PeerList)},
  { 155, -1, -1, sizeof(::alyncoin::net::RollupBlockMsg)},
  { 162, -1, -1, sizeof(::alyncoin::net::SnapshotRequest)},
  { 169, -1, -1, sizeof(::alyncoin::net::TailBlocksRequest)},
  { 176, -1, -1, sizeof(::alyncoin::net::GetData)},
  { 183, -1, -1, sizeof(::alyncoin::net::GetHeaders)},
  { 190, -1, -1, sizeof(::alyncoin::net::Headers)},
  { 197, -1, -1, sizeof(::alyncoin::net::StateProof)},
  { 204, -1, -1, sizeof(::alyncoin::net::TransactionBroadcast)},
  { 211, -1, -1, sizeof(::alyncoin::net::Whisper)},
  { 218, -1, -1, sizeof(::alyncoin::net::Frame)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::alyncoin::net::_Handshake_default_instance_._instance,
  &::alyncoin::net::_Ping_default_instance_._instance,
  &::alyncoin::net::_Pong_default_instance_._instance,
  &::alyncoin::net::_HeightRequest_default_instance_._instance,
  &::alyncoin::net::_HeightResponse_default_instance_._instance,
  &::alyncoin::net::_HeightProbe_default_instance_._instance,
  &::alyncoin::net::_BlockBroadcast_default_instance_._instance,
  &::alyncoin::net::_BlockBatch_default_instance_._instance,
  &::alyncoin::net::_BlockRequest_default_instance_._instance,
  &::alyncoin::net::_BlockResponse_default_instance_._instance,
  &::alyncoin::net::_SnapshotMeta_default_instance_._instance,
  &::alyncoin::net::_SnapshotChunk_default_instance_._instance,
  &::alyncoin::net::_SnapshotAck_default_instance_._instance,
  &::alyncoin::net::_SnapshotEnd_default_instance_._instance,
  &::alyncoin::net::_TailBlocks_default_instance_._instance,
  &::alyncoin::net::_EpochProof_default_instance_._instance,
  &::alyncoin::net::_Inventory_default_instance_._instance,
  &::alyncoin::net::_TipHashRequest_default_instance_._instance,
  &::alyncoin::net::_TipHashResponse_default_instance_._instance,
  &::alyncoin::net::_PeerListRequest_default_instance_._instance,
  &::alyncoin::net::_PeerList_default_instance_._instance,
  &::alyncoin::net::_RollupBlockMsg_default_instance_._instance,
  &::alyncoin::net::_SnapshotRequest_default_instance_._instance,
  &::alyncoin::net::_TailBlocksRequest_default_instance_._instance,
  &::alyncoin::net::_GetData_default_instance_._instance,
  &::alyncoin::net::_GetHeaders_default_instance_._instance,
  &::alyncoin::net::_Headers_default_instance_._instance,
  &::alyncoin::net::_StateProof_default_instance_._instance,
  &::alyncoin::net::_TransactionBroadcast_default_instance_._instance,
  &::alyncoin::net::_Whisper_default_instance_._instance,
  &::alyncoin::net::_Frame_default_instance_._instance,
};

const char descriptor_table_protodef_net_5fframe_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\017net_frame.proto\022\014alyncoin.net\032\022block_p"
  "rotos.proto\032\027blockchain_protos.proto\032\021sy"
  "nc_protos.proto\032\030transaction_protos.prot"
  "o\"\271\001\n\tHandshake\022\017\n\007version\030\001 \001(\t\022\022\n\nnetw"
  "ork_id\030\002 \001(\t\022\016\n\006height\030\003 \001(\004\022\023\n\013listen_p"
  "ort\030\004 \001(\r\022\024\n\014genesis_hash\030\005 \001(\014\022\024\n\014capab"
  "ilities\030\006 \003(\t\022\017\n\007pub_key\030\007 \001(\014\022\021\n\tframe_"
  "rev\030\010 \001(\r\022\022\n\ntotal_work\030\t \001(\004\"\006\n\004Ping\"\006\n"
  "\004Pong\"\017\n\rHeightRequest\"4\n\016HeightResponse"
  "\022\016\n\006height\030\001 \001(\004\022\022\n\ntotal_work\030\002 \001(\004\"C\n\013"
  "HeightProbe\022\016\n\006height\030\001 \001(\r\022\020\n\010tip_hash\030"
  "\002 \001(\014\022\022\n\ntotal_work\030\003 \001(\004\"5\n\016BlockBroadc"
  "ast\022#\n\005block\030\001 \001(\0132\024.alyncoin.BlockProto"
  "\"6\n\nBlockBatch\022(\n\005chain\030\001 \001(\0132\031.alyncoin"
  ".BlockchainProto\"\035\n\014BlockRequest\022\r\n\005inde"
  "x\030\001 \001(\004\"4\n\rBlockResponse\022#\n\005block\030\001 \001(\0132"
  "\024.alyncoin.BlockProto\"Z\n\014SnapshotMeta\022\016\n"
  "\006height\030\001 \001(\004\022\021\n\troot_hash\030\002 \001(\t\022\023\n\013tota"
  "l_bytes\030\003 \001(\004\022\022\n\nchunk_size\030\004 \001(\r\"\035\n\rSna"
  "pshotChunk\022\014\n\004data\030\001 \001(\014\"\032\n\013SnapshotAck\022"
  "\013\n\003seq\030\001 \001(\r\"\r\n\013SnapshotEnd\"2\n\nTailBlock"
  "s\022$\n\006blocks\030\001 \003(\0132\024.alyncoin.BlockProto\""
  "\032\n\nEpochProof\022\014\n\004data\030\001 \001(\014\"\033\n\tInventory"
  "\022\016\n\006hashes\030\001 \003(\t\"\020\n\016TipHashRequest\"\037\n\017Ti"
  "pHashResponse\022\014\n\004hash\030\001 \001(\t\"\021\n\017PeerListR"
  "equest\"\031\n\010PeerList\022\r\n\005peers\030\001 \003(\t\"\036\n\016Rol"
  "lupBlockMsg\022\014\n\004data\030\001 \001(\014\"%\n\017SnapshotReq"
  "uest\022\022\n\nuntil_hash\030\001 \001(\t\"(\n\021TailBlocksRe"
  "quest\022\023\n\013from_height\030\001 \001(\004\"\031\n\007GetData\022\016\n"
  "\006hashes\030\001 \003(\t\"\037\n\nGetHeaders\022\021\n\tfrom_hash"
  "\030\001 \001(\t\"0\n\007Headers\022%\n\007headers\030\001 \003(\0132\024.aly"
  "ncoin.BlockProto\"6\n\nStateProof\022(\n\005proof\030"
  "\001 \001(\0132\031.alyncoin.StateProofProto\">\n\024Tran"
  "sactionBroadcast\022&\n\002tx\030\001 \001(\0132\032.alyncoin."
  "TransactionProto\"\027\n\007Whisper\022\014\n\004data\030\001 \001("
  "\014\"\242\014\n\005Frame\022,\n\thandshake\030\001 \001(\0132\027.alyncoi"
  "n.net.HandshakeH\000\022\"\n\004ping\030\002 \001(\0132\022.alynco"
  "in.net.PingH\000\022\"\n\004pong\030\003 \001(\0132\022.alyncoin.n"
  "et.PongH\000\0221\n\nheight_req\030\004 \001(\0132\033.alyncoin"
  ".net.HeightRequestH\000\0222\n\nheight_res\030\005 \001(\013"
  "2\034.alyncoin.net.HeightResponseH\000\0221\n\014heig"
  "ht_probe\030\037 \001(\0132\031.alyncoin.net.HeightProb"
  "eH\000\0227\n\017block_broadcast\030\006 \001(\0132\034.alyncoin."
  "net.BlockBroadcastH\000\022/\n\013block_batch\030\007 \001("
  "\0132\030.alyncoin.net.BlockBatchH\000\0223\n\rblock_r"
  "equest\030\035 \001(\0132\032.alyncoin.net.BlockRequest"
  "H\000\0225\n\016block_response\030\036 \001(\0132\033.alyncoin.ne"
  "t.BlockResponseH\000\0223\n\rsnapshot_meta\030\010 \001(\013"
  "2\032.alyncoin.net.SnapshotMetaH\000\0225\n\016snapsh"
  "ot_chunk\030\t \001(\0132\033.alyncoin.net.SnapshotCh"
  "unkH\000\0221\n\014snapshot_ack\030\n \001(\0132\031.alyncoin.n"
  "et.SnapshotAckH\000\0221\n\014snapshot_end\030\013 \001(\0132\031"
  ".alyncoin.net.SnapshotEndH\000\022/\n\013tail_bloc"
  "ks\030\014 \001(\0132\030.alyncoin.net.TailBlocksH\000\022-\n\t"
  "agg_proof\030\r \001(\0132\030.alyncoin.net.EpochProo"
  "fH\000\022&\n\003inv\030\016 \001(\0132\027.alyncoin.net.Inventor"
  "yH\000\0224\n\014tip_hash_req\030\017 \001(\0132\034.alyncoin.net"
  ".TipHashRequestH\000\0225\n\014tip_hash_res\030\020 \001(\0132"
  "\035.alyncoin.net.TipHashResponseH\000\0226\n\rpeer"
  "_list_req\030\021 \001(\0132\035.alyncoin.net.PeerListR"
  "equestH\000\022+\n\tpeer_list\030\022 \001(\0132\026.alyncoin.n"
  "et.PeerListH\000\0224\n\014rollup_block\030\023 \001(\0132\034.al"
  "yncoin.net.RollupBlockMsgH\000\0225\n\014snapshot_"
  "req\030\024 \001(\0132\035.alyncoin.net.SnapshotRequest"
  "H\000\0223\n\010tail_req\030\025 \001(\0132\037.alyncoin.net.Tail"
  "BlocksRequestH\000\022/\n\013state_proof\030\026 \001(\0132\030.a"
  "lyncoin.net.StateProofH\000\022)\n\010get_data\030\027 \001"
  "(\0132\025.alyncoin.net.GetDataH\000\022@\n\027blockchai"
  "n_sync_request\030\030 \001(\0132\035.alyncoin.Blockcha"
  "inSyncProtoH\000\022:\n\014tx_broadcast\030\031 \001(\0132\".al"
  "yncoin.net.TransactionBroadcastH\000\022(\n\007whi"
  "sper\030\032 \001(\0132\025.alyncoin.net.WhisperH\000\022/\n\013g"
  "et_headers\030\033 \001(\0132\030.alyncoin.net.GetHeade"
  "rsH\000\022(\n\007headers\030\034 \001(\0132\025.alyncoin.net.Hea"
  "dersH\000B\006\n\004kindb\006proto3"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_net_5fframe_2eproto_deps[4] = {
  &::descriptor_table_block_5fprotos_2eproto,
  &::descriptor_table_blockchain_5fprotos_2eproto,
  &::descriptor_table_sync_5fprotos_2eproto,
  &::descriptor_table_transaction_5fprotos_2eproto,
};
static ::_pbi::once_flag descriptor_table_net_5fframe_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_net_5fframe_2eproto = {
    false, false, 2982, descriptor_table_protodef_net_5fframe_2eproto,
    "net_frame.proto",
    &descriptor_table_net_5fframe_2eproto_once, descriptor_table_net_5fframe_2eproto_deps, 4, 31,
    schemas, file_default_instances, TableStruct_net_5fframe_2eproto::offsets,
    file_level_metadata_net_5fframe_2eproto, file_level_enum_descriptors_net_5fframe_2eproto,
    file_level_service_descriptors_net_5fframe_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_net_5fframe_2eproto_getter() {
  return &descriptor_table_net_5fframe_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_net_5fframe_2eproto(&descriptor_table_net_5fframe_2eproto);
namespace alyncoin {
namespace net {

// ===================================================================

class Handshake::_Internal {
 public:
};

Handshake::Handshake(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Handshake)
}
Handshake::Handshake(const Handshake& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Handshake* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.capabilities_){from._impl_.capabilities_}
    , decltype(_impl_.version_){}
    , decltype(_impl_.network_id_){}
    , decltype(_impl_.genesis_hash_){}
    , decltype(_impl_.pub_key_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.listen_port_){}
    , decltype(_impl_.frame_rev_){}
    , decltype(_impl_.total_work_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_version().empty()) {
    _this->_impl_.version_.Set(from._internal_version(), 
      _this->GetArenaForAllocation());
  }
  _impl_.network_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.network_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_network_id().empty()) {
    _this->_impl_.network_id_.Set(from._internal_network_id(), 
      _this->GetArenaForAllocation());
  }
  _impl_.genesis_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.genesis_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_genesis_hash().empty()) {
    _this->_impl_.genesis_hash_.Set(from._internal_genesis_hash(), 
      _this->GetArenaForAllocation());
  }
  _impl_.pub_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pub_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_pub_key().empty()) {
    _this->_impl_.pub_key_.Set(from._internal_pub_key(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.height_, &from._impl_.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_work_) -
    reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.total_work_));
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Handshake)
}

inline void Handshake::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.capabilities_){arena}
    , decltype(_impl_.version_){}
    , decltype(_impl_.network_id_){}
    , decltype(_impl_.genesis_hash_){}
    , decltype(_impl_.pub_key_){}
    , decltype(_impl_.height_){uint64_t{0u}}
    , decltype(_impl_.listen_port_){0u}
    , decltype(_impl_.frame_rev_){0u}
    , decltype(_impl_.total_work_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.version_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.version_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.network_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.network_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.genesis_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.genesis_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.pub_key_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.pub_key_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Handshake::~Handshake() {
  // @@protoc_insertion_point(destructor:alyncoin.net.Handshake)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Handshake::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.capabilities_.~RepeatedPtrField();
  _impl_.version_.Destroy();
  _impl_.network_id_.Destroy();
  _impl_.genesis_hash_.Destroy();
  _impl_.pub_key_.Destroy();
}

void Handshake::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Handshake::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.Handshake)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.capabilities_.Clear();
  _impl_.version_.ClearToEmpty();
  _impl_.network_id_.ClearToEmpty();
  _impl_.genesis_hash_.ClearToEmpty();
  _impl_.pub_key_.ClearToEmpty();
  ::memset(&_impl_.height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.total_work_) -
      reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.total_work_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Handshake::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_version();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.Handshake.version"));
        } else
          goto handle_unusual;
        continue;
      // string network_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_network_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.Handshake.network_id"));
        } else
          goto handle_unusual;
        continue;
      // uint64 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 listen_port = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.listen_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes genesis_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_genesis_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string capabilities = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_capabilities();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.Handshake.capabilities"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bytes pub_key = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_pub_key();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 frame_rev = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _impl_.frame_rev_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 total_work = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _impl_.total_work_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Handshake::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.Handshake)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string version = 1;
  if (!this->_internal_version().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.Handshake.version");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_version(), target);
  }

  // string network_id = 2;
  if (!this->_internal_network_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_network_id().data(), static_cast<int>(this->_internal_network_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.Handshake.network_id");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_network_id(), target);
  }

  // uint64 height = 3;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_height(), target);
  }

  // uint32 listen_port = 4;
  if (this->_internal_listen_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_listen_port(), target);
  }

  // bytes genesis_hash = 5;
  if (!this->_internal_genesis_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_genesis_hash(), target);
  }

  // repeated string capabilities = 6;
  for (int i = 0, n = this->_internal_capabilities_size(); i < n; i++) {
    const auto& s = this->_internal_capabilities(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.Handshake.capabilities");
    target = stream->WriteString(6, s, target);
  }

  // bytes pub_key = 7;
  if (!this->_internal_pub_key().empty()) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_pub_key(), target);
  }

  // uint32 frame_rev = 8;
  if (this->_internal_frame_rev() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_frame_rev(), target);
  }

  // uint64 total_work = 9;
  if (this->_internal_total_work() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(9, this->_internal_total_work(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.Handshake)
  return target;
}

size_t Handshake::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.Handshake)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string capabilities = 6;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.capabilities_.size());
  for (int i = 0, n = _impl_.capabilities_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.capabilities_.Get(i));
  }

  // string version = 1;
  if (!this->_internal_version().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_version());
  }

  // string network_id = 2;
  if (!this->_internal_network_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_network_id());
  }

  // bytes genesis_hash = 5;
  if (!this->_internal_genesis_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_genesis_hash());
  }

  // bytes pub_key = 7;
  if (!this->_internal_pub_key().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_pub_key());
  }

  // uint64 height = 3;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_height());
  }

  // uint32 listen_port = 4;
  if (this->_internal_listen_port() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_listen_port());
  }

  // uint32 frame_rev = 8;
  if (this->_internal_frame_rev() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_rev());
  }

  // uint64 total_work = 9;
  if (this->_internal_total_work() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_work());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Handshake::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Handshake::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Handshake::GetClassData() const { return &_class_data_; }


void Handshake::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Handshake*>(&to_msg);
  auto& from = static_cast<const Handshake&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.Handshake)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.capabilities_.MergeFrom(from._impl_.capabilities_);
  if (!from._internal_version().empty()) {
    _this->_internal_set_version(from._internal_version());
  }
  if (!from._internal_network_id().empty()) {
    _this->_internal_set_network_id(from._internal_network_id());
  }
  if (!from._internal_genesis_hash().empty()) {
    _this->_internal_set_genesis_hash(from._internal_genesis_hash());
  }
  if (!from._internal_pub_key().empty()) {
    _this->_internal_set_pub_key(from._internal_pub_key());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_listen_port() != 0) {
    _this->_internal_set_listen_port(from._internal_listen_port());
  }
  if (from._internal_frame_rev() != 0) {
    _this->_internal_set_frame_rev(from._internal_frame_rev());
  }
  if (from._internal_total_work() != 0) {
    _this->_internal_set_total_work(from._internal_total_work());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Handshake::CopyFrom(const Handshake& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.Handshake)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Handshake::IsInitialized() const {
  return true;
}

void Handshake::InternalSwap(Handshake* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.capabilities_.InternalSwap(&other->_impl_.capabilities_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.version_, lhs_arena,
      &other->_impl_.version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.network_id_, lhs_arena,
      &other->_impl_.network_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.genesis_hash_, lhs_arena,
      &other->_impl_.genesis_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.pub_key_, lhs_arena,
      &other->_impl_.pub_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Handshake, _impl_.total_work_)
      + sizeof(Handshake::_impl_.total_work_)
      - PROTOBUF_FIELD_OFFSET(Handshake, _impl_.height_)>(
          reinterpret_cast<char*>(&_impl_.height_),
          reinterpret_cast<char*>(&other->_impl_.height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Handshake::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[0]);
}

// ===================================================================

class Ping::_Internal {
 public:
};

Ping::Ping(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Ping)
}
Ping::Ping(const Ping& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Ping* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Ping)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ping::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ping::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Ping::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[1]);
}

// ===================================================================

class Pong::_Internal {
 public:
};

Pong::Pong(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Pong)
}
Pong::Pong(const Pong& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  Pong* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Pong)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Pong::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Pong::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata Pong::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[2]);
}

// ===================================================================

class HeightRequest::_Internal {
 public:
};

HeightRequest::HeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.HeightRequest)
}
HeightRequest::HeightRequest(const HeightRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  HeightRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.HeightRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeightRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeightRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata HeightRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[3]);
}

// ===================================================================

class HeightResponse::_Internal {
 public:
};

HeightResponse::HeightResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.HeightResponse)
}
HeightResponse::HeightResponse(const HeightResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeightResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.height_){}
    , decltype(_impl_.total_work_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.height_, &from._impl_.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_work_) -
    reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.total_work_));
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.HeightResponse)
}

inline void HeightResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.height_){uint64_t{0u}}
    , decltype(_impl_.total_work_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

HeightResponse::~HeightResponse() {
  // @@protoc_insertion_point(destructor:alyncoin.net.HeightResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeightResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void HeightResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeightResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.HeightResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.total_work_) -
      reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.total_work_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeightResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 total_work = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.total_work_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeightResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.HeightResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_height(), target);
  }

  // uint64 total_work = 2;
  if (this->_internal_total_work() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(2, this->_internal_total_work(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.HeightResponse)
  return target;
}

size_t HeightResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.HeightResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_height());
  }

  // uint64 total_work = 2;
  if (this->_internal_total_work() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_work());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeightResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeightResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeightResponse::GetClassData() const { return &_class_data_; }


void HeightResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeightResponse*>(&to_msg);
  auto& from = static_cast<const HeightResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.HeightResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_total_work() != 0) {
    _this->_internal_set_total_work(from._internal_total_work());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeightResponse::CopyFrom(const HeightResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.HeightResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeightResponse::IsInitialized() const {
  return true;
}

void HeightResponse::InternalSwap(HeightResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeightResponse, _impl_.total_work_)
      + sizeof(HeightResponse::_impl_.total_work_)
      - PROTOBUF_FIELD_OFFSET(HeightResponse, _impl_.height_)>(
          reinterpret_cast<char*>(&_impl_.height_),
          reinterpret_cast<char*>(&other->_impl_.height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HeightResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[4]);
}

// ===================================================================

class HeightProbe::_Internal {
 public:
};

HeightProbe::HeightProbe(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.HeightProbe)
}
HeightProbe::HeightProbe(const HeightProbe& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  HeightProbe* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tip_hash_){}
    , decltype(_impl_.total_work_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.tip_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tip_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_tip_hash().empty()) {
    _this->_impl_.tip_hash_.Set(from._internal_tip_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.total_work_, &from._impl_.total_work_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.total_work_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.HeightProbe)
}

inline void HeightProbe::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tip_hash_){}
    , decltype(_impl_.total_work_){uint64_t{0u}}
    , decltype(_impl_.height_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.tip_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.tip_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

HeightProbe::~HeightProbe() {
  // @@protoc_insertion_point(destructor:alyncoin.net.HeightProbe)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void HeightProbe::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.tip_hash_.Destroy();
}

void HeightProbe::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void HeightProbe::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.HeightProbe)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.tip_hash_.ClearToEmpty();
  ::memset(&_impl_.total_work_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.total_work_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* HeightProbe::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bytes tip_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_tip_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint64 total_work = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.total_work_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* HeightProbe::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.HeightProbe)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_height(), target);
  }

  // bytes tip_hash = 2;
  if (!this->_internal_tip_hash().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_tip_hash(), target);
  }

  // uint64 total_work = 3;
  if (this->_internal_total_work() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_total_work(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.HeightProbe)
  return target;
}

size_t HeightProbe::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.HeightProbe)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes tip_hash = 2;
  if (!this->_internal_tip_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_tip_hash());
  }

  // uint64 total_work = 3;
  if (this->_internal_total_work() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_work());
  }

  // uint32 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData HeightProbe::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    HeightProbe::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*HeightProbe::GetClassData() const { return &_class_data_; }


void HeightProbe::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<HeightProbe*>(&to_msg);
  auto& from = static_cast<const HeightProbe&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.HeightProbe)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_tip_hash().empty()) {
    _this->_internal_set_tip_hash(from._internal_tip_hash());
  }
  if (from._internal_total_work() != 0) {
    _this->_internal_set_total_work(from._internal_total_work());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void HeightProbe::CopyFrom(const HeightProbe& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.HeightProbe)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeightProbe::IsInitialized() const {
  return true;
}

void HeightProbe::InternalSwap(HeightProbe* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.tip_hash_, lhs_arena,
      &other->_impl_.tip_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(HeightProbe, _impl_.height_)
      + sizeof(HeightProbe::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(HeightProbe, _impl_.total_work_)>(
          reinterpret_cast<char*>(&_impl_.total_work_),
          reinterpret_cast<char*>(&other->_impl_.total_work_));
}

::PROTOBUF_NAMESPACE_ID::Metadata HeightProbe::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[5]);
}

// ===================================================================

class BlockBroadcast::_Internal {
 public:
  static const ::alyncoin::BlockProto& block(const BlockBroadcast* msg);
};

const ::alyncoin::BlockProto&
BlockBroadcast::_Internal::block(const BlockBroadcast* msg) {
  return *msg->_impl_.block_;
}
void BlockBroadcast::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
BlockBroadcast::BlockBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.BlockBroadcast)
}
BlockBroadcast::BlockBroadcast(const BlockBroadcast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockBroadcast* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::alyncoin::BlockProto(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.BlockBroadcast)
}

inline void BlockBroadcast::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BlockBroadcast::~BlockBroadcast() {
  // @@protoc_insertion_point(destructor:alyncoin.net.BlockBroadcast)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockBroadcast::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.block_;
}

void BlockBroadcast::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockBroadcast::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.BlockBroadcast)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockBroadcast::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .alyncoin.BlockProto block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockBroadcast::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.BlockBroadcast)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .alyncoin.BlockProto block = 1;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.BlockBroadcast)
  return target;
}

size_t BlockBroadcast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.BlockBroadcast)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .alyncoin.BlockProto block = 1;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockBroadcast::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockBroadcast::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockBroadcast::GetClassData() const { return &_class_data_; }


void BlockBroadcast::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockBroadcast*>(&to_msg);
  auto& from = static_cast<const BlockBroadcast&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.BlockBroadcast)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::alyncoin::BlockProto::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockBroadcast::CopyFrom(const BlockBroadcast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.BlockBroadcast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockBroadcast::IsInitialized() const {
  return true;
}

void BlockBroadcast::InternalSwap(BlockBroadcast* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockBroadcast::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[6]);
}

// ===================================================================

class BlockBatch::_Internal {
 public:
  static const ::alyncoin::BlockchainProto& chain(const BlockBatch* msg);
};

const ::alyncoin::BlockchainProto&
BlockBatch::_Internal::chain(const BlockBatch* msg) {
  return *msg->_impl_.chain_;
}
void BlockBatch::clear_chain() {
  if (GetArenaForAllocation() == nullptr && _impl_.chain_ != nullptr) {
    delete _impl_.chain_;
  }
  _impl_.chain_ = nullptr;
}
BlockBatch::BlockBatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.BlockBatch)
}
BlockBatch::BlockBatch(const BlockBatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockBatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.chain_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_chain()) {
    _this->_impl_.chain_ = new ::alyncoin::BlockchainProto(*from._impl_.chain_);
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.BlockBatch)
}

inline void BlockBatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.chain_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BlockBatch::~BlockBatch() {
  // @@protoc_insertion_point(destructor:alyncoin.net.BlockBatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockBatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.chain_;
}

void BlockBatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockBatch::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.BlockBatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.chain_ != nullptr) {
    delete _impl_.chain_;
  }
  _impl_.chain_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockBatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .alyncoin.BlockchainProto chain = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_chain(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockBatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.BlockBatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .alyncoin.BlockchainProto chain = 1;
  if (this->_internal_has_chain()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::chain(this),
        _Internal::chain(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.BlockBatch)
  return target;
}

size_t BlockBatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.BlockBatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .alyncoin.BlockchainProto chain = 1;
  if (this->_internal_has_chain()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.chain_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockBatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockBatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockBatch::GetClassData() const { return &_class_data_; }


void BlockBatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockBatch*>(&to_msg);
  auto& from = static_cast<const BlockBatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.BlockBatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_chain()) {
    _this->_internal_mutable_chain()->::alyncoin::BlockchainProto::MergeFrom(
        from._internal_chain());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockBatch::CopyFrom(const BlockBatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.BlockBatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockBatch::IsInitialized() const {
  return true;
}

void BlockBatch::InternalSwap(BlockBatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.chain_, other->_impl_.chain_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockBatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[7]);
}

// ===================================================================

class BlockRequest::_Internal {
 public:
};

BlockRequest::BlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.BlockRequest)
}
BlockRequest::BlockRequest(const BlockRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.index_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.BlockRequest)
}

inline void BlockRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.index_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BlockRequest::~BlockRequest() {
  // @@protoc_insertion_point(destructor:alyncoin.net.BlockRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void BlockRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.BlockRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.index_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.BlockRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->_internal_index() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.BlockRequest)
  return target;
}

size_t BlockRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.BlockRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 index = 1;
  if (this->_internal_index() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_index());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockRequest::GetClassData() const { return &_class_data_; }


void BlockRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockRequest*>(&to_msg);
  auto& from = static_cast<const BlockRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.BlockRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_index() != 0) {
    _this->_internal_set_index(from._internal_index());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockRequest::CopyFrom(const BlockRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.BlockRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockRequest::IsInitialized() const {
  return true;
}

void BlockRequest::InternalSwap(BlockRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.index_, other->_impl_.index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[8]);
}

// ===================================================================

class BlockResponse::_Internal {
 public:
  static const ::alyncoin::BlockProto& block(const BlockResponse* msg);
};

const ::alyncoin::BlockProto&
BlockResponse::_Internal::block(const BlockResponse* msg) {
  return *msg->_impl_.block_;
}
void BlockResponse::clear_block() {
  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
}
BlockResponse::BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.BlockResponse)
}
BlockResponse::BlockResponse(const BlockResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  BlockResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_block()) {
    _this->_impl_.block_ = new ::alyncoin::BlockProto(*from._impl_.block_);
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.BlockResponse)
}

inline void BlockResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.block_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

BlockResponse::~BlockResponse() {
  // @@protoc_insertion_point(destructor:alyncoin.net.BlockResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void BlockResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.block_;
}

void BlockResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void BlockResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.BlockResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.block_ != nullptr) {
    delete _impl_.block_;
  }
  _impl_.block_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* BlockResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .alyncoin.BlockProto block = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* BlockResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.BlockResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .alyncoin.BlockProto block = 1;
  if (this->_internal_has_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::block(this),
        _Internal::block(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.BlockResponse)
  return target;
}

size_t BlockResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.BlockResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .alyncoin.BlockProto block = 1;
  if (this->_internal_has_block()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.block_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData BlockResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    BlockResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*BlockResponse::GetClassData() const { return &_class_data_; }


void BlockResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<BlockResponse*>(&to_msg);
  auto& from = static_cast<const BlockResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.BlockResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_block()) {
    _this->_internal_mutable_block()->::alyncoin::BlockProto::MergeFrom(
        from._internal_block());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void BlockResponse::CopyFrom(const BlockResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.BlockResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BlockResponse::IsInitialized() const {
  return true;
}

void BlockResponse::InternalSwap(BlockResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.block_, other->_impl_.block_);
}

::PROTOBUF_NAMESPACE_ID::Metadata BlockResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[9]);
}

// ===================================================================

class SnapshotMeta::_Internal {
 public:
};

SnapshotMeta::SnapshotMeta(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.SnapshotMeta)
}
SnapshotMeta::SnapshotMeta(const SnapshotMeta& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SnapshotMeta* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.root_hash_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.total_bytes_){}
    , decltype(_impl_.chunk_size_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.root_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_root_hash().empty()) {
    _this->_impl_.root_hash_.Set(from._internal_root_hash(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.height_, &from._impl_.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.chunk_size_) -
    reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.chunk_size_));
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.SnapshotMeta)
}

inline void SnapshotMeta::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.root_hash_){}
    , decltype(_impl_.height_){uint64_t{0u}}
    , decltype(_impl_.total_bytes_){uint64_t{0u}}
    , decltype(_impl_.chunk_size_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.root_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.root_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SnapshotMeta::~SnapshotMeta() {
  // @@protoc_insertion_point(destructor:alyncoin.net.SnapshotMeta)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SnapshotMeta::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.root_hash_.Destroy();
}

void SnapshotMeta::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SnapshotMeta::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.SnapshotMeta)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.root_hash_.ClearToEmpty();
  ::memset(&_impl_.height_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.chunk_size_) -
      reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.chunk_size_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnapshotMeta::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string root_hash = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_root_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.SnapshotMeta.root_hash"));
        } else
          goto handle_unusual;
        continue;
      // uint64 total_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _impl_.total_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // uint32 chunk_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _impl_.chunk_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SnapshotMeta::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.SnapshotMeta)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 height = 1;
  if (this->_internal_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_height(), target);
  }

  // string root_hash = 2;
  if (!this->_internal_root_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_root_hash().data(), static_cast<int>(this->_internal_root_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.SnapshotMeta.root_hash");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_root_hash(), target);
  }

  // uint64 total_bytes = 3;
  if (this->_internal_total_bytes() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(3, this->_internal_total_bytes(), target);
  }

  // uint32 chunk_size = 4;
  if (this->_internal_chunk_size() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_chunk_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.SnapshotMeta)
  return target;
}

size_t SnapshotMeta::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.SnapshotMeta)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string root_hash = 2;
  if (!this->_internal_root_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_root_hash());
  }

  // uint64 height = 1;
  if (this->_internal_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_height());
  }

  // uint64 total_bytes = 3;
  if (this->_internal_total_bytes() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_total_bytes());
  }

  // uint32 chunk_size = 4;
  if (this->_internal_chunk_size() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_chunk_size());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotMeta::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SnapshotMeta::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotMeta::GetClassData() const { return &_class_data_; }


void SnapshotMeta::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SnapshotMeta*>(&to_msg);
  auto& from = static_cast<const SnapshotMeta&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.SnapshotMeta)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_root_hash().empty()) {
    _this->_internal_set_root_hash(from._internal_root_hash());
  }
  if (from._internal_height() != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  if (from._internal_total_bytes() != 0) {
    _this->_internal_set_total_bytes(from._internal_total_bytes());
  }
  if (from._internal_chunk_size() != 0) {
    _this->_internal_set_chunk_size(from._internal_chunk_size());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnapshotMeta::CopyFrom(const SnapshotMeta& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.SnapshotMeta)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotMeta::IsInitialized() const {
  return true;
}

void SnapshotMeta::InternalSwap(SnapshotMeta* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.root_hash_, lhs_arena,
      &other->_impl_.root_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SnapshotMeta, _impl_.chunk_size_)
      + sizeof(SnapshotMeta::_impl_.chunk_size_)
      - PROTOBUF_FIELD_OFFSET(SnapshotMeta, _impl_.height_)>(
          reinterpret_cast<char*>(&_impl_.height_),
          reinterpret_cast<char*>(&other->_impl_.height_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotMeta::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[10]);
}

// ===================================================================

class SnapshotChunk::_Internal {
 public:
};

SnapshotChunk::SnapshotChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.SnapshotChunk)
}
SnapshotChunk::SnapshotChunk(const SnapshotChunk& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SnapshotChunk* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.SnapshotChunk)
}

inline void SnapshotChunk::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SnapshotChunk::~SnapshotChunk() {
  // @@protoc_insertion_point(destructor:alyncoin.net.SnapshotChunk)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SnapshotChunk::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void SnapshotChunk::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SnapshotChunk::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.SnapshotChunk)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnapshotChunk::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SnapshotChunk::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.SnapshotChunk)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.SnapshotChunk)
  return target;
}

size_t SnapshotChunk::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.SnapshotChunk)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotChunk::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SnapshotChunk::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotChunk::GetClassData() const { return &_class_data_; }


void SnapshotChunk::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SnapshotChunk*>(&to_msg);
  auto& from = static_cast<const SnapshotChunk&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.SnapshotChunk)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnapshotChunk::CopyFrom(const SnapshotChunk& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.SnapshotChunk)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotChunk::IsInitialized() const {
  return true;
}

void SnapshotChunk::InternalSwap(SnapshotChunk* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotChunk::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[11]);
}

// ===================================================================

class SnapshotAck::_Internal {
 public:
};

SnapshotAck::SnapshotAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.SnapshotAck)
}
SnapshotAck::SnapshotAck(const SnapshotAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SnapshotAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.seq_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.seq_ = from._impl_.seq_;
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.SnapshotAck)
}

inline void SnapshotAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.seq_){0u}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SnapshotAck::~SnapshotAck() {
  // @@protoc_insertion_point(destructor:alyncoin.net.SnapshotAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SnapshotAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SnapshotAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SnapshotAck::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.SnapshotAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.seq_ = 0u;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnapshotAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint32 seq = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.seq_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SnapshotAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.SnapshotAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint32 seq = 1;
  if (this->_internal_seq() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_seq(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.SnapshotAck)
  return target;
}

size_t SnapshotAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.SnapshotAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint32 seq = 1;
  if (this->_internal_seq() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_seq());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SnapshotAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotAck::GetClassData() const { return &_class_data_; }


void SnapshotAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SnapshotAck*>(&to_msg);
  auto& from = static_cast<const SnapshotAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.SnapshotAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_seq() != 0) {
    _this->_internal_set_seq(from._internal_seq());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnapshotAck::CopyFrom(const SnapshotAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.SnapshotAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotAck::IsInitialized() const {
  return true;
}

void SnapshotAck::InternalSwap(SnapshotAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.seq_, other->_impl_.seq_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[12]);
}

// ===================================================================

class SnapshotEnd::_Internal {
 public:
};

SnapshotEnd::SnapshotEnd(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.SnapshotEnd)
}
SnapshotEnd::SnapshotEnd(const SnapshotEnd& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  SnapshotEnd* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.SnapshotEnd)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotEnd::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotEnd::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata SnapshotEnd::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[13]);
}

// ===================================================================

class TailBlocks::_Internal {
 public:
};

void TailBlocks::clear_blocks() {
  _impl_.blocks_.Clear();
}
TailBlocks::TailBlocks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.TailBlocks)
}
TailBlocks::TailBlocks(const TailBlocks& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TailBlocks* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.blocks_){from._impl_.blocks_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.TailBlocks)
}

inline void TailBlocks::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.blocks_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TailBlocks::~TailBlocks() {
  // @@protoc_insertion_point(destructor:alyncoin.net.TailBlocks)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TailBlocks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.blocks_.~RepeatedPtrField();
}

void TailBlocks::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TailBlocks::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.TailBlocks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.blocks_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TailBlocks::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .alyncoin.BlockProto blocks = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_blocks(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TailBlocks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.TailBlocks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .alyncoin.BlockProto blocks = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_blocks_size()); i < n; i++) {
    const auto& repfield = this->_internal_blocks(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.TailBlocks)
  return target;
}

size_t TailBlocks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.TailBlocks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .alyncoin.BlockProto blocks = 1;
  total_size += 1UL * this->_internal_blocks_size();
  for (const auto& msg : this->_impl_.blocks_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TailBlocks::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TailBlocks::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TailBlocks::GetClassData() const { return &_class_data_; }


void TailBlocks::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TailBlocks*>(&to_msg);
  auto& from = static_cast<const TailBlocks&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.TailBlocks)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.blocks_.MergeFrom(from._impl_.blocks_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TailBlocks::CopyFrom(const TailBlocks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.TailBlocks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TailBlocks::IsInitialized() const {
  return true;
}

void TailBlocks::InternalSwap(TailBlocks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.blocks_.InternalSwap(&other->_impl_.blocks_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TailBlocks::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[14]);
}

// ===================================================================

class EpochProof::_Internal {
 public:
};

EpochProof::EpochProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.EpochProof)
}
EpochProof::EpochProof(const EpochProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  EpochProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.EpochProof)
}

inline void EpochProof::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

EpochProof::~EpochProof() {
  // @@protoc_insertion_point(destructor:alyncoin.net.EpochProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void EpochProof::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void EpochProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void EpochProof::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.EpochProof)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* EpochProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* EpochProof::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.EpochProof)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.EpochProof)
  return target;
}

size_t EpochProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.EpochProof)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData EpochProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    EpochProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*EpochProof::GetClassData() const { return &_class_data_; }


void EpochProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<EpochProof*>(&to_msg);
  auto& from = static_cast<const EpochProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.EpochProof)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void EpochProof::CopyFrom(const EpochProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.EpochProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool EpochProof::IsInitialized() const {
  return true;
}

void EpochProof::InternalSwap(EpochProof* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata EpochProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[15]);
}

// ===================================================================

class Inventory::_Internal {
 public:
};

Inventory::Inventory(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Inventory)
}
Inventory::Inventory(const Inventory& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Inventory* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){from._impl_.hashes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Inventory)
}

inline void Inventory::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Inventory::~Inventory() {
  // @@protoc_insertion_point(destructor:alyncoin.net.Inventory)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Inventory::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hashes_.~RepeatedPtrField();
}

void Inventory::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Inventory::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.Inventory)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hashes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Inventory::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.Inventory.hashes"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Inventory::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.Inventory)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string hashes = 1;
  for (int i = 0, n = this->_internal_hashes_size(); i < n; i++) {
    const auto& s = this->_internal_hashes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.Inventory.hashes");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.Inventory)
  return target;
}

size_t Inventory::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.Inventory)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string hashes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hashes_.size());
  for (int i = 0, n = _impl_.hashes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.hashes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Inventory::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Inventory::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Inventory::GetClassData() const { return &_class_data_; }


void Inventory::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Inventory*>(&to_msg);
  auto& from = static_cast<const Inventory&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.Inventory)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hashes_.MergeFrom(from._impl_.hashes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Inventory::CopyFrom(const Inventory& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.Inventory)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Inventory::IsInitialized() const {
  return true;
}

void Inventory::InternalSwap(Inventory* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hashes_.InternalSwap(&other->_impl_.hashes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Inventory::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[16]);
}

// ===================================================================

class TipHashRequest::_Internal {
 public:
};

TipHashRequest::TipHashRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.TipHashRequest)
}
TipHashRequest::TipHashRequest(const TipHashRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  TipHashRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.TipHashRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TipHashRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TipHashRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata TipHashRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[17]);
}

// ===================================================================

class TipHashResponse::_Internal {
 public:
};

TipHashResponse::TipHashResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.TipHashResponse)
}
TipHashResponse::TipHashResponse(const TipHashResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TipHashResponse* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_hash().empty()) {
    _this->_impl_.hash_.Set(from._internal_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.TipHashResponse)
}

inline void TipHashResponse::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

TipHashResponse::~TipHashResponse() {
  // @@protoc_insertion_point(destructor:alyncoin.net.TipHashResponse)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TipHashResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hash_.Destroy();
}

void TipHashResponse::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TipHashResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.TipHashResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TipHashResponse::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.TipHashResponse.hash"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TipHashResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.TipHashResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string hash = 1;
  if (!this->_internal_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_hash().data(), static_cast<int>(this->_internal_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.TipHashResponse.hash");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.TipHashResponse)
  return target;
}

size_t TipHashResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.TipHashResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string hash = 1;
  if (!this->_internal_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TipHashResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TipHashResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TipHashResponse::GetClassData() const { return &_class_data_; }


void TipHashResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TipHashResponse*>(&to_msg);
  auto& from = static_cast<const TipHashResponse&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.TipHashResponse)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_hash().empty()) {
    _this->_internal_set_hash(from._internal_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TipHashResponse::CopyFrom(const TipHashResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.TipHashResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TipHashResponse::IsInitialized() const {
  return true;
}

void TipHashResponse::InternalSwap(TipHashResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.hash_, lhs_arena,
      &other->_impl_.hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata TipHashResponse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[18]);
}

// ===================================================================

class PeerListRequest::_Internal {
 public:
};

PeerListRequest::PeerListRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.PeerListRequest)
}
PeerListRequest::PeerListRequest(const PeerListRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  PeerListRequest* const _this = this; (void)_this;
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.PeerListRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PeerListRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PeerListRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata PeerListRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[19]);
}

// ===================================================================

class PeerList::_Internal {
 public:
};

PeerList::PeerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.PeerList)
}
PeerList::PeerList(const PeerList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  PeerList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peers_){from._impl_.peers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.PeerList)
}

inline void PeerList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.peers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

PeerList::~PeerList() {
  // @@protoc_insertion_point(destructor:alyncoin.net.PeerList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PeerList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peers_.~RepeatedPtrField();
}

void PeerList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PeerList::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.PeerList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PeerList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string peers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_peers();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.PeerList.peers"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* PeerList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.PeerList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string peers = 1;
  for (int i = 0, n = this->_internal_peers_size(); i < n; i++) {
    const auto& s = this->_internal_peers(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.PeerList.peers");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.PeerList)
  return target;
}

size_t PeerList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.PeerList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string peers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.peers_.size());
  for (int i = 0, n = _impl_.peers_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.peers_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PeerList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PeerList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PeerList::GetClassData() const { return &_class_data_; }


void PeerList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PeerList*>(&to_msg);
  auto& from = static_cast<const PeerList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.PeerList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peers_.MergeFrom(from._impl_.peers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PeerList::CopyFrom(const PeerList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.PeerList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PeerList::IsInitialized() const {
  return true;
}

void PeerList::InternalSwap(PeerList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.peers_.InternalSwap(&other->_impl_.peers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PeerList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[20]);
}

// ===================================================================

class RollupBlockMsg::_Internal {
 public:
};

RollupBlockMsg::RollupBlockMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.RollupBlockMsg)
}
RollupBlockMsg::RollupBlockMsg(const RollupBlockMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RollupBlockMsg* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.RollupBlockMsg)
}

inline void RollupBlockMsg::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

RollupBlockMsg::~RollupBlockMsg() {
  // @@protoc_insertion_point(destructor:alyncoin.net.RollupBlockMsg)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RollupBlockMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void RollupBlockMsg::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RollupBlockMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.RollupBlockMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RollupBlockMsg::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RollupBlockMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.RollupBlockMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.RollupBlockMsg)
  return target;
}

size_t RollupBlockMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.RollupBlockMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RollupBlockMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RollupBlockMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RollupBlockMsg::GetClassData() const { return &_class_data_; }


void RollupBlockMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RollupBlockMsg*>(&to_msg);
  auto& from = static_cast<const RollupBlockMsg&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.RollupBlockMsg)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RollupBlockMsg::CopyFrom(const RollupBlockMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.RollupBlockMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RollupBlockMsg::IsInitialized() const {
  return true;
}

void RollupBlockMsg::InternalSwap(RollupBlockMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata RollupBlockMsg::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[21]);
}

// ===================================================================

class SnapshotRequest::_Internal {
 public:
};

SnapshotRequest::SnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.SnapshotRequest)
}
SnapshotRequest::SnapshotRequest(const SnapshotRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SnapshotRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.until_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.until_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.until_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_until_hash().empty()) {
    _this->_impl_.until_hash_.Set(from._internal_until_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.SnapshotRequest)
}

inline void SnapshotRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.until_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.until_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.until_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SnapshotRequest::~SnapshotRequest() {
  // @@protoc_insertion_point(destructor:alyncoin.net.SnapshotRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SnapshotRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.until_hash_.Destroy();
}

void SnapshotRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SnapshotRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.SnapshotRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.until_hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SnapshotRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string until_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_until_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.SnapshotRequest.until_hash"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SnapshotRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.SnapshotRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string until_hash = 1;
  if (!this->_internal_until_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_until_hash().data(), static_cast<int>(this->_internal_until_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.SnapshotRequest.until_hash");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_until_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.SnapshotRequest)
  return target;
}

size_t SnapshotRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.SnapshotRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string until_hash = 1;
  if (!this->_internal_until_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_until_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SnapshotRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SnapshotRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SnapshotRequest::GetClassData() const { return &_class_data_; }


void SnapshotRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SnapshotRequest*>(&to_msg);
  auto& from = static_cast<const SnapshotRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.SnapshotRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_until_hash().empty()) {
    _this->_internal_set_until_hash(from._internal_until_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SnapshotRequest::CopyFrom(const SnapshotRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.SnapshotRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SnapshotRequest::IsInitialized() const {
  return true;
}

void SnapshotRequest::InternalSwap(SnapshotRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.until_hash_, lhs_arena,
      &other->_impl_.until_hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata SnapshotRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[22]);
}

// ===================================================================

class TailBlocksRequest::_Internal {
 public:
};

TailBlocksRequest::TailBlocksRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.TailBlocksRequest)
}
TailBlocksRequest::TailBlocksRequest(const TailBlocksRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TailBlocksRequest* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.from_height_ = from._impl_.from_height_;
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.TailBlocksRequest)
}

inline void TailBlocksRequest::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_height_){uint64_t{0u}}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TailBlocksRequest::~TailBlocksRequest() {
  // @@protoc_insertion_point(destructor:alyncoin.net.TailBlocksRequest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TailBlocksRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TailBlocksRequest::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TailBlocksRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.TailBlocksRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.from_height_ = uint64_t{0u};
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TailBlocksRequest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // uint64 from_height = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _impl_.from_height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TailBlocksRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.TailBlocksRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // uint64 from_height = 1;
  if (this->_internal_from_height() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_from_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.TailBlocksRequest)
  return target;
}

size_t TailBlocksRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.TailBlocksRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // uint64 from_height = 1;
  if (this->_internal_from_height() != 0) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_from_height());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TailBlocksRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TailBlocksRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TailBlocksRequest::GetClassData() const { return &_class_data_; }


void TailBlocksRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TailBlocksRequest*>(&to_msg);
  auto& from = static_cast<const TailBlocksRequest&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.TailBlocksRequest)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_from_height() != 0) {
    _this->_internal_set_from_height(from._internal_from_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TailBlocksRequest::CopyFrom(const TailBlocksRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.TailBlocksRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TailBlocksRequest::IsInitialized() const {
  return true;
}

void TailBlocksRequest::InternalSwap(TailBlocksRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.from_height_, other->_impl_.from_height_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TailBlocksRequest::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[23]);
}

// ===================================================================

class GetData::_Internal {
 public:
};

GetData::GetData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.GetData)
}
GetData::GetData(const GetData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){from._impl_.hashes_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.GetData)
}

inline void GetData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.hashes_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

GetData::~GetData() {
  // @@protoc_insertion_point(destructor:alyncoin.net.GetData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.hashes_.~RepeatedPtrField();
}

void GetData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetData::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.GetData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.hashes_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string hashes = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_hashes();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.GetData.hashes"));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.GetData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string hashes = 1;
  for (int i = 0, n = this->_internal_hashes_size(); i < n; i++) {
    const auto& s = this->_internal_hashes(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.GetData.hashes");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.GetData)
  return target;
}

size_t GetData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.GetData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string hashes = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.hashes_.size());
  for (int i = 0, n = _impl_.hashes_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.hashes_.Get(i));
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetData::GetClassData() const { return &_class_data_; }


void GetData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetData*>(&to_msg);
  auto& from = static_cast<const GetData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.GetData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.hashes_.MergeFrom(from._impl_.hashes_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetData::CopyFrom(const GetData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.GetData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetData::IsInitialized() const {
  return true;
}

void GetData::InternalSwap(GetData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.hashes_.InternalSwap(&other->_impl_.hashes_);
}

::PROTOBUF_NAMESPACE_ID::Metadata GetData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[24]);
}

// ===================================================================

class GetHeaders::_Internal {
 public:
};

GetHeaders::GetHeaders(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.GetHeaders)
}
GetHeaders::GetHeaders(const GetHeaders& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  GetHeaders* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.from_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.from_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_from_hash().empty()) {
    _this->_impl_.from_hash_.Set(from._internal_from_hash(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.GetHeaders)
}

inline void GetHeaders::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.from_hash_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.from_hash_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.from_hash_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

GetHeaders::~GetHeaders() {
  // @@protoc_insertion_point(destructor:alyncoin.net.GetHeaders)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void GetHeaders::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.from_hash_.Destroy();
}

void GetHeaders::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void GetHeaders::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.GetHeaders)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.from_hash_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GetHeaders::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string from_hash = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_from_hash();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "alyncoin.net.GetHeaders.from_hash"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GetHeaders::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.GetHeaders)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string from_hash = 1;
  if (!this->_internal_from_hash().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_from_hash().data(), static_cast<int>(this->_internal_from_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "alyncoin.net.GetHeaders.from_hash");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_from_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.GetHeaders)
  return target;
}

size_t GetHeaders::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.GetHeaders)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string from_hash = 1;
  if (!this->_internal_from_hash().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_from_hash());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GetHeaders::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    GetHeaders::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetHeaders::GetClassData() const { return &_class_data_; }


void GetHeaders::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<GetHeaders*>(&to_msg);
  auto& from = static_cast<const GetHeaders&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.GetHeaders)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_from_hash().empty()) {
    _this->_internal_set_from_hash(from._internal_from_hash());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GetHeaders::CopyFrom(const GetHeaders& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.GetHeaders)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GetHeaders::IsInitialized() const {
  return true;
}

void GetHeaders::InternalSwap(GetHeaders* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.from_hash_, lhs_arena,
      &other->_impl_.from_hash_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata GetHeaders::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[25]);
}

// ===================================================================

class Headers::_Internal {
 public:
};

void Headers::clear_headers() {
  _impl_.headers_.Clear();
}
Headers::Headers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Headers)
}
Headers::Headers(const Headers& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Headers* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.headers_){from._impl_.headers_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Headers)
}

inline void Headers::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.headers_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Headers::~Headers() {
  // @@protoc_insertion_point(destructor:alyncoin.net.Headers)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Headers::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.headers_.~RepeatedPtrField();
}

void Headers::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Headers::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.Headers)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.headers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Headers::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .alyncoin.BlockProto headers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_headers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Headers::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.Headers)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .alyncoin.BlockProto headers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_headers_size()); i < n; i++) {
    const auto& repfield = this->_internal_headers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.Headers)
  return target;
}

size_t Headers::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.Headers)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .alyncoin.BlockProto headers = 1;
  total_size += 1UL * this->_internal_headers_size();
  for (const auto& msg : this->_impl_.headers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Headers::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Headers::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Headers::GetClassData() const { return &_class_data_; }


void Headers::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Headers*>(&to_msg);
  auto& from = static_cast<const Headers&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.Headers)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.headers_.MergeFrom(from._impl_.headers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Headers::CopyFrom(const Headers& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.Headers)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Headers::IsInitialized() const {
  return true;
}

void Headers::InternalSwap(Headers* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.headers_.InternalSwap(&other->_impl_.headers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Headers::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[26]);
}

// ===================================================================

class StateProof::_Internal {
 public:
  static const ::alyncoin::StateProofProto& proof(const StateProof* msg);
};

const ::alyncoin::StateProofProto&
StateProof::_Internal::proof(const StateProof* msg) {
  return *msg->_impl_.proof_;
}
void StateProof::clear_proof() {
  if (GetArenaForAllocation() == nullptr && _impl_.proof_ != nullptr) {
    delete _impl_.proof_;
  }
  _impl_.proof_ = nullptr;
}
StateProof::StateProof(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.StateProof)
}
StateProof::StateProof(const StateProof& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  StateProof* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_proof()) {
    _this->_impl_.proof_ = new ::alyncoin::StateProofProto(*from._impl_.proof_);
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.StateProof)
}

inline void StateProof::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.proof_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

StateProof::~StateProof() {
  // @@protoc_insertion_point(destructor:alyncoin.net.StateProof)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StateProof::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.proof_;
}

void StateProof::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void StateProof::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.StateProof)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.proof_ != nullptr) {
    delete _impl_.proof_;
  }
  _impl_.proof_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* StateProof::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .alyncoin.StateProofProto proof = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_proof(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StateProof::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.StateProof)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .alyncoin.StateProofProto proof = 1;
  if (this->_internal_has_proof()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::proof(this),
        _Internal::proof(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.StateProof)
  return target;
}

size_t StateProof::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.StateProof)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .alyncoin.StateProofProto proof = 1;
  if (this->_internal_has_proof()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.proof_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData StateProof::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    StateProof::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*StateProof::GetClassData() const { return &_class_data_; }


void StateProof::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<StateProof*>(&to_msg);
  auto& from = static_cast<const StateProof&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.StateProof)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_proof()) {
    _this->_internal_mutable_proof()->::alyncoin::StateProofProto::MergeFrom(
        from._internal_proof());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void StateProof::CopyFrom(const StateProof& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.StateProof)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StateProof::IsInitialized() const {
  return true;
}

void StateProof::InternalSwap(StateProof* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.proof_, other->_impl_.proof_);
}

::PROTOBUF_NAMESPACE_ID::Metadata StateProof::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[27]);
}

// ===================================================================

class TransactionBroadcast::_Internal {
 public:
  static const ::alyncoin::TransactionProto& tx(const TransactionBroadcast* msg);
};

const ::alyncoin::TransactionProto&
TransactionBroadcast::_Internal::tx(const TransactionBroadcast* msg) {
  return *msg->_impl_.tx_;
}
void TransactionBroadcast::clear_tx() {
  if (GetArenaForAllocation() == nullptr && _impl_.tx_ != nullptr) {
    delete _impl_.tx_;
  }
  _impl_.tx_ = nullptr;
}
TransactionBroadcast::TransactionBroadcast(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.TransactionBroadcast)
}
TransactionBroadcast::TransactionBroadcast(const TransactionBroadcast& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  TransactionBroadcast* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.tx_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_tx()) {
    _this->_impl_.tx_ = new ::alyncoin::TransactionProto(*from._impl_.tx_);
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.TransactionBroadcast)
}

inline void TransactionBroadcast::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.tx_){nullptr}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

TransactionBroadcast::~TransactionBroadcast() {
  // @@protoc_insertion_point(destructor:alyncoin.net.TransactionBroadcast)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TransactionBroadcast::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.tx_;
}

void TransactionBroadcast::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TransactionBroadcast::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.TransactionBroadcast)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && _impl_.tx_ != nullptr) {
    delete _impl_.tx_;
  }
  _impl_.tx_ = nullptr;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TransactionBroadcast::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .alyncoin.TransactionProto tx = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_tx(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TransactionBroadcast::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.TransactionBroadcast)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .alyncoin.TransactionProto tx = 1;
  if (this->_internal_has_tx()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::tx(this),
        _Internal::tx(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.TransactionBroadcast)
  return target;
}

size_t TransactionBroadcast::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.TransactionBroadcast)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .alyncoin.TransactionProto tx = 1;
  if (this->_internal_has_tx()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.tx_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TransactionBroadcast::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TransactionBroadcast::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TransactionBroadcast::GetClassData() const { return &_class_data_; }


void TransactionBroadcast::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TransactionBroadcast*>(&to_msg);
  auto& from = static_cast<const TransactionBroadcast&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.TransactionBroadcast)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_tx()) {
    _this->_internal_mutable_tx()->::alyncoin::TransactionProto::MergeFrom(
        from._internal_tx());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TransactionBroadcast::CopyFrom(const TransactionBroadcast& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.TransactionBroadcast)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TransactionBroadcast::IsInitialized() const {
  return true;
}

void TransactionBroadcast::InternalSwap(TransactionBroadcast* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.tx_, other->_impl_.tx_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TransactionBroadcast::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[28]);
}

// ===================================================================

class Whisper::_Internal {
 public:
};

Whisper::Whisper(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Whisper)
}
Whisper::Whisper(const Whisper& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Whisper* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_data().empty()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Whisper)
}

inline void Whisper::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Whisper::~Whisper() {
  // @@protoc_insertion_point(destructor:alyncoin.net.Whisper)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Whisper::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void Whisper::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Whisper::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.Whisper)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.ClearToEmpty();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Whisper::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Whisper::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.Whisper)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.Whisper)
  return target;
}

size_t Whisper::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.Whisper)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // bytes data = 1;
  if (!this->_internal_data().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Whisper::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Whisper::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Whisper::GetClassData() const { return &_class_data_; }


void Whisper::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Whisper*>(&to_msg);
  auto& from = static_cast<const Whisper&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.Whisper)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_data().empty()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Whisper::CopyFrom(const Whisper& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.Whisper)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Whisper::IsInitialized() const {
  return true;
}

void Whisper::InternalSwap(Whisper* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata Whisper::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[29]);
}

// ===================================================================

class Frame::_Internal {
 public:
  static const ::alyncoin::net::Handshake& handshake(const Frame* msg);
  static const ::alyncoin::net::Ping& ping(const Frame* msg);
  static const ::alyncoin::net::Pong& pong(const Frame* msg);
  static const ::alyncoin::net::HeightRequest& height_req(const Frame* msg);
  static const ::alyncoin::net::HeightResponse& height_res(const Frame* msg);
  static const ::alyncoin::net::HeightProbe& height_probe(const Frame* msg);
  static const ::alyncoin::net::BlockBroadcast& block_broadcast(const Frame* msg);
  static const ::alyncoin::net::BlockBatch& block_batch(const Frame* msg);
  static const ::alyncoin::net::BlockRequest& block_request(const Frame* msg);
  static const ::alyncoin::net::BlockResponse& block_response(const Frame* msg);
  static const ::alyncoin::net::SnapshotMeta& snapshot_meta(const Frame* msg);
  static const ::alyncoin::net::SnapshotChunk& snapshot_chunk(const Frame* msg);
  static const ::alyncoin::net::SnapshotAck& snapshot_ack(const Frame* msg);
  static const ::alyncoin::net::SnapshotEnd& snapshot_end(const Frame* msg);
  static const ::alyncoin::net::TailBlocks& tail_blocks(const Frame* msg);
  static const ::alyncoin::net::EpochProof& agg_proof(const Frame* msg);
  static const ::alyncoin::net::Inventory& inv(const Frame* msg);
  static const ::alyncoin::net::TipHashRequest& tip_hash_req(const Frame* msg);
  static const ::alyncoin::net::TipHashResponse& tip_hash_res(const Frame* msg);
  static const ::alyncoin::net::PeerListRequest& peer_list_req(const Frame* msg);
  static const ::alyncoin::net::PeerList& peer_list(const Frame* msg);
  static const ::alyncoin::net::RollupBlockMsg& rollup_block(const Frame* msg);
  static const ::alyncoin::net::SnapshotRequest& snapshot_req(const Frame* msg);
  static const ::alyncoin::net::TailBlocksRequest& tail_req(const Frame* msg);
  static const ::alyncoin::net::StateProof& state_proof(const Frame* msg);
  static const ::alyncoin::net::GetData& get_data(const Frame* msg);
  static const ::alyncoin::BlockchainSyncProto& blockchain_sync_request(const Frame* msg);
  static const ::alyncoin::net::TransactionBroadcast& tx_broadcast(const Frame* msg);
  static const ::alyncoin::net::Whisper& whisper(const Frame* msg);
  static const ::alyncoin::net::GetHeaders& get_headers(const Frame* msg);
  static const ::alyncoin::net::Headers& headers(const Frame* msg);
};

const ::alyncoin::net::Handshake&
Frame::_Internal::handshake(const Frame* msg) {
  return *msg->_impl_.kind_.handshake_;
}
const ::alyncoin::net::Ping&
Frame::_Internal::ping(const Frame* msg) {
  return *msg->_impl_.kind_.ping_;
}
const ::alyncoin::net::Pong&
Frame::_Internal::pong(const Frame* msg) {
  return *msg->_impl_.kind_.pong_;
}
const ::alyncoin::net::HeightRequest&
Frame::_Internal::height_req(const Frame* msg) {
  return *msg->_impl_.kind_.height_req_;
}
const ::alyncoin::net::HeightResponse&
Frame::_Internal::height_res(const Frame* msg) {
  return *msg->_impl_.kind_.height_res_;
}
const ::alyncoin::net::HeightProbe&
Frame::_Internal::height_probe(const Frame* msg) {
  return *msg->_impl_.kind_.height_probe_;
}
const ::alyncoin::net::BlockBroadcast&
Frame::_Internal::block_broadcast(const Frame* msg) {
  return *msg->_impl_.kind_.block_broadcast_;
}
const ::alyncoin::net::BlockBatch&
Frame::_Internal::block_batch(const Frame* msg) {
  return *msg->_impl_.kind_.block_batch_;
}
const ::alyncoin::net::BlockRequest&
Frame::_Internal::block_request(const Frame* msg) {
  return *msg->_impl_.kind_.block_request_;
}
const ::alyncoin::net::BlockResponse&
Frame::_Internal::block_response(const Frame* msg) {
  return *msg->_impl_.kind_.block_response_;
}
const ::alyncoin::net::SnapshotMeta&
Frame::_Internal::snapshot_meta(const Frame* msg) {
  return *msg->_impl_.kind_.snapshot_meta_;
}
const ::alyncoin::net::SnapshotChunk&
Frame::_Internal::snapshot_chunk(const Frame* msg) {
  return *msg->_impl_.kind_.snapshot_chunk_;
}
const ::alyncoin::net::SnapshotAck&
Frame::_Internal::snapshot_ack(const Frame* msg) {
  return *msg->_impl_.kind_.snapshot_ack_;
}
const ::alyncoin::net::SnapshotEnd&
Frame::_Internal::snapshot_end(const Frame* msg) {
  return *msg->_impl_.kind_.snapshot_end_;
}
const ::alyncoin::net::TailBlocks&
Frame::_Internal::tail_blocks(const Frame* msg) {
  return *msg->_impl_.kind_.tail_blocks_;
}
const ::alyncoin::net::EpochProof&
Frame::_Internal::agg_proof(const Frame* msg) {
  return *msg->_impl_.kind_.agg_proof_;
}
const ::alyncoin::net::Inventory&
Frame::_Internal::inv(const Frame* msg) {
  return *msg->_impl_.kind_.inv_;
}
const ::alyncoin::net::TipHashRequest&
Frame::_Internal::tip_hash_req(const Frame* msg) {
  return *msg->_impl_.kind_.tip_hash_req_;
}
const ::alyncoin::net::TipHashResponse&
Frame::_Internal::tip_hash_res(const Frame* msg) {
  return *msg->_impl_.kind_.tip_hash_res_;
}
const ::alyncoin::net::PeerListRequest&
Frame::_Internal::peer_list_req(const Frame* msg) {
  return *msg->_impl_.kind_.peer_list_req_;
}
const ::alyncoin::net::PeerList&
Frame::_Internal::peer_list(const Frame* msg) {
  return *msg->_impl_.kind_.peer_list_;
}
const ::alyncoin::net::RollupBlockMsg&
Frame::_Internal::rollup_block(const Frame* msg) {
  return *msg->_impl_.kind_.rollup_block_;
}
const ::alyncoin::net::SnapshotRequest&
Frame::_Internal::snapshot_req(const Frame* msg) {
  return *msg->_impl_.kind_.snapshot_req_;
}
const ::alyncoin::net::TailBlocksRequest&
Frame::_Internal::tail_req(const Frame* msg) {
  return *msg->_impl_.kind_.tail_req_;
}
const ::alyncoin::net::StateProof&
Frame::_Internal::state_proof(const Frame* msg) {
  return *msg->_impl_.kind_.state_proof_;
}
const ::alyncoin::net::GetData&
Frame::_Internal::get_data(const Frame* msg) {
  return *msg->_impl_.kind_.get_data_;
}
const ::alyncoin::BlockchainSyncProto&
Frame::_Internal::blockchain_sync_request(const Frame* msg) {
  return *msg->_impl_.kind_.blockchain_sync_request_;
}
const ::alyncoin::net::TransactionBroadcast&
Frame::_Internal::tx_broadcast(const Frame* msg) {
  return *msg->_impl_.kind_.tx_broadcast_;
}
const ::alyncoin::net::Whisper&
Frame::_Internal::whisper(const Frame* msg) {
  return *msg->_impl_.kind_.whisper_;
}
const ::alyncoin::net::GetHeaders&
Frame::_Internal::get_headers(const Frame* msg) {
  return *msg->_impl_.kind_.get_headers_;
}
const ::alyncoin::net::Headers&
Frame::_Internal::headers(const Frame* msg) {
  return *msg->_impl_.kind_.headers_;
}
void Frame::set_allocated_handshake(::alyncoin::net::Handshake* handshake) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (handshake) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(handshake);
    if (message_arena != submessage_arena) {
      handshake = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handshake, submessage_arena);
    }
    set_has_handshake();
    _impl_.kind_.handshake_ = handshake;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.handshake)
}
void Frame::set_allocated_ping(::alyncoin::net::Ping* ping) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (ping) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ping);
    if (message_arena != submessage_arena) {
      ping = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ping, submessage_arena);
    }
    set_has_ping();
    _impl_.kind_.ping_ = ping;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.ping)
}
void Frame::set_allocated_pong(::alyncoin::net::Pong* pong) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (pong) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(pong);
    if (message_arena != submessage_arena) {
      pong = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pong, submessage_arena);
    }
    set_has_pong();
    _impl_.kind_.pong_ = pong;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.pong)
}
void Frame::set_allocated_height_req(::alyncoin::net::HeightRequest* height_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (height_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(height_req);
    if (message_arena != submessage_arena) {
      height_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_req, submessage_arena);
    }
    set_has_height_req();
    _impl_.kind_.height_req_ = height_req;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.height_req)
}
void Frame::set_allocated_height_res(::alyncoin::net::HeightResponse* height_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (height_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(height_res);
    if (message_arena != submessage_arena) {
      height_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_res, submessage_arena);
    }
    set_has_height_res();
    _impl_.kind_.height_res_ = height_res;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.height_res)
}
void Frame::set_allocated_height_probe(::alyncoin::net::HeightProbe* height_probe) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (height_probe) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(height_probe);
    if (message_arena != submessage_arena) {
      height_probe = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, height_probe, submessage_arena);
    }
    set_has_height_probe();
    _impl_.kind_.height_probe_ = height_probe;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.height_probe)
}
void Frame::set_allocated_block_broadcast(::alyncoin::net::BlockBroadcast* block_broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (block_broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_broadcast);
    if (message_arena != submessage_arena) {
      block_broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_broadcast, submessage_arena);
    }
    set_has_block_broadcast();
    _impl_.kind_.block_broadcast_ = block_broadcast;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.block_broadcast)
}
void Frame::set_allocated_block_batch(::alyncoin::net::BlockBatch* block_batch) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (block_batch) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_batch);
    if (message_arena != submessage_arena) {
      block_batch = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_batch, submessage_arena);
    }
    set_has_block_batch();
    _impl_.kind_.block_batch_ = block_batch;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.block_batch)
}
void Frame::set_allocated_block_request(::alyncoin::net::BlockRequest* block_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (block_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_request);
    if (message_arena != submessage_arena) {
      block_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_request, submessage_arena);
    }
    set_has_block_request();
    _impl_.kind_.block_request_ = block_request;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.block_request)
}
void Frame::set_allocated_block_response(::alyncoin::net::BlockResponse* block_response) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (block_response) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(block_response);
    if (message_arena != submessage_arena) {
      block_response = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_response, submessage_arena);
    }
    set_has_block_response();
    _impl_.kind_.block_response_ = block_response;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.block_response)
}
void Frame::set_allocated_snapshot_meta(::alyncoin::net::SnapshotMeta* snapshot_meta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (snapshot_meta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_meta);
    if (message_arena != submessage_arena) {
      snapshot_meta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_meta, submessage_arena);
    }
    set_has_snapshot_meta();
    _impl_.kind_.snapshot_meta_ = snapshot_meta;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.snapshot_meta)
}
void Frame::set_allocated_snapshot_chunk(::alyncoin::net::SnapshotChunk* snapshot_chunk) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (snapshot_chunk) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_chunk);
    if (message_arena != submessage_arena) {
      snapshot_chunk = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_chunk, submessage_arena);
    }
    set_has_snapshot_chunk();
    _impl_.kind_.snapshot_chunk_ = snapshot_chunk;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.snapshot_chunk)
}
void Frame::set_allocated_snapshot_ack(::alyncoin::net::SnapshotAck* snapshot_ack) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (snapshot_ack) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_ack);
    if (message_arena != submessage_arena) {
      snapshot_ack = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_ack, submessage_arena);
    }
    set_has_snapshot_ack();
    _impl_.kind_.snapshot_ack_ = snapshot_ack;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.snapshot_ack)
}
void Frame::set_allocated_snapshot_end(::alyncoin::net::SnapshotEnd* snapshot_end) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (snapshot_end) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_end);
    if (message_arena != submessage_arena) {
      snapshot_end = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_end, submessage_arena);
    }
    set_has_snapshot_end();
    _impl_.kind_.snapshot_end_ = snapshot_end;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.snapshot_end)
}
void Frame::set_allocated_tail_blocks(::alyncoin::net::TailBlocks* tail_blocks) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (tail_blocks) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tail_blocks);
    if (message_arena != submessage_arena) {
      tail_blocks = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_blocks, submessage_arena);
    }
    set_has_tail_blocks();
    _impl_.kind_.tail_blocks_ = tail_blocks;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.tail_blocks)
}
void Frame::set_allocated_agg_proof(::alyncoin::net::EpochProof* agg_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (agg_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(agg_proof);
    if (message_arena != submessage_arena) {
      agg_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, agg_proof, submessage_arena);
    }
    set_has_agg_proof();
    _impl_.kind_.agg_proof_ = agg_proof;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.agg_proof)
}
void Frame::set_allocated_inv(::alyncoin::net::Inventory* inv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (inv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(inv);
    if (message_arena != submessage_arena) {
      inv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, inv, submessage_arena);
    }
    set_has_inv();
    _impl_.kind_.inv_ = inv;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.inv)
}
void Frame::set_allocated_tip_hash_req(::alyncoin::net::TipHashRequest* tip_hash_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (tip_hash_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tip_hash_req);
    if (message_arena != submessage_arena) {
      tip_hash_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tip_hash_req, submessage_arena);
    }
    set_has_tip_hash_req();
    _impl_.kind_.tip_hash_req_ = tip_hash_req;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.tip_hash_req)
}
void Frame::set_allocated_tip_hash_res(::alyncoin::net::TipHashResponse* tip_hash_res) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (tip_hash_res) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tip_hash_res);
    if (message_arena != submessage_arena) {
      tip_hash_res = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tip_hash_res, submessage_arena);
    }
    set_has_tip_hash_res();
    _impl_.kind_.tip_hash_res_ = tip_hash_res;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.tip_hash_res)
}
void Frame::set_allocated_peer_list_req(::alyncoin::net::PeerListRequest* peer_list_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (peer_list_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peer_list_req);
    if (message_arena != submessage_arena) {
      peer_list_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_list_req, submessage_arena);
    }
    set_has_peer_list_req();
    _impl_.kind_.peer_list_req_ = peer_list_req;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.peer_list_req)
}
void Frame::set_allocated_peer_list(::alyncoin::net::PeerList* peer_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (peer_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(peer_list);
    if (message_arena != submessage_arena) {
      peer_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, peer_list, submessage_arena);
    }
    set_has_peer_list();
    _impl_.kind_.peer_list_ = peer_list;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.peer_list)
}
void Frame::set_allocated_rollup_block(::alyncoin::net::RollupBlockMsg* rollup_block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (rollup_block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rollup_block);
    if (message_arena != submessage_arena) {
      rollup_block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rollup_block, submessage_arena);
    }
    set_has_rollup_block();
    _impl_.kind_.rollup_block_ = rollup_block;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.rollup_block)
}
void Frame::set_allocated_snapshot_req(::alyncoin::net::SnapshotRequest* snapshot_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (snapshot_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(snapshot_req);
    if (message_arena != submessage_arena) {
      snapshot_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot_req, submessage_arena);
    }
    set_has_snapshot_req();
    _impl_.kind_.snapshot_req_ = snapshot_req;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.snapshot_req)
}
void Frame::set_allocated_tail_req(::alyncoin::net::TailBlocksRequest* tail_req) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (tail_req) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tail_req);
    if (message_arena != submessage_arena) {
      tail_req = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tail_req, submessage_arena);
    }
    set_has_tail_req();
    _impl_.kind_.tail_req_ = tail_req;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.tail_req)
}
void Frame::set_allocated_state_proof(::alyncoin::net::StateProof* state_proof) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (state_proof) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(state_proof);
    if (message_arena != submessage_arena) {
      state_proof = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, state_proof, submessage_arena);
    }
    set_has_state_proof();
    _impl_.kind_.state_proof_ = state_proof;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.state_proof)
}
void Frame::set_allocated_get_data(::alyncoin::net::GetData* get_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (get_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_data);
    if (message_arena != submessage_arena) {
      get_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_data, submessage_arena);
    }
    set_has_get_data();
    _impl_.kind_.get_data_ = get_data;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.get_data)
}
void Frame::set_allocated_blockchain_sync_request(::alyncoin::BlockchainSyncProto* blockchain_sync_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (blockchain_sync_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(blockchain_sync_request));
    if (message_arena != submessage_arena) {
      blockchain_sync_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, blockchain_sync_request, submessage_arena);
    }
    set_has_blockchain_sync_request();
    _impl_.kind_.blockchain_sync_request_ = blockchain_sync_request;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.blockchain_sync_request)
}
void Frame::clear_blockchain_sync_request() {
  if (_internal_has_blockchain_sync_request()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.kind_.blockchain_sync_request_;
    }
    clear_has_kind();
  }
}
void Frame::set_allocated_tx_broadcast(::alyncoin::net::TransactionBroadcast* tx_broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (tx_broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(tx_broadcast);
    if (message_arena != submessage_arena) {
      tx_broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tx_broadcast, submessage_arena);
    }
    set_has_tx_broadcast();
    _impl_.kind_.tx_broadcast_ = tx_broadcast;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.tx_broadcast)
}
void Frame::set_allocated_whisper(::alyncoin::net::Whisper* whisper) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (whisper) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(whisper);
    if (message_arena != submessage_arena) {
      whisper = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, whisper, submessage_arena);
    }
    set_has_whisper();
    _impl_.kind_.whisper_ = whisper;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.whisper)
}
void Frame::set_allocated_get_headers(::alyncoin::net::GetHeaders* get_headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (get_headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(get_headers);
    if (message_arena != submessage_arena) {
      get_headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, get_headers, submessage_arena);
    }
    set_has_get_headers();
    _impl_.kind_.get_headers_ = get_headers;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.get_headers)
}
void Frame::set_allocated_headers(::alyncoin::net::Headers* headers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_kind();
  if (headers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(headers);
    if (message_arena != submessage_arena) {
      headers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, headers, submessage_arena);
    }
    set_has_headers();
    _impl_.kind_.headers_ = headers;
  }
  // @@protoc_insertion_point(field_set_allocated:alyncoin.net.Frame.headers)
}
Frame::Frame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:alyncoin.net.Frame)
}
Frame::Frame(const Frame& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Frame* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.kind_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_kind();
  switch (from.kind_case()) {
    case kHandshake: {
      _this->_internal_mutable_handshake()->::alyncoin::net::Handshake::MergeFrom(
          from._internal_handshake());
      break;
    }
    case kPing: {
      _this->_internal_mutable_ping()->::alyncoin::net::Ping::MergeFrom(
          from._internal_ping());
      break;
    }
    case kPong: {
      _this->_internal_mutable_pong()->::alyncoin::net::Pong::MergeFrom(
          from._internal_pong());
      break;
    }
    case kHeightReq: {
      _this->_internal_mutable_height_req()->::alyncoin::net::HeightRequest::MergeFrom(
          from._internal_height_req());
      break;
    }
    case kHeightRes: {
      _this->_internal_mutable_height_res()->::alyncoin::net::HeightResponse::MergeFrom(
          from._internal_height_res());
      break;
    }
    case kHeightProbe: {
      _this->_internal_mutable_height_probe()->::alyncoin::net::HeightProbe::MergeFrom(
          from._internal_height_probe());
      break;
    }
    case kBlockBroadcast: {
      _this->_internal_mutable_block_broadcast()->::alyncoin::net::BlockBroadcast::MergeFrom(
          from._internal_block_broadcast());
      break;
    }
    case kBlockBatch: {
      _this->_internal_mutable_block_batch()->::alyncoin::net::BlockBatch::MergeFrom(
          from._internal_block_batch());
      break;
    }
    case kBlockRequest: {
      _this->_internal_mutable_block_request()->::alyncoin::net::BlockRequest::MergeFrom(
          from._internal_block_request());
      break;
    }
    case kBlockResponse: {
      _this->_internal_mutable_block_response()->::alyncoin::net::BlockResponse::MergeFrom(
          from._internal_block_response());
      break;
    }
    case kSnapshotMeta: {
      _this->_internal_mutable_snapshot_meta()->::alyncoin::net::SnapshotMeta::MergeFrom(
          from._internal_snapshot_meta());
      break;
    }
    case kSnapshotChunk: {
      _this->_internal_mutable_snapshot_chunk()->::alyncoin::net::SnapshotChunk::MergeFrom(
          from._internal_snapshot_chunk());
      break;
    }
    case kSnapshotAck: {
      _this->_internal_mutable_snapshot_ack()->::alyncoin::net::SnapshotAck::MergeFrom(
          from._internal_snapshot_ack());
      break;
    }
    case kSnapshotEnd: {
      _this->_internal_mutable_snapshot_end()->::alyncoin::net::SnapshotEnd::MergeFrom(
          from._internal_snapshot_end());
      break;
    }
    case kTailBlocks: {
      _this->_internal_mutable_tail_blocks()->::alyncoin::net::TailBlocks::MergeFrom(
          from._internal_tail_blocks());
      break;
    }
    case kAggProof: {
      _this->_internal_mutable_agg_proof()->::alyncoin::net::EpochProof::MergeFrom(
          from._internal_agg_proof());
      break;
    }
    case kInv: {
      _this->_internal_mutable_inv()->::alyncoin::net::Inventory::MergeFrom(
          from._internal_inv());
      break;
    }
    case kTipHashReq: {
      _this->_internal_mutable_tip_hash_req()->::alyncoin::net::TipHashRequest::MergeFrom(
          from._internal_tip_hash_req());
      break;
    }
    case kTipHashRes: {
      _this->_internal_mutable_tip_hash_res()->::alyncoin::net::TipHashResponse::MergeFrom(
          from._internal_tip_hash_res());
      break;
    }
    case kPeerListReq: {
      _this->_internal_mutable_peer_list_req()->::alyncoin::net::PeerListRequest::MergeFrom(
          from._internal_peer_list_req());
      break;
    }
    case kPeerList: {
      _this->_internal_mutable_peer_list()->::alyncoin::net::PeerList::MergeFrom(
          from._internal_peer_list());
      break;
    }
    case kRollupBlock: {
      _this->_internal_mutable_rollup_block()->::alyncoin::net::RollupBlockMsg::MergeFrom(
          from._internal_rollup_block());
      break;
    }
    case kSnapshotReq: {
      _this->_internal_mutable_snapshot_req()->::alyncoin::net::SnapshotRequest::MergeFrom(
          from._internal_snapshot_req());
      break;
    }
    case kTailReq: {
      _this->_internal_mutable_tail_req()->::alyncoin::net::TailBlocksRequest::MergeFrom(
          from._internal_tail_req());
      break;
    }
    case kStateProof: {
      _this->_internal_mutable_state_proof()->::alyncoin::net::StateProof::MergeFrom(
          from._internal_state_proof());
      break;
    }
    case kGetData: {
      _this->_internal_mutable_get_data()->::alyncoin::net::GetData::MergeFrom(
          from._internal_get_data());
      break;
    }
    case kBlockchainSyncRequest: {
      _this->_internal_mutable_blockchain_sync_request()->::alyncoin::BlockchainSyncProto::MergeFrom(
          from._internal_blockchain_sync_request());
      break;
    }
    case kTxBroadcast: {
      _this->_internal_mutable_tx_broadcast()->::alyncoin::net::TransactionBroadcast::MergeFrom(
          from._internal_tx_broadcast());
      break;
    }
    case kWhisper: {
      _this->_internal_mutable_whisper()->::alyncoin::net::Whisper::MergeFrom(
          from._internal_whisper());
      break;
    }
    case kGetHeaders: {
      _this->_internal_mutable_get_headers()->::alyncoin::net::GetHeaders::MergeFrom(
          from._internal_get_headers());
      break;
    }
    case kHeaders: {
      _this->_internal_mutable_headers()->::alyncoin::net::Headers::MergeFrom(
          from._internal_headers());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:alyncoin.net.Frame)
}

inline void Frame::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.kind_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_kind();
}

Frame::~Frame() {
  // @@protoc_insertion_point(destructor:alyncoin.net.Frame)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Frame::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_kind()) {
    clear_kind();
  }
}

void Frame::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Frame::clear_kind() {
// @@protoc_insertion_point(one_of_clear_start:alyncoin.net.Frame)
  switch (kind_case()) {
    case kHandshake: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.handshake_;
      }
      break;
    }
    case kPing: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.ping_;
      }
      break;
    }
    case kPong: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.pong_;
      }
      break;
    }
    case kHeightReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.height_req_;
      }
      break;
    }
    case kHeightRes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.height_res_;
      }
      break;
    }
    case kHeightProbe: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.height_probe_;
      }
      break;
    }
    case kBlockBroadcast: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.block_broadcast_;
      }
      break;
    }
    case kBlockBatch: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.block_batch_;
      }
      break;
    }
    case kBlockRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.block_request_;
      }
      break;
    }
    case kBlockResponse: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.block_response_;
      }
      break;
    }
    case kSnapshotMeta: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.snapshot_meta_;
      }
      break;
    }
    case kSnapshotChunk: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.snapshot_chunk_;
      }
      break;
    }
    case kSnapshotAck: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.snapshot_ack_;
      }
      break;
    }
    case kSnapshotEnd: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.snapshot_end_;
      }
      break;
    }
    case kTailBlocks: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.tail_blocks_;
      }
      break;
    }
    case kAggProof: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.agg_proof_;
      }
      break;
    }
    case kInv: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.inv_;
      }
      break;
    }
    case kTipHashReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.tip_hash_req_;
      }
      break;
    }
    case kTipHashRes: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.tip_hash_res_;
      }
      break;
    }
    case kPeerListReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.peer_list_req_;
      }
      break;
    }
    case kPeerList: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.peer_list_;
      }
      break;
    }
    case kRollupBlock: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.rollup_block_;
      }
      break;
    }
    case kSnapshotReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.snapshot_req_;
      }
      break;
    }
    case kTailReq: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.tail_req_;
      }
      break;
    }
    case kStateProof: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.state_proof_;
      }
      break;
    }
    case kGetData: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.get_data_;
      }
      break;
    }
    case kBlockchainSyncRequest: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.blockchain_sync_request_;
      }
      break;
    }
    case kTxBroadcast: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.tx_broadcast_;
      }
      break;
    }
    case kWhisper: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.whisper_;
      }
      break;
    }
    case kGetHeaders: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.get_headers_;
      }
      break;
    }
    case kHeaders: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.kind_.headers_;
      }
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = KIND_NOT_SET;
}


void Frame::Clear() {
// @@protoc_insertion_point(message_clear_start:alyncoin.net.Frame)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_kind();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Frame::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .alyncoin.net.Handshake handshake = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_handshake(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.Ping ping = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ping(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.Pong pong = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_pong(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.HeightRequest height_req = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_height_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.HeightResponse height_res = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_height_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.BlockBroadcast block_broadcast = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_broadcast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.BlockBatch block_batch = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_batch(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.SnapshotMeta snapshot_meta = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot_meta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.SnapshotChunk snapshot_chunk = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot_chunk(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.SnapshotAck snapshot_ack = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot_ack(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.SnapshotEnd snapshot_end = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.TailBlocks tail_blocks = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_blocks(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.EpochProof agg_proof = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_agg_proof(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.Inventory inv = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_inv(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.TipHashRequest tip_hash_req = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr = ctx->ParseMessage(_internal_mutable_tip_hash_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.TipHashResponse tip_hash_res = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr = ctx->ParseMessage(_internal_mutable_tip_hash_res(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.PeerListRequest peer_list_req = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr = ctx->ParseMessage(_internal_mutable_peer_list_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.PeerList peer_list = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr = ctx->ParseMessage(_internal_mutable_peer_list(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.RollupBlockMsg rollup_block = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_rollup_block(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.SnapshotRequest snapshot_req = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_snapshot_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.TailBlocksRequest tail_req = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_tail_req(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.StateProof state_proof = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_state_proof(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.GetData get_data = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_data(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.BlockchainSyncProto blockchain_sync_request = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 194)) {
          ptr = ctx->ParseMessage(_internal_mutable_blockchain_sync_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.TransactionBroadcast tx_broadcast = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 202)) {
          ptr = ctx->ParseMessage(_internal_mutable_tx_broadcast(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.Whisper whisper = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 210)) {
          ptr = ctx->ParseMessage(_internal_mutable_whisper(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.GetHeaders get_headers = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 218)) {
          ptr = ctx->ParseMessage(_internal_mutable_get_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.Headers headers = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 226)) {
          ptr = ctx->ParseMessage(_internal_mutable_headers(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.BlockRequest block_request = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 234)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_request(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.BlockResponse block_response = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr = ctx->ParseMessage(_internal_mutable_block_response(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .alyncoin.net.HeightProbe height_probe = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr = ctx->ParseMessage(_internal_mutable_height_probe(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Frame::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:alyncoin.net.Frame)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .alyncoin.net.Handshake handshake = 1;
  if (_internal_has_handshake()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::handshake(this),
        _Internal::handshake(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.Ping ping = 2;
  if (_internal_has_ping()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ping(this),
        _Internal::ping(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.Pong pong = 3;
  if (_internal_has_pong()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::pong(this),
        _Internal::pong(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.HeightRequest height_req = 4;
  if (_internal_has_height_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::height_req(this),
        _Internal::height_req(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.HeightResponse height_res = 5;
  if (_internal_has_height_res()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::height_res(this),
        _Internal::height_res(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.BlockBroadcast block_broadcast = 6;
  if (_internal_has_block_broadcast()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::block_broadcast(this),
        _Internal::block_broadcast(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.BlockBatch block_batch = 7;
  if (_internal_has_block_batch()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::block_batch(this),
        _Internal::block_batch(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.SnapshotMeta snapshot_meta = 8;
  if (_internal_has_snapshot_meta()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::snapshot_meta(this),
        _Internal::snapshot_meta(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.SnapshotChunk snapshot_chunk = 9;
  if (_internal_has_snapshot_chunk()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::snapshot_chunk(this),
        _Internal::snapshot_chunk(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.SnapshotAck snapshot_ack = 10;
  if (_internal_has_snapshot_ack()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::snapshot_ack(this),
        _Internal::snapshot_ack(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.SnapshotEnd snapshot_end = 11;
  if (_internal_has_snapshot_end()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::snapshot_end(this),
        _Internal::snapshot_end(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.TailBlocks tail_blocks = 12;
  if (_internal_has_tail_blocks()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::tail_blocks(this),
        _Internal::tail_blocks(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.EpochProof agg_proof = 13;
  if (_internal_has_agg_proof()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(13, _Internal::agg_proof(this),
        _Internal::agg_proof(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.Inventory inv = 14;
  if (_internal_has_inv()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::inv(this),
        _Internal::inv(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.TipHashRequest tip_hash_req = 15;
  if (_internal_has_tip_hash_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(15, _Internal::tip_hash_req(this),
        _Internal::tip_hash_req(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.TipHashResponse tip_hash_res = 16;
  if (_internal_has_tip_hash_res()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(16, _Internal::tip_hash_res(this),
        _Internal::tip_hash_res(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.PeerListRequest peer_list_req = 17;
  if (_internal_has_peer_list_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(17, _Internal::peer_list_req(this),
        _Internal::peer_list_req(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.PeerList peer_list = 18;
  if (_internal_has_peer_list()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, _Internal::peer_list(this),
        _Internal::peer_list(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.RollupBlockMsg rollup_block = 19;
  if (_internal_has_rollup_block()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::rollup_block(this),
        _Internal::rollup_block(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.SnapshotRequest snapshot_req = 20;
  if (_internal_has_snapshot_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::snapshot_req(this),
        _Internal::snapshot_req(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.TailBlocksRequest tail_req = 21;
  if (_internal_has_tail_req()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::tail_req(this),
        _Internal::tail_req(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.StateProof state_proof = 22;
  if (_internal_has_state_proof()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::state_proof(this),
        _Internal::state_proof(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.GetData get_data = 23;
  if (_internal_has_get_data()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::get_data(this),
        _Internal::get_data(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.BlockchainSyncProto blockchain_sync_request = 24;
  if (_internal_has_blockchain_sync_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(24, _Internal::blockchain_sync_request(this),
        _Internal::blockchain_sync_request(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.TransactionBroadcast tx_broadcast = 25;
  if (_internal_has_tx_broadcast()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(25, _Internal::tx_broadcast(this),
        _Internal::tx_broadcast(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.Whisper whisper = 26;
  if (_internal_has_whisper()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(26, _Internal::whisper(this),
        _Internal::whisper(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.GetHeaders get_headers = 27;
  if (_internal_has_get_headers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(27, _Internal::get_headers(this),
        _Internal::get_headers(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.Headers headers = 28;
  if (_internal_has_headers()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(28, _Internal::headers(this),
        _Internal::headers(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.BlockRequest block_request = 29;
  if (_internal_has_block_request()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(29, _Internal::block_request(this),
        _Internal::block_request(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.BlockResponse block_response = 30;
  if (_internal_has_block_response()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(30, _Internal::block_response(this),
        _Internal::block_response(this).GetCachedSize(), target, stream);
  }

  // .alyncoin.net.HeightProbe height_probe = 31;
  if (_internal_has_height_probe()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(31, _Internal::height_probe(this),
        _Internal::height_probe(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:alyncoin.net.Frame)
  return target;
}

size_t Frame::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:alyncoin.net.Frame)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (kind_case()) {
    // .alyncoin.net.Handshake handshake = 1;
    case kHandshake: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.handshake_);
      break;
    }
    // .alyncoin.net.Ping ping = 2;
    case kPing: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.ping_);
      break;
    }
    // .alyncoin.net.Pong pong = 3;
    case kPong: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.pong_);
      break;
    }
    // .alyncoin.net.HeightRequest height_req = 4;
    case kHeightReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.height_req_);
      break;
    }
    // .alyncoin.net.HeightResponse height_res = 5;
    case kHeightRes: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.height_res_);
      break;
    }
    // .alyncoin.net.HeightProbe height_probe = 31;
    case kHeightProbe: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.height_probe_);
      break;
    }
    // .alyncoin.net.BlockBroadcast block_broadcast = 6;
    case kBlockBroadcast: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.block_broadcast_);
      break;
    }
    // .alyncoin.net.BlockBatch block_batch = 7;
    case kBlockBatch: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.block_batch_);
      break;
    }
    // .alyncoin.net.BlockRequest block_request = 29;
    case kBlockRequest: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.block_request_);
      break;
    }
    // .alyncoin.net.BlockResponse block_response = 30;
    case kBlockResponse: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.block_response_);
      break;
    }
    // .alyncoin.net.SnapshotMeta snapshot_meta = 8;
    case kSnapshotMeta: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.snapshot_meta_);
      break;
    }
    // .alyncoin.net.SnapshotChunk snapshot_chunk = 9;
    case kSnapshotChunk: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.snapshot_chunk_);
      break;
    }
    // .alyncoin.net.SnapshotAck snapshot_ack = 10;
    case kSnapshotAck: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.snapshot_ack_);
      break;
    }
    // .alyncoin.net.SnapshotEnd snapshot_end = 11;
    case kSnapshotEnd: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.snapshot_end_);
      break;
    }
    // .alyncoin.net.TailBlocks tail_blocks = 12;
    case kTailBlocks: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.tail_blocks_);
      break;
    }
    // .alyncoin.net.EpochProof agg_proof = 13;
    case kAggProof: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.agg_proof_);
      break;
    }
    // .alyncoin.net.Inventory inv = 14;
    case kInv: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.inv_);
      break;
    }
    // .alyncoin.net.TipHashRequest tip_hash_req = 15;
    case kTipHashReq: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.tip_hash_req_);
      break;
    }
    // .alyncoin.net.TipHashResponse tip_hash_res = 16;
    case kTipHashRes: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.tip_hash_res_);
      break;
    }
    // .alyncoin.net.PeerListRequest peer_list_req = 17;
    case kPeerListReq: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.peer_list_req_);
      break;
    }
    // .alyncoin.net.PeerList peer_list = 18;
    case kPeerList: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.peer_list_);
      break;
    }
    // .alyncoin.net.RollupBlockMsg rollup_block = 19;
    case kRollupBlock: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.rollup_block_);
      break;
    }
    // .alyncoin.net.SnapshotRequest snapshot_req = 20;
    case kSnapshotReq: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.snapshot_req_);
      break;
    }
    // .alyncoin.net.TailBlocksRequest tail_req = 21;
    case kTailReq: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.tail_req_);
      break;
    }
    // .alyncoin.net.StateProof state_proof = 22;
    case kStateProof: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.state_proof_);
      break;
    }
    // .alyncoin.net.GetData get_data = 23;
    case kGetData: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.get_data_);
      break;
    }
    // .alyncoin.BlockchainSyncProto blockchain_sync_request = 24;
    case kBlockchainSyncRequest: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.blockchain_sync_request_);
      break;
    }
    // .alyncoin.net.TransactionBroadcast tx_broadcast = 25;
    case kTxBroadcast: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.tx_broadcast_);
      break;
    }
    // .alyncoin.net.Whisper whisper = 26;
    case kWhisper: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.whisper_);
      break;
    }
    // .alyncoin.net.GetHeaders get_headers = 27;
    case kGetHeaders: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.get_headers_);
      break;
    }
    // .alyncoin.net.Headers headers = 28;
    case kHeaders: {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.kind_.headers_);
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Frame::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Frame::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Frame::GetClassData() const { return &_class_data_; }


void Frame::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Frame*>(&to_msg);
  auto& from = static_cast<const Frame&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:alyncoin.net.Frame)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.kind_case()) {
    case kHandshake: {
      _this->_internal_mutable_handshake()->::alyncoin::net::Handshake::MergeFrom(
          from._internal_handshake());
      break;
    }
    case kPing: {
      _this->_internal_mutable_ping()->::alyncoin::net::Ping::MergeFrom(
          from._internal_ping());
      break;
    }
    case kPong: {
      _this->_internal_mutable_pong()->::alyncoin::net::Pong::MergeFrom(
          from._internal_pong());
      break;
    }
    case kHeightReq: {
      _this->_internal_mutable_height_req()->::alyncoin::net::HeightRequest::MergeFrom(
          from._internal_height_req());
      break;
    }
    case kHeightRes: {
      _this->_internal_mutable_height_res()->::alyncoin::net::HeightResponse::MergeFrom(
          from._internal_height_res());
      break;
    }
    case kHeightProbe: {
      _this->_internal_mutable_height_probe()->::alyncoin::net::HeightProbe::MergeFrom(
          from._internal_height_probe());
      break;
    }
    case kBlockBroadcast: {
      _this->_internal_mutable_block_broadcast()->::alyncoin::net::BlockBroadcast::MergeFrom(
          from._internal_block_broadcast());
      break;
    }
    case kBlockBatch: {
      _this->_internal_mutable_block_batch()->::alyncoin::net::BlockBatch::MergeFrom(
          from._internal_block_batch());
      break;
    }
    case kBlockRequest: {
      _this->_internal_mutable_block_request()->::alyncoin::net::BlockRequest::MergeFrom(
          from._internal_block_request());
      break;
    }
    case kBlockResponse: {
      _this->_internal_mutable_block_response()->::alyncoin::net::BlockResponse::MergeFrom(
          from._internal_block_response());
      break;
    }
    case kSnapshotMeta: {
      _this->_internal_mutable_snapshot_meta()->::alyncoin::net::SnapshotMeta::MergeFrom(
          from._internal_snapshot_meta());
      break;
    }
    case kSnapshotChunk: {
      _this->_internal_mutable_snapshot_chunk()->::alyncoin::net::SnapshotChunk::MergeFrom(
          from._internal_snapshot_chunk());
      break;
    }
    case kSnapshotAck: {
      _this->_internal_mutable_snapshot_ack()->::alyncoin::net::SnapshotAck::MergeFrom(
          from._internal_snapshot_ack());
      break;
    }
    case kSnapshotEnd: {
      _this->_internal_mutable_snapshot_end()->::alyncoin::net::SnapshotEnd::MergeFrom(
          from._internal_snapshot_end());
      break;
    }
    case kTailBlocks: {
      _this->_internal_mutable_tail_blocks()->::alyncoin::net::TailBlocks::MergeFrom(
          from._internal_tail_blocks());
      break;
    }
    case kAggProof: {
      _this->_internal_mutable_agg_proof()->::alyncoin::net::EpochProof::MergeFrom(
          from._internal_agg_proof());
      break;
    }
    case kInv: {
      _this->_internal_mutable_inv()->::alyncoin::net::Inventory::MergeFrom(
          from._internal_inv());
      break;
    }
    case kTipHashReq: {
      _this->_internal_mutable_tip_hash_req()->::alyncoin::net::TipHashRequest::MergeFrom(
          from._internal_tip_hash_req());
      break;
    }
    case kTipHashRes: {
      _this->_internal_mutable_tip_hash_res()->::alyncoin::net::TipHashResponse::MergeFrom(
          from._internal_tip_hash_res());
      break;
    }
    case kPeerListReq: {
      _this->_internal_mutable_peer_list_req()->::alyncoin::net::PeerListRequest::MergeFrom(
          from._internal_peer_list_req());
      break;
    }
    case kPeerList: {
      _this->_internal_mutable_peer_list()->::alyncoin::net::PeerList::MergeFrom(
          from._internal_peer_list());
      break;
    }
    case kRollupBlock: {
      _this->_internal_mutable_rollup_block()->::alyncoin::net::RollupBlockMsg::MergeFrom(
          from._internal_rollup_block());
      break;
    }
    case kSnapshotReq: {
      _this->_internal_mutable_snapshot_req()->::alyncoin::net::SnapshotRequest::MergeFrom(
          from._internal_snapshot_req());
      break;
    }
    case kTailReq: {
      _this->_internal_mutable_tail_req()->::alyncoin::net::TailBlocksRequest::MergeFrom(
          from._internal_tail_req());
      break;
    }
    case kStateProof: {
      _this->_internal_mutable_state_proof()->::alyncoin::net::StateProof::MergeFrom(
          from._internal_state_proof());
      break;
    }
    case kGetData: {
      _this->_internal_mutable_get_data()->::alyncoin::net::GetData::MergeFrom(
          from._internal_get_data());
      break;
    }
    case kBlockchainSyncRequest: {
      _this->_internal_mutable_blockchain_sync_request()->::alyncoin::BlockchainSyncProto::MergeFrom(
          from._internal_blockchain_sync_request());
      break;
    }
    case kTxBroadcast: {
      _this->_internal_mutable_tx_broadcast()->::alyncoin::net::TransactionBroadcast::MergeFrom(
          from._internal_tx_broadcast());
      break;
    }
    case kWhisper: {
      _this->_internal_mutable_whisper()->::alyncoin::net::Whisper::MergeFrom(
          from._internal_whisper());
      break;
    }
    case kGetHeaders: {
      _this->_internal_mutable_get_headers()->::alyncoin::net::GetHeaders::MergeFrom(
          from._internal_get_headers());
      break;
    }
    case kHeaders: {
      _this->_internal_mutable_headers()->::alyncoin::net::Headers::MergeFrom(
          from._internal_headers());
      break;
    }
    case KIND_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Frame::CopyFrom(const Frame& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:alyncoin.net.Frame)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Frame::IsInitialized() const {
  return true;
}

void Frame::InternalSwap(Frame* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.kind_, other->_impl_.kind_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata Frame::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_net_5fframe_2eproto_getter, &descriptor_table_net_5fframe_2eproto_once,
      file_level_metadata_net_5fframe_2eproto[30]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace net
}  // namespace alyncoin
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::alyncoin::net::Handshake*
Arena::CreateMaybeMessage< ::alyncoin::net::Handshake >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Handshake >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::Ping*
Arena::CreateMaybeMessage< ::alyncoin::net::Ping >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Ping >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::Pong*
Arena::CreateMaybeMessage< ::alyncoin::net::Pong >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Pong >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::HeightRequest*
Arena::CreateMaybeMessage< ::alyncoin::net::HeightRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::HeightRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::HeightResponse*
Arena::CreateMaybeMessage< ::alyncoin::net::HeightResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::HeightResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::HeightProbe*
Arena::CreateMaybeMessage< ::alyncoin::net::HeightProbe >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::HeightProbe >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::BlockBroadcast*
Arena::CreateMaybeMessage< ::alyncoin::net::BlockBroadcast >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::BlockBroadcast >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::BlockBatch*
Arena::CreateMaybeMessage< ::alyncoin::net::BlockBatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::BlockBatch >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::BlockRequest*
Arena::CreateMaybeMessage< ::alyncoin::net::BlockRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::BlockRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::BlockResponse*
Arena::CreateMaybeMessage< ::alyncoin::net::BlockResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::BlockResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::SnapshotMeta*
Arena::CreateMaybeMessage< ::alyncoin::net::SnapshotMeta >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::SnapshotMeta >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::SnapshotChunk*
Arena::CreateMaybeMessage< ::alyncoin::net::SnapshotChunk >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::SnapshotChunk >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::SnapshotAck*
Arena::CreateMaybeMessage< ::alyncoin::net::SnapshotAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::SnapshotAck >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::SnapshotEnd*
Arena::CreateMaybeMessage< ::alyncoin::net::SnapshotEnd >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::SnapshotEnd >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::TailBlocks*
Arena::CreateMaybeMessage< ::alyncoin::net::TailBlocks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::TailBlocks >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::EpochProof*
Arena::CreateMaybeMessage< ::alyncoin::net::EpochProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::EpochProof >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::Inventory*
Arena::CreateMaybeMessage< ::alyncoin::net::Inventory >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Inventory >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::TipHashRequest*
Arena::CreateMaybeMessage< ::alyncoin::net::TipHashRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::TipHashRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::TipHashResponse*
Arena::CreateMaybeMessage< ::alyncoin::net::TipHashResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::TipHashResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::PeerListRequest*
Arena::CreateMaybeMessage< ::alyncoin::net::PeerListRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::PeerListRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::PeerList*
Arena::CreateMaybeMessage< ::alyncoin::net::PeerList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::PeerList >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::RollupBlockMsg*
Arena::CreateMaybeMessage< ::alyncoin::net::RollupBlockMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::RollupBlockMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::SnapshotRequest*
Arena::CreateMaybeMessage< ::alyncoin::net::SnapshotRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::SnapshotRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::TailBlocksRequest*
Arena::CreateMaybeMessage< ::alyncoin::net::TailBlocksRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::TailBlocksRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::GetData*
Arena::CreateMaybeMessage< ::alyncoin::net::GetData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::GetData >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::GetHeaders*
Arena::CreateMaybeMessage< ::alyncoin::net::GetHeaders >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::GetHeaders >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::Headers*
Arena::CreateMaybeMessage< ::alyncoin::net::Headers >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Headers >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::StateProof*
Arena::CreateMaybeMessage< ::alyncoin::net::StateProof >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::StateProof >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::TransactionBroadcast*
Arena::CreateMaybeMessage< ::alyncoin::net::TransactionBroadcast >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::TransactionBroadcast >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::Whisper*
Arena::CreateMaybeMessage< ::alyncoin::net::Whisper >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Whisper >(arena);
}
template<> PROTOBUF_NOINLINE ::alyncoin::net::Frame*
Arena::CreateMaybeMessage< ::alyncoin::net::Frame >(Arena* arena) {
  return Arena::CreateMessageInternal< ::alyncoin::net::Frame >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
